---
lang: ko-KR
title: Day 99
description: üïäÔ∏è100 Days of Swift > Day 99
category:
  - üïäÔ∏èSwift
tag: 
  - crashcourse
  - paul-hudson
  - swift
  - hacking-with-swift
  - xcode
  - appstore
head:
  - - meta:
    - property: og:title
      content: üïäÔ∏è100 Days of Swift > Day 99
    - property: og:description
      content: Day 99
    - property: og:url
      content: https://chanhi2000.github.io/crashcourse/swift/100-days-of-swift/99.html
---

# {{ $frontmatter.title }} Í¥ÄÎ†®

> {{ $frontmatter.description }}

[[toc]]

---

```component VPCard
{
  "title": "100 Days of Swift - Day 99",
  "desc": "Milestone (Projects 28-30)",
  "link": "https://www.hackingwithswift.com/100/99",
  "logo": "https://www.hackingwithswift.com/favicon-96x96.png",
  "background": "rgb(213,52,58,0.2)"
}
```

## Milestone: Projects 28-30

Today is the last consolidation day of this 100 Days challenge, and we‚Äôll be looking over what you‚Äôve learned before diving straight into your toughest challenge yet.

I know the thought of a tough challenge might not be welcome at this point, because you‚Äôre almost certainly tired. But as the Greek philosopher Epictetus once said, ‚Äúthe greater the difficulty the more glory in surmounting it‚Äù ‚Äì this is a biggie, but you‚Äôll feel _great_ when you‚Äôre done because you‚Äôll have had to exercise so many of the skills you‚Äôve learned over these past few months.

Although biometric authentication is an interesting topic ‚Äì and certainly an important one if you happen to be on a team building apps for a bank! ‚Äì the real highlights of these last days have been more Core Graphics practice and dipping a toe in Instruments. Both of these are skills that will last you years. Sure, you might not remember the exact code required to make clipping masks in Core Graphics, or the precise button to press in Instruments to find the problem you‚Äôre hunting for, but you know _where_ to look, and, more importantly, you know _what_ you‚Äôre looking for.

As you might have learned yourself, when you‚Äôre facing a problem half the battle is figuring out what you‚Äôre looking for ‚Äì what words to use, or even vaguely what kind of UIKit class might contain your answer. Since this course started you‚Äôve gained so much experience across so many of Apple‚Äôs frameworks, but you will already have forgotten half of it.

And you know what? That‚Äôs OK. In fact, that‚Äôs _normal_. What you _haven‚Äôt_ lost is all the code you wrote, which you can use as a reference for all your projects going forward. You also haven‚Äôt lost the _concepts_ ‚Äì you‚Äôre used to the idea of a table view delegate now, just like you‚Äôre used to storyboards, or view controllers, or `Codable`, and more. Those are the things that last, and, helpfully, those are the things that _matter_.

__Today you have three topics to work through, one of which of is your challenge.__

### What you learned

::: details What you learned

```component VPCard
{
  "title": "100 Days of Swift - Day 99 - What you learned",
  "desc": "What you learned",
  "link": "https://hackingwithswift.com/guide/11/1/what-you-learned",
  "logo": "https://www.hackingwithswift.com/favicon-96x96.png",
  "background": "rgb(213,52,58,0.2)"
}
```

Project 29 was a serious game with a lot going on, not least the dynamically rendered buildings with destructible terrain, the scene transitions and the UIKit/SpriteKit integration.

And in project 30 we took our first steps outside of Xcode and into Instruments. I could write a whole book on Instruments, partly because it‚Äôs extremely powerful, but also because it‚Äôs extremely complicated. As per usual, I tried to cherrypick things so you can see useful, practical benefits from what I was teaching, and certainly you have the skills now to be able to diagnose and result a variety of performance problems on iOS.

Here are some of the things you learned in this milestone:

- How to access the keychain using SwiftKeychainWrapper.
- How to force the keyboard to disappear by calling `resignFirstResponder()` on a text view. (And remember: it also works on text fields.)
- How to detect when your app is moving to the background by registering for the `UIApplication.willResignActiveNotification` notification.
- How to use `LAContext` from the LocalAuthentication framework to require Touch ID authentication.
- Using the `stride()` function to loop across a range of numbers using a specific increment, e.g. from 0 to 100 in tens.
- Creating colors using the hue, saturation, and brightness. As I said, keeping the saturation and brightness constant while choosing different hues helps you create similar color palettes easily.
- SpriteKit texture atlases. These are automatically made by Xcode if you place images into a folder with the .atlas extension, and are drawn significantly quicker than regular graphics.
- Using `usesPreciseCollisionDetection` to make collisions work better with small, fast-moving physics bodies.
- Transitioning between scenes with the `presentScene()` method and passing in a transition effect. We‚Äôll be using this again in project 36, so you‚Äôll have ample time to practice transitions.
- Using the blend mode `.clear` to erase parts of an image. Once that was done, we just recalculated the pixel-perfect physics to get destructible terrain.
- Adding dynamic shadows to views using `layer.shadowRadius` and other properties ‚Äì and particularly how to use the `layer.shadowPath` property to save shadow calculation.
- The importance of using `dequeueReusableCell(withIdentifier:)` so that iOS can re-use cells rather than continually creating new ones.
- How the `UIImage(named:)` initializer has an automatic cache to help load common images. When you don‚Äôt need that, use the `UIImage(contentsOfFile:)` initializer instead.

:::

### Key points

::: details Key points

```component VPCard
{
  "title": "100 Days of Swift - Day 99 - Key points",
  "desc": "Key points",
  "link": "https://hackingwithswift.com/guide/11/2/key-points",
  "logo": "https://www.hackingwithswift.com/favicon-96x96.png",
  "background": "rgb(213,52,58,0.2)"
}

```

There are two things I‚Äôd like to review for this milestone.

First, the weak keyword. We used it in project 29 to add a property to our game scene:

```swift
weak var viewController: GameViewController!
```

We also added the opposite property to the game view controller:

```swift
var currentGame: GameScene!
```

This approach allowed the game scene to call methods on the view controller, and vice versa. At the time I explained why one was `weak` and the other was not ‚Äì do you remember? I hope so, because it‚Äôs important!

There are four possibilities:

1. Game scene holds strong view controller and view controller holds strong game scene.
2. Game scene holds strong view controller and view controller holds weak game scene.
3. Game scene holds weak view controller and view controller holds weak game scene.
4. Game scene holds weak view controller and view controller holds strong game scene.

Remember, ‚Äústrong‚Äù means ‚ÄúI want to own this; don‚Äôt let this memory be destroyed until I‚Äôm done with it,‚Äù and weak means ‚ÄúI want to use this but I don‚Äôt want to own it; I‚Äôm OK if it gets destroyed, so don‚Äôt keep it around on my account.‚Äù

Now, the view controller has an `SKView`, which is what renders SpriteKit content. That‚Äôs owned strongly, because obviously the view controller can‚Äôt really work without something to draw to. And that `SKView` has a `scene` property, which is the current `SKScene` visible on the screen. That‚Äôs _also_ strongly owned. As a result, the view controller already - albeit indirectly ‚Äì has strong ownership of the game scene.

As a result, both options 1 and 2 will cause a strong reference cycle, because they would cause the game scene to have a strong reference to something that has a strong reference back to the game scene. This isn‚Äôt necessarily _bad_ as long as you remember to break the strong reference cycle, but let‚Äôs face it: why take the risk?

That leaves options 3 and 4: both have the game scene using a `weak` reference to the view controller, but one has a weak reference going back the other way and the other has a strong one. Which is better? Honestly, I‚Äôm not sure it matters: using a strong reference wouldn‚Äôt result in anything new because there‚Äôs already the indirect strong reference in place. So, use whichever you prefer!

The second thing I‚Äôd like to cover is much easier: it‚Äôs the `UIImage(contentsOfFile:)` initializer for `UIImage`. Like I said in project 30, the `UIImage(named:)` initializer has a built-in cache system to help load and store commonly used images ‚Äì anything you load with that initializer will automatically be cached, and so load instantly if you request it again.

Of course, if you _don‚Äôt_ want something to be cached, that‚Äôs the wrong solution, which is where `UIImage(contentsOfFile:)` comes in: give it a path and it will load the image, with no magic caching ever happening.

The downside is that `UIImage(named:)` automatically finds images inside your app bundle, whereas `UIImage(contentsOfFile:)` does not. So, you need to write code like this:

```swift
let path = Bundle.main.path(forResource: someImage, ofType: nil)!
imageView.image = UIImage(contentsOfFile: path)
```

That‚Äôs hardly a lot of code, but it‚Äôs never nice writing even simple repetitive code ‚Äì and look at that force unwrap after `path()`! Wouldn‚Äôt it be great to get rid of it? I‚Äôm going to show you how to do just that, and, as a bonus, I‚Äôm also going to teach you something new: convenience initializers.

You‚Äôve already seen initializers ‚Äì we‚Äôve used dozens of them. They are special methods that create things, like `UILabel()` or `UIImage(named:)`. Swift has complex rules about its initializers, all designed to stop you trying to access something that hasn‚Äôt been created yet.

Fortunately, there‚Äôs one _easy_ part, which is convenience initializers, which are effectively wrappers around basic initializers that are designed to make coding a bit more pleasant. A convenience initializer is able to do some work before calling a regular initializer, which in our case means we can add a wrapper around `UIImage(contentsOfFile:)` so that it‚Äôs nicer to call.

To make things even better, we‚Äôre also going to get rid of the force unwrap. Remember, `path(forResource:)` can return nil because the file you requested might not exist. Force unwrapping it works on occasion if you know something definitely exists, but it‚Äôs usually a better idea to use an alternative such as failable initializers.

You‚Äôve already used failable initializers several times ‚Äì both `UIImage(named:)` and `UIImage(contentsOfFile:)` are failable, for example. A failable initializer is one that might return a valid created object, or it might fail and return nil. We‚Äôre going to use this so that we can return `nil` if the image name can‚Äôt be found in the app bundle.

So, leveraging the power of Swift extensions that you learned in project 24, here‚Äôs a `UIImage` extension that creates a new, failable, convenience initializer called `UIImage(uncached:)`. It works like `UIImage(named:)` in that you don‚Äôt need to provide the full bundle path, but it _doesn‚Äôt_ have the downside of caching images you don‚Äôt intend to use more than once.

Here‚Äôs the code:

```swift
extension UIImage {
    convenience init?(uncached name: String) {
        if let path = Bundle.main.path(forResource: name, ofType: nil) {
            self.init(contentsOfFile: path)
        } else {
            return nil
        }
    }
}
```

Note the `init?` syntax that marks this as an initializer that returns an optional.

:::

### Challenge

::: details Challenge

```component VPCard
{
  "title": "100 Days of Swift - Day 99 - Challenge",
  "desc": "Challenge",
  "link": "https://hackingwithswift.com/guide/11/3/challenge",
  "logo": "https://www.hackingwithswift.com/favicon-96x96.png",
  "background": "rgb(213,52,58,0.2)"
}
```

Your challenge is to create a memory pairs game that has players find pairs of cards ‚Äì it‚Äôs sometimes called Concentration, Pelmanism, or Pairs. At the very least you should:

Come up with a list of pairs. Traditionally this is two pictures, but you could also use capital cities (e.g. one card says France and its match says Paris), languages (e.g one card says ‚Äúhello‚Äù and the other says ‚Äúbonjour‚Äù), and so on.
Show a grid of face-down cards. How many is down to you, but if you‚Äôre targeting iPad I would have thought 4x4 or more.
Let the player select any two cards, and show them face up as they are tapped.
If they match remove them; if they don‚Äôt match, wait a second then turn them face down again.
Show a You Win message once all are matched.
You can use either SpriteKit or UIKit depending on which skill you want to practice the most, but I think you‚Äôll find UIKit much easier.

Don‚Äôt under-estimate this challenge! To make it work you‚Äôre going to need to draw on a wide variety of skills, and it _will_ push you. That‚Äôs the point, though, so take your time and give yourself space to think.

If you‚Äôre looking for a more advanced challenge, go for a variant of the game that uses word pairs and add a parental option that lets them create new cards. This would mean:

- Authenticating users using Touch ID or Face ID.
- Showing a new view controller that lists all existing cards and lets them enter a new card.
- You can use a `UIAlertController` with one or two text fields for your card entry, depending on what kind of game you‚Äôve made.

Please go ahead and try to solve the challenge now. My hints are below, but please try to avoid reading them unless you‚Äôre really struggling.

- Start small. Seriously! Find something really simple that works, and only try something bigger or better once your simplest possible solution actually works.
- If you‚Äôre using UIKit, you could try to solve this using a `UICollectionView`. This gives you a natural grid, as well as touch handling for selecting cells, but make sure you think carefully about cells being re-used ‚Äì this might prove more difficult than you thought.
- An easier approach is to lay out your cards much like we did with the word letters in project 8, 7 Swifty Words. You could show your card backs as a button image, then when the button is tapped show the other side of the card ‚Äì which might be as simple as changing the picture and making the button‚Äôs text label have a non-clear color, or perhaps using Core Graphics to render the text directly onto the card front image.
- If you made the buttons work and want to try something fancier, you can actually create a flip animation to toggle between views ‚Äì see my article [How to flip a UIView with a 3D effect: `transition(with:)`](https://www.hackingwithswift.com/example-code/uikit/how-to-flip-a-uiview-with-a-3d-effect-transitionwith) for more information.
- In terms of tracking the game state it really only has three states: player has chosen zero cards, player has chosen one card (flip it over), and player has chosen two cards (flip the second one over). When they‚Äôve chosen two cards you need to decide whether you have a match, then either remove the cards or flip them back down and go back to the first state.
- For the content to show, you can just type in a list of words/images into your code if you want, but you‚Äôre welcome to use `Codable` if you want to push yourself.

Again, this is _not_ an easy challenge so please take your time and don‚Äôt feel bad when you find yourself having to look back at previous projects.

:::

::: tip Note

Don‚Äôt worry if you don‚Äôt complete challenges in the day they were assigned. Today‚Äôs challenge is particularly tough, so it will probably be something you solve over a few days. Take your time, look back on previous projects to see how you can re-use ideas, don‚Äôt be afraid to experiment, and remember to ask for help if you need it.

:::

---

<TagLinks />