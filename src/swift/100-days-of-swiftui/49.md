---
lang: ko-KR
title: Day 49
description: üïäÔ∏è100 Days of SwiftUI > Day 49
tags: ["crashcourse", "swift", "swiftui", "paul-hudson" , "xcode", "appstore"]
meta:
  - name: 100 Days of SwiftUI > Day 49
    content: Day 49
  - property: og:title
    content: Day 49
  - property: og:description
    content: 100 Days of SwiftUI > Day 49
  - property: og:url
    content: https://chanhi2000.github.io/crashcourse/swift/100-days-of-swiftui/49.html
---

# {{ $frontmatter.title }} Í¥ÄÎ†®

> {{ $frontmatter.description }}

[[toc]]

---

## Project 10, part 1

You‚Äôve had a couple of days away from following projects, and I hope you used them to review what you‚Äôve learned, write your own code for a while, and reflect on what was said in yesterday‚Äôs videos.

As the late, great Zig Ziglar said, ‚Äúthere are two sure ways to fail: think and never do, or do and never think.‚Äù Well, today is very much back to being a ‚Äúdo‚Äù day: we have a new project to build, which in turns means some new techniques to learn.

In particular, we‚Äôre going to go even deeper into `Codable` so you can get a feel for what‚Äôs happening behind the scenes when Swift can synthesize functionality for us. This is another step towards demystifying Swift and SwiftUI ‚Äì it‚Äôs great to be able to rely on our tools to do work for us, but it‚Äôs also important to understand _what_ they are doing.

__Today you have five topics to work through, in which you‚Äôll learn about custom `Codable` implementations, `URLSession`, the `disabled()` modifier, and more.__

### Cupcake Corner: Introduction

::: details Cupcake Corner: Introduction

[üìélink](https://hackingwithswift.com/books/ios-swiftui/cupcake-corner-introduction)

In this project we‚Äôre going to build a multi-screen app for ordering cupcakes. This will use a couple of forms, which are old news for you, but you‚Äôre also going to learn how to make classes conform to `Codable` when they have `@Published` properties, how to send and receive the order data from the internet, how to validate forms, and more.

As we continue to dig deeper and deeper into `Codable`, I hope you‚Äôll continue to be impressed by how flexible and safe it is. In particular, I‚Äôd like you to keep in mind how very different it is from the much older `UserDefaults` API ‚Äì it‚Äôs so nice not having to worry about typing strings exactly correctly!

Anyway, we have lots to get through so let‚Äôs get started: create a new iOS app using the App template, and name it CupcakeCorner. If you haven‚Äôt already downloaded the project files for this book, please fetch them now: [<FontIcon icon="iconfont icon-gitub"/>twostraws/HackingWithSwift](https://github.com/twostraws/HackingWithSwift)

As always we‚Äôre going to start with the new techniques you‚Äôll need for the project‚Ä¶

:::

### Adding `Codable` conformance for `@Published` properties

::: details Adding Codable conformance for @Published properties

[üìélink](https://hackingwithswift.com/books/ios-swiftui/adding-codable-conformance-for-published-properties)

<YouTube id="GqQdUzrJIkI" />

If all the properties of a type already conform to `Codable`, then the type itself can conform to `Codable` with no extra work ‚Äì Swift will synthesize the code required to archive and unarchive your type as needed. However, this _doesn‚Äôt_ work when we use property wrappers such as `@Published`, which means conforming to `Codable` requires some extra work on our behalf.

To fix this, we need to implement `Codable` conformance ourself. This will fix the `@Published` encoding problem, but is also a valuable skill to have elsewhere too because it lets us control exactly what data is saved and how it happens.

First let‚Äôs create a simple type that recreates the problem. Add this class to <FontIcon icon="fas fa-dove"/>`ContentView.swift`:

```swift
class User: ObservableObject, Codable {
    var name = "Paul Hudson"
}
```

That will compile just fine, because `String` conforms to `Codable` out of the box. However, if we make it `@Published` then the code no longer compiles:

```swift
class User: ObservableObject, Codable {
    @Published var name = "Paul Hudson"
}
```

The `@Published` property wrapper isn‚Äôt magic ‚Äì the name _property wrapper_ comes from the fact that our `name` property is automatically wrapped inside another type that adds some additional functionality. In the case of `@Published` that‚Äôs a struct called `Published` that can store any kind of value.

Previously we looked at how we can write generic methods that work with any kind of value, and the `Published` struct takes that a step further: the whole type itself is generic, meaning that you can‚Äôt make an instance of `Published` all by itself, but instead make an instance of `Published<String>` ‚Äì a publishable object that contains a string.

If that sounds confusing, back up: it‚Äôs actually a fairly fundamental principle of Swift, and one you‚Äôve been working with for some time. Think about it ‚Äì we can‚Äôt say `var names: Set`, can we? Swift doesn‚Äôt allow it; Swift wants to know what‚Äôs _in_ the set. This is because `Set` is also a generic type: you must make an instance of `Set<String>`. The same is also true of arrays and dictionaries: we always make them have something specific inside.

Swift already has rules in place that say if an array contains `Codable` types then the whole array is `Codable`, and the same for dictionaries and sets. However, SwiftUI _doesn‚Äôt_ provide the same functionality for its `Published` struct ‚Äì it has no rule saying ‚Äúif the published object is `Codable`, then the published struct itself is also `Codable`.‚Äù

As a result, we need to make the type conform ourselves: we need to tell Swift which properties should be loaded and saved, and how to do both of those actions.

None of those steps are terribly hard, so let‚Äôs just dive in with the first one: telling Swift which properties should be loaded and saved. This is done using an enum that conforms to a special protocol called `CodingKey`, which means that every case in our enum is the name of a property we want to load and save. This enum is conventionally called `CodingKeys`, with an S on the end, but you can call it something else if you want.

So, our first step is to create a `CodingKeys` enum that conforms to `CodingKey`, listing all the properties we want to archive and unarchive. Add this inside the `User` class now:

```swift
enum CodingKeys: CodingKey {
    case name
}
```

The next task is to create a custom initializer that will be given some sort of container, and use that to read values for all our properties. This will involve learning a few new things, but let‚Äôs look at the code first ‚Äì add this initializer to `User` now:

```swift
required init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    name = try container.decode(String.self, forKey: .name)
}
```

Even though that isn‚Äôt much code, there are at least four new things in there.

First, this initializer is handed an instance of a new type called `Decoder`. This contains all our data, but it‚Äôs down to us to figure out how to read it.

Second, anyone who subclasses our `User` class must override this initializer with a custom implementation to make sure they add their own values. We mark this using the `required` keyword: `required init`. An alternative is to mark this class as final so that subclassing isn‚Äôt allowed, in which case we‚Äôd write final class `User` and drop the `required` keyword entirely.

Third, inside the method we ask our `Decoder` instance for a container matching all the coding keys we already set in our `CodingKey` struct by writing `decoder.container(keyedBy: CodingKeys.self)`. This means ‚Äúthis data should have a container where the keys match whatever cases we have in our `CodingKeys` enum. This is a throwing call, because it‚Äôs possible those keys don‚Äôt exist.

Finally, we can read values directly from that container by referencing cases in our enum ‚Äì `container.decode(String.self, forKey: .name)`. This provides really strong safety in two ways: we‚Äôre making it clear we expect to read a string, so if `name` gets changed to an integer the code will stop compiling; and we‚Äôre also using a case in our `CodingKeys` enum rather than a string, so there‚Äôs no chance of typos.

There‚Äôs one more task we need to complete before the `User` class conforms to `Codable`: we‚Äôve made an initializer so that Swift can _decode_ data into this type, but now we need to tell Swift how to _encode_ this type ‚Äì how to archive it ready to write to JSON.

This step is pretty much the reverse of the initializer we just wrote: we get handed an `Encoder` instance to write to, ask it to make a container using our `CodingKeys` enum for keys, then write our values attached to each key.

Add this method to the `User` class now:

```swift
func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(name, forKey: .name)
}
```

And now our code compiles: Swift knows what data we want to write, knows how to convert some encoded data into our object‚Äôs properties, and knows how to convert our object‚Äôs properties into some encoded data.

I hope you‚Äôre able to see some real advantages here compared to the stringly typed API of `UserDefaults` ‚Äì it‚Äôs much harder to make a mistake with `Codable` because we don‚Äôt use strings, and it automatically checks our data types are correct.

:::

### Sending and receiving `Codable` data with `URLSession` and SwiftUI

::: details Sending and receiving Codable data with URLSession and SwiftUI

[üìélink](https://hackingwithswift.com/books/ios-swiftui/sending-and-receiving-codable-data-with-urlsession-and-swiftui)

<YouTube id="MBCX1atOvdA" />

iOS gives us built-in tools for sending and receiving data from the internet, and if we combine it with `Codable` support then it‚Äôs possible to convert Swift objects to JSON for sending, then receive back JSON to be converted back to Swift objects. Even better, when the request completes we can immediately assign its data to properties in SwiftUI views, causing our user interface to update.

To demonstrate this we can load some example music JSON data from Apple‚Äôs iTunes API, and show it all in a SwiftUI `List`. Apple‚Äôs data includes lots of information, but we‚Äôre going to whittle it down to just two types: a `Result` will store a track ID, its name, and the album it belongs to, and a `Response` will store an array of results.

So, start with this code:

```swift
struct Response: Codable {
    var results: [Result]
}

struct Result: Codable {
    var trackId: Int
    var trackName: String
    var collectionName: String
}
```

We can now write a simple `ContentView` that shows an array of results:

```swift
struct ContentView: View {
    @State private var results = [Result]()

    var body: some View {
        List(results, id: \.trackId) { item in
            VStack(alignment: .leading) {
                Text(item.trackName)
                    .font(.headline)
                Text(item.collectionName)
            }
        }
    }
}
```

That won‚Äôt show anything at first, because the `results` array is empty. This is where our networking call comes in: we‚Äôre going to ask the iTunes API to send us a list of all the songs by Taylor Swift, then use `JSONDecoder` to convert those results into an array of `Result` instances.

However, doing this means you need to meet two important Swift keywords: `async` and `await`. You see, any iPhone capable of running SwiftUI can perform billions of operations every second ‚Äì it‚Äôs so fast that it completes most work before we even realized it started it. On the flip side, networking ‚Äì downloading data from the internet ‚Äì might take several hundreds milliseconds or more to come, which is extremely slow for a computer that‚Äôs used to doing literally a billion other things in that time.

Rather than forcing our entire progress to stop while the networking happens, Swift gives us the ability to say ‚Äúthis work will take some time, so please wait for it to complete while the rest of the app carries on running as usual.‚Äù

This functionality ‚Äì this ability to leave some code running while our main app code carries on working ‚Äì is called an _asynchronous_ function. A synchronous function is one that runs fully before returning a value as needed, but an asynchronous function is one that is able to go to sleep for a while, so that it can wait for some other work to complete before continuing. In our case, that means going to sleep while our networking code happens, so that the rest of our app doesn‚Äôt freeze up for several seconds.

To make this easier to understand, let‚Äôs write it in a few stages. First, here‚Äôs the basic method stub ‚Äì please add this to the `ContentView` struct:

```swift
func loadData() async {

}
```

Notice the new `async` keyword in there ‚Äì we‚Äôre telling Swift this function might want to go to sleep in order to complete its work.

We want that to be run as soon as our `List` is shown, but we can‚Äôt just use `onAppear()` here because that doesn‚Äôt know how to handle sleeping functions ‚Äì it expects its function to be synchronous.

SwiftUI provides a different modifier for these kinds of tasks, giving it a particularly easy to remember name: `task()`. This _can_ call functions that might go to sleep for a while; all Swift asks us to do is mark those functions with a second keyword, `await`, so we‚Äôre explicitly acknowledging that a sleep might happen.

Add this modifier to the `List` now:

```swift
.task {
    await loadData()
}
```

Tip: Think of `await` as being like `try` ‚Äì we‚Äôre saying we understand a sleep might happen, in the same way `try` says we acknowledge an error might be thrown.

_Inside_ `loadData()` we have three steps we need to complete:

1. Creating the URL we want to read.
2. Fetching the data for that URL.
3. Decoding the result of that data into a `Response` struct.

We‚Äôll add those step by step, starting with the URL. This needs to have a precise format: ‚Äúitunes.apple.com‚Äù followed by a series of parameters ‚Äì you can find the full set of parameters if you do a web search for ‚ÄúiTunes Search API‚Äù. In our case we‚Äôll be using the search term ‚ÄúTaylor Swift‚Äù and the entity ‚Äúsong‚Äù, so add this to `loadData()` now:

```swift
guard let url = URL(string: "https://itunes.apple.com/search?term=taylor+swift&entity=song") else {
    print("Invalid URL")
    return
}
```

Step 2 is to fetch the data from that URL, which is where our sleep is likely to happen. I say ‚Äúlikely‚Äù because it might not ‚Äì iOS will do a little caching of data, so if the URL is fetched twice back to back then the data will get sent back immediately rather than triggering a sleep.

Regardless, a sleep _is_ possible here, and every time a sleep is possible we need to use the `await` keyword with the code we want to run. Just as importantly, an error might also be thrown here ‚Äì maybe the user isn‚Äôt currently connected to the internet, for example.

So, we need to use both `try` _and_ `await` at the same time. Please add this code directly after the previous code:

```swift
do {
    let (data, _) = try await URLSession.shared.data(from: url)

    // more code to come
} catch {
    print("Invalid data")
}
```

That introduced three important things, so let‚Äôs break it down:

1. Our work is being done by the `data(from:)` method, which takes a URL and returns the `Data` object at that URL. This method belongs to the `URLSession` class, which you can create and configure by hand if you want, but you can also use a shared instance that comes with sensible defaults.
2. The return value from `data(from:)` is a tuple containing the data at the URL and some metadata describing how the request went. We don‚Äôt use the metadata, but we _do_ want the URL‚Äôs data, hence the underscore ‚Äì we create a new local constant for the data, and toss the metadata away.
3. When using both `try` and `await` at the same time, we must write `try await` ‚Äì using `await try` is not allowed. There‚Äôs no special reason for this, but they had to pick one so they went with the one that reads more naturally.

So, if our download succeeds our `data` constant will be set to whatever data was sent back from the URL, but if it fails for any reason our code prints ‚ÄúInvalid data‚Äù and does nothing else.

The last part of this method is to convert the `Data` object into a `Response` object using `JSONDecoder`, then assign the array inside to our `results` property. This is exactly what we‚Äôve used before, so this shouldn‚Äôt be a surprise ‚Äì add this last code in place of the `// more code to come` comment now:

```swift
if let decodedResponse = try? JSONDecoder().decode(Response.self, from: data) {
    results = decodedResponse.results
}
```

If you run the code now you should see a list of Taylor Swift songs appear after a short pause ‚Äì it really isn‚Äôt a lot of code given how well the end result works.

All this only handles _downloading_ data. Later on in this project we‚Äôre going to look at how to adopt a slightly different approach so you can _send_ `Codable` data, but that‚Äôs enough for now.

:::

### Loading an image from a remote server

::: details Loading an image from a remote server

[üìélink](https://hackingwithswift.com/books/ios-swiftui/loading-an-image-from-a-remote-server)

<YouTube id="O4xkQK6sHVU" />

SwiftUI‚Äôs `Image` view works great with images in your app bundle, but if you want to load a _remote_ image from the internet you need to use AsyncI`mage instead. These are created using an image URL rather than a simple asset name, but SwiftUI takes care of all the rest for us ‚Äì it downloads the image, caches the download, and displays it automatically.

So, the simplest image we can create looks like this:

```swift
AsyncImage(url: URL(string: "https://hws.dev/img/logo.png"))
```

I created that picture to be 1200 pixels high, but when it displays you‚Äôll see it‚Äôs much bigger. This gets straight to one of the fundamental complexities of using `AsyncImage`: SwiftUI knows nothing about the image until our code is run and the image is downloaded, and so it isn‚Äôt able to size it appropriately ahead of time.

If I were to include that 1200px image in my project, I‚Äôd actually name it logo@3x.png, then also add an 800px image that was logo@2x.png. SwiftUI would then take care of loading the correct image for us, and making sure it appeared nice and sharp, and at the correct size too. As it is, SwiftUI loads that image as if it were designed to be shown at 1200 pixels high ‚Äì it will be much bigger than our screen, and will look a bit blurry too.

To fix this, we can tell SwiftUI ahead of time that we‚Äôre trying to load a 3x scale image, like this:

```swift
AsyncImage(url: URL(string: "https://hws.dev/img/logo.png"), scale: 3)
```

When you run the code now you‚Äôll see the resulting image is a much more reasonable size.

And if you wanted to give it a _precise_ size? Well, then you might start by trying this:

```swift
AsyncImage(url: URL(string: "https://hws.dev/img/logo.png"))
    .frame(width: 200, height: 200)
```

That won‚Äôt work, but perhaps that won‚Äôt even surprise you because it wouldn‚Äôt work with a regular `Image` either. So you might try to make it resizable, like this:

```swift
AsyncImage(url: URL(string: "https://hws.dev/img/logo.png"))
    .resizable()
    .frame(width: 200, height: 200)
```

‚Ä¶except that won‚Äôt work either, and in fact it‚Äôs worse because now our code won‚Äôt even compile. You see, the modifiers we‚Äôre applying here don‚Äôt apply directly to the image that SwiftUI downloads ‚Äì they can‚Äôt, because SwiftUI can‚Äôt know how to apply them until it has actually fetched the image data.

Instead, we‚Äôre applying modifiers to a wrapper _around_ the image, which is the `AsyncImage` view. That will ultimately contain our finished image, but it will also contain a _placeholder_ that gets used while the image is loading. You can actually see the placeholder just briefly when your app runs ‚Äì that 200x200 gray square is it, and it will automatically go away once loading finishes.

To adjust our image, you need to use a more advanced form of `AsyncImage` that passes us the final image view once it‚Äôs ready, which we can then customize as needed. As a bonus, this also gives us a second closure to customize the placeholder as needed.

For example, we could make the finished image view be both resizable and scaled to fit, and use `Color.red` as the placeholder so it‚Äôs more obvious while you‚Äôre learning.

```swift
AsyncImage(url: URL(string: "https://hws.dev/img/logo.png")) { image in
    image
        .resizable()
        .scaledToFit()
} placeholder: {
    Color.red
}
.frame(width: 200, height: 200)
```

A resizable image and `Color.red` both automatically take up all available space, which means the `frame()` modifier actually works now.

The placeholder view can be whatever you want. For example, if you replace `Color.red` with `ProgressView()` ‚Äì just that ‚Äì then you‚Äôll get a little spinner activity indicator instead of a solid color.

If you want _complete_ control over your remote image, there‚Äôs a third way of creating `AsyncImage` that tells us whether the image was loaded, hit an error, or hasn‚Äôt finished yet. This is particularly useful for times when you want to show a dedicated view when the download fails ‚Äì if the URL doesn‚Äôt exist, or the user was offline, etc.

Here‚Äôs how that looks:

```swift
AsyncImage(url: URL(string: "https://hws.dev/img/bad.png")) { phase in
    if let image = phase.image {
        image
            .resizable()
            .scaledToFit()
    } else if phase.error != nil {
        Text("There was an error loading the image.")
    } else {
        ProgressView()
    }
}
.frame(width: 200, height: 200)
```

So, that will show our image if it can, an error message if the download failed for any reason, or a spinning activity indicator while the download is still in progress.

:::

### Validating and disabling forms

::: details Validating and disabling forms

[üìélink](https://hackingwithswift.com/books/ios-swiftui/validating-and-disabling-forms)

<YouTube id="LZr7JRZwt68" />

SwiftUI‚Äôs `Form` view lets us store user input in a really fast and convenient way, but sometimes it‚Äôs important to go a step further ‚Äì to _check_ that input to make sure it‚Äôs valid before we proceed.

Well, we have a modifier just for that purpose: `disabled()`. This takes a condition to check, and if the condition is true then whatever it‚Äôs attached to won‚Äôt respond to user input ‚Äì buttons can‚Äôt be tapped, sliders can‚Äôt be dragged, and so on. You can use simple properties here, but any condition will do: reading a computed property, calling a method, and so on,

To demonstrate this, here‚Äôs a form that accepts a username and email address:

```swift
struct ContentView: View {
    @State private var username = ""
    @State private var email = ""

    var body: some View {
        Form {
            Section {
                TextField("Username", text: $username)
                TextField("Email", text: $email)
            }

            Section {
                Button("Create account") {
                    print("Creating account‚Ä¶")
                }
            }

        }
    }
}
```

In this example, we don‚Äôt want users to create an account unless both fields have been filled in, so we can disable the form section containing the Create Account button by adding the `disabled()` modifier like this:

```swift
Section {
    Button("Create account") {
        print("Creating account‚Ä¶")
    }
}
.disabled(username.isEmpty || email.isEmpty)
```

That means ‚Äúthis section is disabled if username is empty or email is empty,‚Äù which is exactly what we want.

You might find that it‚Äôs worth spinning out your conditions into a separate computed property, such as this:

```swift
var disableForm: Bool {
    username.count < 5 || email.count < 5
}
```

Now you can just reference that in your modifier:

```swift
.disabled(disableForm)
```

Regardless of how you do it, I hope you try running the app and seeing how SwiftUI handles a disabled button ‚Äì when our test fails the button‚Äôs text goes gray, but as soon as the test passes the button lights up blue.

That brings us to the end of the overview for this project, so please put <FontIcon icon="fas fa-dove"/>`ContentView.swift` back to its original state so we can begin building the main project.

:::

---

<TagLinks />
