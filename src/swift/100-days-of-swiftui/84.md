---
lang: ko-KR
title: Day 84
description: üïäÔ∏è100 Days of SwiftUI > Day 84
category:
  - üïäÔ∏èSwift
tag: 
  - crashcourse
  - paul-hudson
  - swift
  - swiftui
  - hacking-with-swift
  - xcode
  - appstore
head:
  - - meta:
    - property: og:title
      content: üïäÔ∏è100 Days of SwiftUI > Day 84
    - property: og:description
      content: Day 84
    - property: og:url
      content: https://chanhi2000.github.io/crashcourse/swift/100-days-of-swiftui/84.html
---

# {{ $frontmatter.title }} Í¥ÄÎ†®

> {{ $frontmatter.description }}

[[toc]]

---

```component VPCard
{
  "title": "100 Days of SwiftUI - Day 84",
  "desc": "Project 16, part 6",
  "link": "https://www.hackingwithswift.com/100/swiftui/84",
  "logo": "https://www.hackingwithswift.com/favicon-96x96.png",
  "background": "rgba(54,94,226,0.2)"
}
```

## Project 16, part 6

This has been a long project with lots to learn, but today marks the last of the code. As the American professor Angela Duckworth said, ‚Äúenthusiasm is common; endurance is rare‚Äù ‚Äì it took enthusiasm to start day 1 of this series, but here you are on day 84 just finishing a huge project, so it‚Äôs clear you‚Äôve got great endurance as well.

This project has already drawn upon some important SwiftUI features such as tab bars, swipe actions, and the environment; some important Swift features such as importing external packages and `Result`; and even some important iOS features such as Core Image and scanning codes with the camera. Today we‚Äôre going to add the icing on the cake, which is adding a context menu, and showing alerts using the UserNotification framework.

This is what great apps look like: they lean on a variety of language and system features to build great user experiences that go beyond what SwiftUI can do by itself. Yes, SwiftUI is an awesome way to build apps, but it‚Äôs only the beginning ‚Äì iOS is capable of so much more, and as much as it sounds like a cliche the only limit to what you can make is your imagination.

__Today you have two topics to work through, in which you‚Äôll add a context menu to save our QR code, then show local notifications using the UserNotifications framework.__

### Adding a context menu to an image

::: details Adding a context menu to an image

```component VPCard
{
  "title": "100 Days of SwiftUI - Day 84 - Adding a context menu to an image",
  "desc": "Adding a context menu to an image",
  "link": "https://hackingwithswift.com/books/ios-swiftui/adding-a-context-menu-to-an-image",
  "logo": "https://www.hackingwithswift.com/favicon-96x96.png",
  "background": "rgba(54,94,226,0.2)"
}
```

<VidStack src="youtube/kSt3jCwpLmo" />

We‚Äôve already written code that dynamically generates a QR code based on the user‚Äôs name and email address, but with a little extra code we can also let the user _share_ that QR code outside the app. This is another example of where `ShareLink` comes in handy, although this time we'll place it inside a context menu.

Start by opening <FontIcon icon="fas fa-dove"/>`MeView.swift`, and adding the `contextMenu()` modifier to the QR code image, like this:

```swift
Image(uiImage: generateQRCode(from: "\(name)\n\(emailAddress)"))
    .interpolation(.none)
    .resizable()
    .scaledToFit()
    .frame(width: 200, height: 200)
    .contextMenu {
        let image = generateQRCode(from: "\(name)\n\(emailAddress)")

        ShareLink(item: Image(uiImage: image), preview: SharePreview("My QR Code", image: Image(uiImage: image)))
    }
```

As you can see, we need to convert the `UIImage` of our QR code to a SwiftUI `Image` view, which can then be handed to the system's share sheet.

We _could_ save a little work by caching the generated QR code, however a more important side effect of that is that we wouldn‚Äôt have to pass in the name and email address each time ‚Äì duplicating that data means if we change one copy in the future we need to change the other too.

To add this change, first add a new `@State` property that will store the code we generate:

```swift
@State private var qrCode = UIImage()
```

Now modify `generateQRCode()` so that it quietly stores the new code in our cache before sending it back:

```swift
if let cgimg = context.createCGImage(outputImage, from: outputImage.extent) {
    qrCode = UIImage(cgImage: cgimg)
    return qrCode
}
```

And now our context menu button can use the cached code:

```swift
.contextMenu {
    `ShareLink`(item: Image(uiImage: qrCode), preview: SharePreview("My QR Code", image: Image(uiImage: qrCode)))
}
```

Before you try the context menu yourself, make sure you add the same project option we had for the Instafilter project ‚Äì you need to add a permission request string to your project‚Äôs configuration options.

In case you‚Äôve forgotten how to do that, here are the steps you need:

- Open your target settings
- Select the Info tab
- Right-click on an existing option
- Choose Add Row
- Select `[‚ÄúPrivacy - Photo Library Additions Usage Description‚Äù]` for the key name.
- Enter ‚ÄúWe want to save your QR code.‚Äù as the value.

And now go ahead and run the app ‚Äì you're likely to find things don't work quite as planned. In fact, back in Xcode you might see a purple warning line in the `generateQRCode()` method: "Modifying state during view update, this will cause undefined behavior."

What this means is that our current view body calls `generateQRCode()` to create the shareable image that we're attaching our context menu to, but calling that method now saves a value in the `qrCode` property we marked with `@State`, which in _turn_ causes the view body to be reinvoked ‚Äì it creates a loop, so SwiftUI bails out and flags a big warning for us.

To fix this we need to make the `Image` view use our cached QR code, like this:

```swift
Image(uiImage: qrCode)
```

And _then_ use a combination of `onAppear()` and `onChange()` to make sure the code is updated when the view is first shown, and also when either the name or email address changes.

This means creating a new method that updates our code in one place:

```swift
func updateCode() {
    qrCode = generateQRCode(from: "\(name)\n\(emailAddress)")
}
```

Then attaching some extra modifiers below `navigationTitle()`:

```swift
.onAppear(perform: updateCode)
.onChange(of: name, updateCode)
.onChange(of: emailAddress, updateCode)
```

Tip: Now that `updateCode()` updates the value of `qrCode` directly, we can go back to the earlier version of `generateQRCode()`, which simply returns the new value:

```swift
if let cgimg = context.createCGImage(outputImage, from: outputImage.extent) {
    return UIImage(cgImage: cgimg)
}
```

Now this step is done, and done properly ‚Äì you should be able to run the app, switch to the Me tab, then long press the QR code to bring up your new context menu.

:::

### Posting notifications to the lock screen

::: details Posting notifications to the lock screen

```component VPCard
{
  "title": "100 Days of SwiftUI - Day 84 - Posting notifications to the lock screen",
  "desc": "Posting notifications to the lock screen",
  "link": "https://hackingwithswift.com/books/ios-swiftui/posting-notifications-to-the-lock-screen",
  "logo": "https://www.hackingwithswift.com/favicon-96x96.png",
  "background": "rgba(54,94,226,0.2)"
}
```

<VidStack src="youtube/31sTDonbI5k" />

For the final part of our app, we‚Äôre going to add another button to our list swipe actions, letting users opt to be reminded to contact a particular person. This will use iOS‚Äôs UserNotifications framework to create a local notification, and we‚Äôll conditionally include it in the swipe actions as part of our existing `if` check ‚Äì the button will only be shown if the user hasn‚Äôt been contacted already.

Much more interesting is how we schedule the local notifications. Remember, the first time we try this we need to use `requestAuthorization()` to explicitly ask for permission to show a notification on the lock screen, but we also need to be careful subsequent times because the user can retroactively change their mind and disable notifications.

One option is to call `requestAuthorization()` _every time we want to post a notification_, and honestly that works great: the first time it will show an alert, and all other times it will immediately return success or failure based on the previous response.

However, in the interests of completion I want to show you a more powerful alternative: we can request the current authorization settings, and use that to determine whether we should schedule a notification or request permission. The reason it‚Äôs helpful to use _this_ approach rather than just requesting permission repeatedly, is that the settings object handed back to us includes properties such as `alertSetting` to check whether we can show an alert or not ‚Äì the user might have restricted this so all we can do is display a numbered badge on our icon.

So, we‚Äôre going to call `getNotificationSettings()` to read whether notifications are currently allowed. If they are, we‚Äôll show a notification. If they _aren‚Äôt_, we‚Äôll request permissions, and if _that_ comes back successfully then we‚Äôll also show a notification. Rather than repeat the code to schedule a notification, we‚Äôll put it inside a closure that can be called in either scenario.

Start by adding this import near the top of <FontIcon icon="fas fa-dove"/>`ProspectsView.swift`:

```swift
import UserNotifications
```

Now add this method to the ProspectsView struct:

```swift
func addNotification(for prospect: Prospect) {
    let center = UNUserNotificationCenter.current()

    let addRequest = {
        let content = UNMutableNotificationContent()
        content.title = "Contact \(prospect.name)"
        content.subtitle = prospect.emailAddress
        content.sound = UNNotificationSound.default

        var dateComponents = DateComponents()
        dateComponents.hour = 9
        let trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: false)

        let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
        center.add(request)
    }

    // more code to come
}
```

That puts all the code to create a notification for the current prospect into a closure, which we can call whenever we need. Notice that I‚Äôve used `UNCalendarNotificationTrigger` for the trigger, which lets us specify a custom `DateComponents` instance. I set it to have an hour component of 9, which means it will trigger the next time 9am comes about.

Tip: For testing purposes, I recommend you comment out that trigger code and replace it with the following, which shows the alert five seconds from now:

```swift
let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)
```

For the second part of that method we‚Äôre going to use both `getNotificationSettings()` and `requestAuthorization()` together, to make sure we only schedule notifications when allowed. This will use the `addRequest` closure we defined above, because the same code can be used if we have permission already or if we ask and have been granted permission.

Replace the `// more code to come` comment with this:

```swift
center.getNotificationSettings { settings in
    if settings.authorizationStatus == .authorized {
        addRequest()
    } else {
        center.requestAuthorization(options: [.alert, .badge, .sound]) { success, error in
            if success {
                addRequest()
            } else if let error {
                print(error.localizedDescription)
            }
        }
    }
}
```

That‚Äôs all the code we need to schedule a notification for a particular prospect, so all that remains is to add an extra button to our swipe actions ‚Äì add this below the ‚ÄúMark Contacted‚Äù button:

```swift
Button("Remind Me", systemImage: "bell") {
    addNotification(for: prospect)
}
.tint(.orange)
```

That completes the current step, and completes our project too ‚Äì try running it now and you should find that you can add new prospects, then press and hold to either mark them as contacted, or to schedule a contact reminder.

Good job!

:::

That‚Äôs another app complete ‚Äì don‚Äôt forget to share your progress with others!

---

<TagLinks />