---
lang: ko-KR
title: 03. 파이썬을 이용한 날짜와 시간 다루기 
description: 🐍Finance with Python > 03. 파이썬을 이용한 날짜와 시간 다루기 
tags: ["crashcourse", "python", "py", "google" , "google-colab", "jupyter-notebook", "numpy", "pandas", "ipython"]
meta:
  - name: 🐍Finance with Python > 03. 파이썬을 이용한 날짜와 시간 다루기 
    content: 03. 파이썬을 이용한 날짜와 시간 다루기 
  - property: og:title
    content: 03. 파이썬을 이용한 날짜와 시간 다루기 
  - property: og:description
    content: 🐍Finance with Python > 03. 파이썬을 이용한 날짜와 시간 다루기 
  - property: og:url
    content: https://chanhi2000.github.io/crashcourse/py-finance-w-python/03.html
---

# {{ $frontmatter.title }} 관련

> {{ $frontmatter.description }}

[[toc]]

---

```card
title: 03. 파이썬을 이용한 날짜와 시간 다루기
desc: 금융 데이터 분석을 위한 파이썬 - WikiDocs
link: https://wikidocs.net/172633
logo: https://wikidocs.net/static/img/favicon.ico
color: rgba(255, 255, 255, 0.2)
```

---

이번 챕터에서는 가장 중요한 시간(`time`) 데이터를 다루는 다양한 방법을 배울 것입니다. 시간 데이터를 때로는 시계열 데이터라고도 부릅니다. 시계열 데이터를 가장 자주 접하는 곳은 단연 금융권입니다.

따라서 시간 데이터를 능숙하게 다룰 수 있도록 파이썬 패키지인 데이트타임(`datetime`), 넘파이(`numpy`), 판다스(`pandas`)에서 시간을 어떻게 다루는지 살펴봅니다.

여기서 언급하고 있는 3개의 패키지는 데이터 분석에서 굉장히 중요한 패키지이기 때문에 여러분들이 패키지 이름, 패키지가 하는 역할에 대해서만큼은 꼭 암기를 해주시면 좋겠습니다.

패키지의 세부적인 기능은 잘 기억 안나도 괜찮아요.
필요할 때마다 찾아보면 되니까요. 그런데, 이런 기능을 수행하는 패키지가 무엇이었는지는 기억을 해야 다음에 찾아보기 때문에 패키지 이름을 암기하라는 것입니다.

---

## 01. `datetime`

날짜와 시간 관련 함수는 시계열 데이터를 다루는 다양한 상황에서 사용됩니다. 스트링(String) 타입의 문자를 날짜 형태 포맷(`format`)으로 바꾸거나 시간 단위 변경, 시각화 등에 응용할 수 있습니다. 파이썬 표준 패키지인 `datetime`에 대해서 알아봅시다.

`datetime`에는 `time`, `date`, `datetime`, `timedelta` 외에도 여러 기능이 있습니다.

::: details time

시간 기능만 제공합니다, 시, 분, 초, 마이크로초

```python
datetime.time(hour=4, minute=3, second=10, microsecond=1000)
```

:::

::: details date

날짜 기능만 제공합니다. 연, 월, 일

```python
datetime.date(year=2019, month=1, day=10)
```

:::

::: details datetime

날짜와 시간 기능을 제공합니다. - date + time

```python
datetime.datetime(year=2019, month=10, day=24, hour=4, minute=3, second=10, microsecond=1000)
```

:::

::: details timedelta

`datetime` 인스턴스 간의 차이를 구함

```python
datetime.datetime(year=2019, month=10, day=24, hour=4, minute=3, second=10, microsecond=1000)
```

:::

실제 분석에서 날짜와 시간은 문자열 타입으로 주어지는 경우가 많습니다. 따라서 자유롭게 데이터 타입을 변환하는 방법을 익혀야 합니다. 다음 설명을 보면서 날짜 변환(`conversion`)에 대해서 알아봅시다. 먼저 `str` 타입의 문자를 `datetime` 형식으로 바꾸는 방법을 살펴봅시다.

```python
import datetime
datetime_str = '2018-05-13 12:34:56'
```

`strptime()` 함수에 datetime_str 변수와 형식을 매개변수로 전달합니다. 우리가 입력한 `str` 타입의 날짜와 날짜를 표현하는 형식을 `strtime()` 함수에 전달한 것입니다. 함수의 결과를 보니, `str` 타입의 문자가 `datetime` 타입으로 변환한 것을 알 수 있습니다.

```python
format = '%Y-%m-%d %H:%M:%S' 
datetime_dt = datetime.datetime.strptime(datetime_str, format)
print(datetime_dt)

print(type(datetime_dt))
```

이번에는 반대로 `datetime`을 `str`타입의 문자로 변환할 수 있는지 확인해봅시다.
`datetime_dt`는 우리가 앞서 확인했듯이 현재 `datetime` 타입입니다.

```python
datetime_str = datetime_dt.strftime('%Y-%m-%d %H:%M:%S')

print(type(datetime_str)) # <class 'str'>
print(datetime_str)       # 2018-08-24 18:00:25
#
#
# <class 'str'>
# 2018-05-13 12:34:56
```

위에서 `strptime()` 함수를 호출할 때 변환된 `datetime_dt`에서 `strftime()` 함수를 호출한 것을 알 수 있습니다. 함수 매개변수에는 변환하려는 날짜, 시간 형식을 전달한다. 결과를 보니, `str` 타입으로 변환된 것과 우리가 전달한 형식에 맞게 값이 나온 것을 확인할 수 있습니다. 또 다른 형식으로 변경하려면 다음과 같이 수정해서 전달하면 됩니다. 이번에는 분, 초를 제외하고 시간까지만 출력을 해봅시다.

```python
datetime_str = datetime_dt.strftime('%Y-%m-%d %H')

print(type(datetime_str)) # <class 'str'>
print(datetime_str)       # 2018-08-24 18:00:25
#
#
# <class 'str'>
# 2018-05-13 12
```

시간까지만 출력이 된 것을 확인할 수 있습니다. 이번에는 년도와 달까지만 출력을 해보겠습니다.

```python
datetime_str = datetime_dt.strftime('%Y-%m')

print(type(datetime_str)) # <class 'str'>
print(datetime_str)       # 2018-08-24 18:00:25
#
#
# <class 'str'>
# 2018-05
```

정리하면 `'%Y-%m-%d %H'` 형식을 전달하면 연-월-일-시 형식으로 출력되고, `'%Y-%m'`을 전달하면 연-월만 출력됩니다.

`strptime()` 함수와 `strftime()` 함수는 서로 반대되는 기능을 가지고 있습니다. String을 `datetime`으로 변환할 때는 `strptime()` 함수를 사용하고, 그 반대의 경우에는 `strftime()` 함수를 사용합니다.

- `strptime()` : `str` 타입으로 된 날짜 데이터를 `datetime` 형태로 변환
- `strftime()` : `datetime` 형태의 데이터를 `str` 타입으로 변환 주의해야 할 점은 우리가 형식을 정의할 때 지정한 형식이 대소문자를 구분하므로 형식을 맞추거나 정확한 날짜를 표현해야 합니다.

아래 링크로 이동하신 다음에 아래 링크에서 제공되는 자료의 표 47-4를 참고하세요.
암기하실 필요는 없고 필요할 때 찾아보시면 됩니다.

> 📚참고자료: [https://dojang.io/mod/page/view.php?id=2463](https://dojang.io/mod/page/view.php?id=2463)

---

## 02. 날짜와 시간을 다루는 넘파이(`Numpy`)

객체라는 표현이 종종 나올 수 있습니다. 객체라는 표현에 익숙하지 않으시다면 아래 참고 자료를 참고하세요.

> 📚참고자료: [클래스와 객체](https://wikidocs.net/28)

넘파이에서는 날짜와 시간을 `datetime64` 객체로 표현합니다. 넘파이의 `datetime64`와 파이썬의 `datetime.datetime`과 차이점은 `datetime`에서는 시간을 마이크로초(10^-6) 단위까지 관리한다면, 넘파이의 `datetime64`는 아토초(10^-18) 단위까지 관리한다는 것입니다.

넘파이의 날짜와 시간을 이해해야 하는 가장 중용한 이유는 우리가 궁극적으로 사용할 판다스의 날짜와 시간 함수가 넘파이를 기반으로 만들어졌기 때문입니다. 그럼 넘파이의 날짜와 시간 사용 예제를 살펴봅시다.

### `datetime64`

Numpy 객체를 이용해 날짜를 생성하는 방식에는 두 가지 방식이 있습니다. 첫번째는 아래와 같이 문자열 형식으로 전달해서 생성하는 방법입니다.

```python
import numpy as np
np.datetime64('2019-01-01')
```

두번째는 아래와 같이 유닉스 시간을 이용한 방식입니다. 첫번째 입력 매개변수는 수치 데이터, 그리고 두번째 입력 매개변수는 단위를 의미합니다. 'ns'는 나노초 단위, 'D'는 일 단위, 's'는 초 단위를 의미합니다. 출력 결과는 단위에 따라서 각기 다른 종류의 날짜가 만들어집니다.

::: tabs 

@tab:active 나노초 단위 1

```python
import numpy as np

# 나노초 단위
np.datetime64(1000,'ns')
numpy.datetime64('1970-01-01T00:00:00.000001000')
```

@tab 나노초 단위 2

이번에는 동일하게 나노초 단위로 하되 수치를 바꿔보겠습니다.

```python
np.datetime64(10000000000,'ns')
numpy.datetime64('1970-01-01T00:00:10.000000000')
```

@tab 초 단위

초 단위로 출력해봅시다.

```python
np.datetime64(1000000000,'s')
numpy.datetime64('2001-09-09T01:46:40')
```

@tab 일 단위 

일 단위로 출력해봅시다.

```python
np.datetime64(10000,'D')
numpy.datetime64('1997-05-19')
```

:::

### `array()`

Numpy의 `array()` 함수를 사용해서도 날짜를 생성할 수 있습니다. `np.array()` 함수에 `str` 타입의 날짜 리스트를 전달하고, `dtype`(데이터 타입)을 '`datetime64`'로 설정했습니다.

```python
np.array(['2007-07-13', '2006-01-13', '2010-08-13'], dtype='datetime64')
array(['2007-07-13', '2006-01-13', '2010-08-13'], dtype='datetime64[D]')
```

이때 `dtype`에서 `datetime64`를 적어주실 때, `[ ]`안에 어떤 값을 넣느냐에 따라서 날짜 단위를 지정할 수도 있습니다.

```python
# 달단위
np.array(['2007-07-13', '2006-01-13', '2010-08-13'], dtype='datetime64[M]')
array(['2007-07', '2006-01', '2010-08'], dtype='datetime64[M]')
```

### `arange()`

`arange()` 함수를 사용해서 범위를 줄 수도 있습니다.

```python
# 달단위
np.arange('2005-02', '2006-03', dtype='datetime64[M]')
array(['2005-02', '2005-03', '2005-04', '2005-05', '2005-06', '2005-07',
       '2005-08', '2005-09', '2005-10', '2005-11', '2005-12', '2006-01',
       '2006-02'], dtype='datetime64[M]')
# 주단위
np.arange('2005-02', '2006-03', dtype='datetime64[W]')
array(['2005-01-27', '2005-02-03', '2005-02-10', '2005-02-17',
       '2005-02-24', '2005-03-03', '2005-03-10', '2005-03-17',
       '2005-03-24', '2005-03-31', '2005-04-07', '2005-04-14',
       '2005-04-21', '2005-04-28', '2005-05-05', '2005-05-12',
       '2005-05-19', '2005-05-26', '2005-06-02', '2005-06-09',
       '2005-06-16', '2005-06-23', '2005-06-30', '2005-07-07',
       '2005-07-14', '2005-07-21', '2005-07-28', '2005-08-04',
       '2005-08-11', '2005-08-18', '2005-08-25', '2005-09-01',
       '2005-09-08', '2005-09-15', '2005-09-22', '2005-09-29',
       '2005-10-06', '2005-10-13', '2005-10-20', '2005-10-27',
       '2005-11-03', '2005-11-10', '2005-11-17', '2005-11-24',
       '2005-12-01', '2005-12-08', '2005-12-15', '2005-12-22',
       '2005-12-29', '2006-01-05', '2006-01-12', '2006-01-19',
       '2006-01-26', '2006-02-02', '2006-02-09', '2006-02-16'],
      dtype='datetime64[W]')
# 일단위
np.arange('2005-02', '2005-03', dtype='datetime64[D]')
array(['2005-02-01', '2005-02-02', '2005-02-03', '2005-02-04',
       '2005-02-05', '2005-02-06', '2005-02-07', '2005-02-08',
       '2005-02-09', '2005-02-10', '2005-02-11', '2005-02-12',
       '2005-02-13', '2005-02-14', '2005-02-15', '2005-02-16',
       '2005-02-17', '2005-02-18', '2005-02-19', '2005-02-20',
       '2005-02-21', '2005-02-22', '2005-02-23', '2005-02-24',
       '2005-02-25', '2005-02-26', '2005-02-27', '2005-02-28'],
      dtype='datetime64[D]')
# 시간단위
np.arange('2005-02-01', '2005-02-02', dtype='datetime64[h]')
array(['2005-02-01T00', '2005-02-01T01', '2005-02-01T02', '2005-02-01T03',
       '2005-02-01T04', '2005-02-01T05', '2005-02-01T06', '2005-02-01T07',
       '2005-02-01T08', '2005-02-01T09', '2005-02-01T10', '2005-02-01T11',
       '2005-02-01T12', '2005-02-01T13', '2005-02-01T14', '2005-02-01T15',
       '2005-02-01T16', '2005-02-01T17', '2005-02-01T18', '2005-02-01T19',
       '2005-02-01T20', '2005-02-01T21', '2005-02-01T22', '2005-02-01T23'],
      dtype='datetime64[h]')
```

### `datetime64`을 이용한 날짜 차이 구하기

각각 날짜를 생성할 때 어떤 단위를 전달하는지에 따라서 생성되는 범위가 달라집니다. 두 날짜의 간격을 구할 때는 단순하게 빼주면 됩니다. 직관적인 날짜 간격을 구하기 쉽습니다. 날짜 간격을 구해봅시다. 2009년 1월 1일과 2008년 1월을 넣어봤습니다.

```python
np.datetime64('2009-01-01') - np.datetime64('2008-01')
numpy.timedelta64(366,'D')
```

366이라는 숫자가 나옵니다. 2009년 1월 1일은 단위가 일(day)이고, 2008년 1월은 단위가 월(month)인데 어떤 기준으로 366이 나온 것일까요? 이번에는 2009년 1월 1일과 2008년 1월 1일을 넣어봅시다.

```python
np.datetime64('2009-01-01') - np.datetime64('2008-01-01')
numpy.timedelta64(366,'D')
```

동일한 결과가 나옵니다. 다시 말해 위에서 2008년 1월을 했을 때 자동으로 2008년 1월 1일로 인식하여 366일의 차이가 나온 것이라고 추정해볼 수 있습니다. 이번에는 2009년과 2008년 1월의 차이를 구해봅시다. 2009년은 연(year)이고, 2008년 1월은 월(month) 단위인데 어떤 결과가 나올까요?

```python
np.datetime64('2009') - np.datetime64('2008-01')
numpy.timedelta64(12,'M')
```

12라는 숫자가 나옵니다. 추측컨대, 2009년 1월과 2008년 1월의 차이가 12개월이라는 의미인 것 같습니다. 위의 결과를 확인해보니, 날짜 간격을 구할 때 두 날짜 중 작은 단위 날짜로 맞춘다는 것을 확인할 수 있습니다. 사실 위의 출력 결과에서 'D'와 'M'은 연산이 수행된 단위를 의미합니다. 각각이 의미하는 단위는 다음과 같습니다.

- `Y`: 연
- `M`: 월
- `W`: 주
- `D`: 일
- `h`: 시간
- `m`: 분
- `s`: 초
- `ms`: 밀리초
- `us`: 마이크로초
- `ns`: 나노초
- `ps`: 피코초
- `fs`: 펨토초

위에서 살펴본 단위 코드는 날짜 형식을 다룰 때 적용되는 단위입니다. 위 정리를 통해서 두 날짜 간 간격이 일 단위 간격인지, 월 단위 간격인지 등을 확인할 수 있습니다. 월(M)과 분(m)은 대소문자를 구분하므로 주의해 사용합시다. 이외에 넘파이에서 제공하는 세부적인 기능도 많지만, 여기서는 이 정도만 알아보고 판다스로 넘어가도록 하겠습니다.

---

## 03. 날짜와 시간을 다루는 판다스(Pandas)

판다스는 테이블 데이터 및 시계열 데이터 구조를 조작하는 탁월한 기능을 제공하는 라이브러리입니다. 판다스는 내부적으로 넘파이를 포함하고 있어 날짜와 시간 관련 기능도 `datetime64`를 바탕으로 이루어지고 있습니다. 판다스만 잘 활용해도 짧은 코드로 강력한 기능을 구사할 수 있습니다.

대표적인 기능으로 날짜 범위 생성, 날짜 변환, 날짜 이동 등이 있습니다. 또한 `DataFrame` 객체의 인덱싱 기능은 데이터 필터링, 인덱싱, 피벗팅, 정렬, 슬라이싱 등 다양하게 활용이 가능합니다. 여기서는 판다스의 날짜와 시간 관련 기능을 살펴보겠습니다.

### `Timestamp`와 `DatetimeIndex`

- `pd.Timestamp()`
- `pd.to_datetime()`
- `pd.date_range()`

판다스에서 하나의 날짜만 사용할 때는 `Timestamp`로 표현하고 두 개 이상의 배열을 이룰 때는 `DatetimeIndex`로 표현합니다. 어떤 의미인지 실습을 통해 이해해봅시다.

```python
import pandas as pd
```

판다스의 `Timestamp` 함수를 사용하여 특정 날짜를 표현할 수 있습니다.

```python
pd.Timestamp(1239.1238934) # 디폴트로는 나노초로 되어져 있습니다.
#
# Timestamp('1970-01-01 00:00:00.000001239')
```

단위를 '일'로 바꿔서 실행해봅시다.

```python
pd.Timestamp(1239.1238934, unit='D') # Timestamp('1973-05-24 02:58:24.389760')
pd.Timestamp('2019-1-1')             # Timestamp('2019-01-01 00:00:00')
```

`Timestamp()` 함수는 특정 시점을 나타내는 날짜와 시간을 표현합니다. 판다스에서도 `Timestamp` 함수에 수치 데이터를 전달하고 unit(단위) 값을 매개변수로 넘기면 넘파이에서 살펴본 유닉스 시간을 이용한 방식임을 알 수 있습니다. UTC 시간 '1970년 1월 1일 00:00:00'부터 현재까지 경과 시간을 초 단위로 환산해 나타낸 방식입니다.

`to_datetime()` 함수로도 특정 시점 날짜와 시간을 생성할 수 있습니다. 한 개의 날짜만 생성하는 경우, 호출하는 함수는 다르지만 내부적으로 넘파이에서 datetime64를 통해 날짜를 만드는 것과 같습니다. 판다스 내부적으로 넘파이가 동작한다는 내용을 이런 출력 결과로 확인할 수 있습니다.

```python
pd.to_datetime('2019-1-1 12')
Timestamp('2019-01-01 12:00:00')
```

하지만 to_datetime()에 날짜들의 리스트를 넣을 경우 범위. 즉, DatetimeIndex를 표현하게 됩니다. DatetimeIndex라는 클래스로 배열이 생기고 데이터 타입이 datetime64[ns]로 표현되는 것을 확인할 수 있습니다.

```python
pd.to_datetime(['2018-1-1', '2019-1-2'])
DatetimeIndex(['2018-01-01', '2019-01-02'], dtype='datetime64[ns]', freq=None)
```

마지막으로, date_range() 함수는 특정 기간의 날짜를 자동 생성합니다. '2019-01'과 '2019-02'를 전달하면 출력 결과는 2월 말까지 데이터를 생성하는 것이 아니라 2월 1일자 데이터만 생성합니다. 간단하게 생각하면, 둘째 인자로 전달한 값의 월은 고려하지 않는다는 것입니다. 추후 데이터를 생성하거나 가공할 때 주의가 필요한 대목입니다.

```python
pd.date_range('2019-01','2019-02')
DatetimeIndex(['2019-01-01', '2019-01-02', '2019-01-03', '2019-01-04',
               '2019-01-05', '2019-01-06', '2019-01-07', '2019-01-08',
               '2019-01-09', '2019-01-10', '2019-01-11', '2019-01-12',
               '2019-01-13', '2019-01-14', '2019-01-15', '2019-01-16',
               '2019-01-17', '2019-01-18', '2019-01-19', '2019-01-20',
               '2019-01-21', '2019-01-22', '2019-01-23', '2019-01-24',
               '2019-01-25', '2019-01-26', '2019-01-27', '2019-01-28',
               '2019-01-29', '2019-01-30', '2019-01-31', '2019-02-01'],
              dtype='datetime64[ns]', freq='D')
```

### `Period`와 `PeriodIndex`

- `pd.Period()`
- `pd.period_range()`
이번에는 `Period`와 `PeriodIndex`에 대해서 이해해봅시다. 이를 생성하는 방법은 `Period` 함수와 `period_range` 함수가 있습니다.

```python
pd.Period('2019-01')
Period('2019-01', 'M')
```

이번에 배우는 `Period`와 `PeriodIndex`는 특정 시점이 아니라 기간을 포괄하는 개념입니다. 그래서 freq 인자를 사용할 수 있습니다. `pd.Period()`를 사용해 '2019-01'을 넣을 때 출력값이 기본적으로는 월 단위(`freq='M'`)으로 인식됩니다. 하지만 매개변수 `freq`를 일간. 즉, `daily`를 뜻하는 `'D'`로 설정하면 일 단위로 자동 생성되고 '2019-01'과는 달리 '2019-05-01'처럼 1일자까지 붙는 것을 확인할 수 있습니다.

```python
pd.Period('2019-05', freq='D')
Period('2019-05-01', 'D')
```

그리고 str 타입의 두 개 이상 날짜 데이터를 전달하면 PeriodIndex 클래스로 묶입니다.

```python
pd.period_range('2019-01','2019-02',freq='D')
PeriodIndex(['2019-01-01', '2019-01-02', '2019-01-03', '2019-01-04',
             '2019-01-05', '2019-01-06', '2019-01-07', '2019-01-08',
             '2019-01-09', '2019-01-10', '2019-01-11', '2019-01-12',
             '2019-01-13', '2019-01-14', '2019-01-15', '2019-01-16',
             '2019-01-17', '2019-01-18', '2019-01-19', '2019-01-20',
             '2019-01-21', '2019-01-22', '2019-01-23', '2019-01-24',
             '2019-01-25', '2019-01-26', '2019-01-27', '2019-01-28',
             '2019-01-29', '2019-01-30', '2019-01-31', '2019-02-01'],
            dtype='period[D]', freq='D')
```

### Timestamp Vs. Period

`pd.Period()`와 앞서 배운 `pd.Timestamp()`에 어떤 차이가 있는지 한번 비교 연산을 통해서 이해해보겠습니다.

```python
p = pd.Period('2019-06-13')
test = pd.Timestamp('2019-06-13 22:11')
p.start_time < test < p.end_time
# 
# True
```

`Timestamp`는 한 시점을 뜻하고, `Period`는 1일의 시작 시점부터 종료 시점까지의 범위를 포괄합니다.

```python 
p.start_time
# Timestamp('2019-06-13 00:00:00')
p.end_time
# Timestamp('2019-06-13 23:59:59.999999999')
```

---

## 04. FinanceDataReader

FinanceDataReader는 한국 주식 가격, 미국 주식 가격, 지수, 환율, 암호 화폐 가격, 종목 리스트 등을 제공하는 API 패키지입니다. 우선 해당 패키지를 설치해줍니다.

```sh
pip install -U finance-datareader
```

사용법을 이해해봅시다. 패키지를 임포트합니다.

```py
import FinanceDataReader as fdr
```

### 종목 리스트 가져오기

`StockListing()` 함수에 'KRX' 심볼을 전달하면, 한국 거래소에 상장된 전체 종목 리스트를 출력합니다.

```py
df_krx = fdr.StockListing('KRX')
```

df_krx의 타입을 확인해봅시다.

```py
type(df_krx)
pandas.core.frame.DataFrame
```

데이터프레임이 출력됩니다. df_krx를 출력해봅시다.

```py
df_krx
```

![df_krx](https://wikidocs.net/images/page/172650/df_krx.PNG)

`StockListing()` 함수에 미국 '`S&P500`' 심볼을 전달하면, `S&P 500` 지수에 등록된 전체 종목 리스트를 출력할 수 있습니다. 다음 코드는 미국 S&P 500에 등록된 모든 종목 리스트를 가져옵니다. `head()`는 데이터프레임에서 상위 5개의 샘플만을 출력합니다.

```py
df_spx = fdr.StockListing('S&P500')
df_spx.head()
```

해당 데이터프레임에 몇 개의 샘플이 있는지 확인해봅시다.

```py
print('s&p 종목 데이터프레임의 크기 :', len(df_spx))
# 
# s&p 종목 데이터프레임의 크기 : 503
```

종목 코드를 가져오는 방법을 알아보았으니 이제 가격 데이터를 가져오는 방법을 살펴봅시다.

### 가격 가져오기

한국 거래소에 상장된 종목은 단축 코드(여섯 자리)를 전달하면 가격 데이터를 가져올 수 있습니다. 함수 하나만 호출하면 가격 데이터를 정말 손쉽게 가져옵니다. 예를 들어 GS글로벌의 2018년 가격 데이터를 불러와봅시다. `head(10)`은 상위 10개의 샘플만을 출력합니다.

```py
# GS글로벌, 2018년
df = fdr.DataReader('001250', '2018')
df.head(10)
```

![gs글로벌](https://wikidocs.net/images/page/172650/gs%EA%B8%80%EB%A1%9C%EB%B2%8C.PNG)

미국 주가 데이터도 불러와봅시다. 미국 종목을 가져올 때는 티커(ticker) 명을 사용합니다. 티커란, 미국에서 사용하는 종목 코드이며 네 자리로 제안됩니다.

```py
# 애플(AAPL), 2017년
df = fdr.DataReader('AAPL', '2017')
df.head(10)
```

![apple](https://wikidocs.net/images/page/172650/apple.PNG)

다른 종목의 가격 데이터를 가져올 때도 마찬가지로 `DataReader`를 호출하면 됩니다. 아래 정리된 속성을 참고하여 다양한 값을 호출할 수 있습니다.

- __거래소별 전체 종목 코드 - `StockListing()` 함수__
  - 한국 거래소 : KRX(KOSPI, KOSDAQ, KONEX)
  - 미국 거래소 : NASDAQ, NYSE, AMEX, S&P500

- 가격 데이터 - `DataReader()` 함수
  - 국내 주식 : 005930(삼성전자), 091990(셀트리온헬스케어) 등
  - 해외 주식 : AAPL(애플), AMZN(아마존), GOOG(구글) 등
  - 각종 지수 : KS11(코스피 지수), KQ11(코스닥 지수), DJI(다우 지수), IXIC(나스닥 지수), US500(S&P5000)
  - 환율 데이터 : USD/KRX(원달러 환율), USD/EUR(달러당 유로화 환율), CNY/KRX(위완화 원화 환율)
  - 암호 화폐 가격 : BTC/USD(비트코인 달러 가격, 비트파이넥스), BTC/KRW(비트코인 원화 가격, 빗썸)

이외 상세한 옵션은 API 사용자 메뉴얼을 참고해주세요.

> 첨고: [<FontIcon icon="iconfont icon-github"/>`FinanceData/FinanceDataReader` - `wiki/Users-Guide`](https://github.com/FinanceData/FinanceDataReader/wiki/Users-Guide)

### 다양한 예시

아래는 다양한 종류의 데이터를 로드하는 예제입니다.

::: tabs

@tab:active APPL

```py
# 애플(AAPL), 2018-01-01 ~ 2018-03-30
df = fdr.DataReader('AAPL', '2018-01-01', '2018-03-30')
df.head()
```

![apple_2018](https://wikidocs.net/images/page/172650/apple_2018.PNG)

@tab KS11 

```py
# KS11 (KOSPI 지수), 2015년~현재
df = fdr.DataReader('KS11', '2015')
df.head()
```

![kospi_2015](https://wikidocs.net/images/page/172650/kospi_from_2015_to_now.PNG)

@tab USD/KRW

```py
# 원달러 환율, 1995년~현재
df = fdr.DataReader('USD/KRW', '1995')
df.head()
```

![krw](https://wikidocs.net/images/page/172650/krw.PNG)

@tab BTC/KRW

```py
# 비트코인 원화 가격 (빗썸), 2016년~현재
df = fdr.DataReader('BTC/KRW', '2016')
df.head()
```

![btc](https://wikidocs.net/images/page/172650/btc_2016.PNG)

:::

---

## 05. Quiz

총 3개의 퀴즈를 출제합니다. 해답은 이 페이지의 하단에 위치하지만, 해답을 보지않고 위에서 학습한 자료들을 참고하여 스스로 풀어보세요. 스스로 풀어보아야 성장합니다.

### Quiz 1

::: tabs 

@tab:active Question

아래의 문자열을 datetime 타입으로 변환해보세요. 단, 아래의 문자열은 2021년 8월 7일을 의미합니다.

```py
datetime_str = '07-08-2021'
```

@tab Answer

```py
import datetime

datetime_str = '07-08-2021'
format = '%d-%m-%Y'
datetime_dt = datetime.datetime.strptime(datetime_str, format)
print(datetime_dt)
#
# 2021-08-07 00:00:00
```

:::

### Quiz 2

::: tabs 

@tab:active Question

`FinanceDataReader` 패키지를 사용하여 미코바이오메드 종목의 2020년 1월 8일부터 2021년 7월 1일까지의 데이터를 로드 및 출력해보세요.

@tab Answer

```py
import FinanceDataReader as fdr

# 미코바이오메드의 종목 번호는 '214610'
df = fdr.DataReader('214610', '2020-01-08', '2021-07-01')
df
```

:::

### Quiz 3

::: tabs 

@tab:active Question

파이썬 패키지 Numpy를 사용하여 2021년 3월 1일부터 2021년 7월 1일 사이의 모든 일자를 출력하세요. 단, 7월 1일도 포함해야 합니다.

@tab Answer

```py
# 일단위
import numpy as np
np.arange('2021-03', '2021-07-02', dtype='datetime64[D]')
array(['2021-03-01', '2021-03-02', '2021-03-03', '2021-03-04',
       '2021-03-05', '2021-03-06', '2021-03-07', '2021-03-08',
       '2021-03-09', '2021-03-10', '2021-03-11', '2021-03-12',
       '2021-03-13', '2021-03-14', '2021-03-15', '2021-03-16',
       '2021-03-17', '2021-03-18', '2021-03-19', '2021-03-20',
       '2021-03-21', '2021-03-22', '2021-03-23', '2021-03-24',
       '2021-03-25', '2021-03-26', '2021-03-27', '2021-03-28',
       '2021-03-29', '2021-03-30', '2021-03-31', '2021-04-01',
       '2021-04-02', '2021-04-03', '2021-04-04', '2021-04-05',
       '2021-04-06', '2021-04-07', '2021-04-08', '2021-04-09',
       '2021-04-10', '2021-04-11', '2021-04-12', '2021-04-13',
       '2021-04-14', '2021-04-15', '2021-04-16', '2021-04-17',
       '2021-04-18', '2021-04-19', '2021-04-20', '2021-04-21',
       '2021-04-22', '2021-04-23', '2021-04-24', '2021-04-25',
       '2021-04-26', '2021-04-27', '2021-04-28', '2021-04-29',
       '2021-04-30', '2021-05-01', '2021-05-02', '2021-05-03',
       '2021-05-04', '2021-05-05', '2021-05-06', '2021-05-07',
       '2021-05-08', '2021-05-09', '2021-05-10', '2021-05-11',
       '2021-05-12', '2021-05-13', '2021-05-14', '2021-05-15',
       '2021-05-16', '2021-05-17', '2021-05-18', '2021-05-19',
       '2021-05-20', '2021-05-21', '2021-05-22', '2021-05-23',
       '2021-05-24', '2021-05-25', '2021-05-26', '2021-05-27',
       '2021-05-28', '2021-05-29', '2021-05-30', '2021-05-31',
       '2021-06-01', '2021-06-02', '2021-06-03', '2021-06-04',
       '2021-06-05', '2021-06-06', '2021-06-07', '2021-06-08',
       '2021-06-09', '2021-06-10', '2021-06-11', '2021-06-12',
       '2021-06-13', '2021-06-14', '2021-06-15', '2021-06-16',
       '2021-06-17', '2021-06-18', '2021-06-19', '2021-06-20',
       '2021-06-21', '2021-06-22', '2021-06-23', '2021-06-24',
       '2021-06-25', '2021-06-26', '2021-06-27', '2021-06-28',
       '2021-06-29', '2021-06-30', '2021-07-01'], dtype='datetime64[D]')
```

:::

---

<TagLinks />
