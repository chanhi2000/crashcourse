import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,a as n,t as m,b as s,w as i,n as p,g as l,e as a,d as e,r,o as k}from"./app-U_bew1in.js";const w={},f={id:"frontmatter-title-관련",tabindex:"-1"},g={class:"header-anchor",href:"#frontmatter-title-관련"},y={class:"table-of-contents"},v=n("hr",null,null,-1),b=a('<h2 id="protocols-and-extensions" tabindex="-1"><a class="header-anchor" href="#protocols-and-extensions"><span>Protocols and extensions</span></a></h2><p>Today you’re going to learn some truly Swifty functionality: protocols, extensions, and protocol extensions.</p><p>Protocol extensions allow us to do away with large, complex inheritance hierarchies, and replaces them with much smaller, simpler protocols that can be combined together. This really is the fulfillment of something Tony Hoare said many years ago: “inside every large program, there is a small program trying to get out.”</p><p>You’ll be using protocols from your very first SwiftUI project, and they’ll continue to be invaluable for your entire Swift coding career – it’s worth taking the time to get familiar with them.</p><p><strong>Today you have four tutorials to follow, where you’ll meet protocols, extensions, and more.</strong> Once you’ve watched each video and optionally gone through the extra reading, there are short tests to help make sure you’ve understood what was taught.</p><div class="hint-container tip"><p class="hint-container-title">Tip</p><p>This is one of the handful of days that will almost certainly take more than an hour to work through. I did warn you about this back in day 4, but that won’t make it feel any easier – there’s a lot to cover here! Remember, the optional reading is <em>optional</em> – if you understood a topic first time you’re welcome to skip it.</p></div><h3 id="_1-how-to-create-and-use-protocols" tabindex="-1"><a class="header-anchor" href="#_1-how-to-create-and-use-protocols"><span>1. How to create and use protocols</span></a></h3>',7),x={class:"hint-container details"},_=n("summary",null,"1. How to create and use protocols",-1),q=a(`<p>Protocols are a bit like contracts in Swift: they let us define what kinds of functionality we expect a data type to support, and Swift ensures that the rest of our code follows those rules.</p><p>Think about how we might write some code to simulate someone commuting from their home to their office. We might create a small Car struct, then write a function like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">commute</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> using vehicle<span class="token punctuation">:</span> <span class="token class-name">Car</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// lots of code here</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Of course, they might also commute by train, so we’d also write this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">commute</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> using vehicle<span class="token punctuation">:</span> <span class="token class-name">Train</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// lots of code here</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Or they might travel by bus:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">commute</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> using vehicle<span class="token punctuation">:</span> <span class="token class-name">Bus</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// lots of code here</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Or they might use a bike, an e-scooter, a ride share, or any number of other transport options.</p><p>The truth is that at this level we don’t actually care how the underlying trip happens. What we care about is much broader: how long might it take for the user to commute using each option, and how to perform the actual act of moving to the new location.</p><p>This is where protocols come in: they let us define a series of properties and methods that we want to use. They don’t <em>implement</em> those properties and methods – they don’t actually put any code behind it – they just say that the properties and methods must exist, a bit like a blueprint.</p><p>For example, we could define a new <code>Vehicle</code> protocol like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">estimateTime</span><span class="token punctuation">(</span><span class="token keyword">for</span> distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">travel</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Let’s break that down:</p><ul><li>To create a new protocol we write protocol followed by the <code>protocol</code> name. This is a new type, so we need to use camel case starting with an uppercase letter.</li><li>Inside the protocol we list all the methods we require in order for this protocol to work the way we expect.</li><li>These methods do not contain any code inside – there are no function bodies provided here. Instead, we’re specifying the method names, parameters, and return types. You can also mark methods as being throwing or mutating if needed.</li></ul><p>So we’ve made a protocol – how has that helped us?</p><p>Well, now we can design types that work with that protocol. This means creating new structs, classes, or enums that implement the requirements for that protocol, which is a process we call <em>adopting</em> or <em>conforming</em> to the protocol.</p><p>The protocol doesn’t specify the full range of functionality that must exist, only a bare minimum. This means when you create new types that conform to the protocol you can add all sorts of other properties and methods as needed.</p><p>For example, we could make a <code>Car</code> struct that conforms to <code>Vehicle</code>, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Car</span><span class="token punctuation">:</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">estimateTime</span><span class="token punctuation">(</span><span class="token keyword">for</span> distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span></span>
<span class="line">        distance <span class="token operator">/</span> <span class="token number">50</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">travel</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;I&#39;m driving </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">distance</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">km.&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">openSunroof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;It&#39;s a nice day!&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>There are a few things I want to draw particular attention to in that code:</p><ol><li>We tell Swift that <code>Car</code> conforms to <code>Vehicle</code> by using a colon after the name <code>Car</code>, just like how we mark subclasses.</li><li>All the methods we listed in <code>Vehicle</code> must exist <em>exactly</em> in <code>Car</code>. If they have slightly different names, accept different parameters, have different return types, etc, then Swift will say we haven’t conformed to the protocol.</li><li>The methods in <code>Car</code> provide actual implementations of the methods we defined in the protocol. In this case, that means our struct provides a rough estimate for how many minutes it takes to drive a certain distance, and prints a message when <code>travel()</code> is called.</li><li>The <code>openSunroof()</code> method doesn’t come from the <code>Vehicle</code> protocol, and doesn’t really make sense there because many vehicle types don’t have a sunroof. But that’s okay, because the protocol describes only the <em>minimum</em> functionality conforming types must have, and they can add their own as needed.</li></ol><p>So, now we’ve created a protocol, and made a <code>Car</code> struct that conforms to the protocol.</p><p>To finish off, let’s update the <code>commute()</code> function from earlier so that it uses the new methods we added to <code>Car</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">commute</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> using vehicle<span class="token punctuation">:</span> <span class="token class-name">Car</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> vehicle<span class="token punctuation">.</span><span class="token function">estimateTime</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> distance<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;That&#39;s too slow! I&#39;ll try a different vehicle.&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        vehicle<span class="token punctuation">.</span><span class="token function">travel</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> distance<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> car <span class="token operator">=</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">commute</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> using<span class="token punctuation">:</span> car<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That code all works, but here the protocol isn’t actually adding any value. Yes, it made us implement two very specific methods inside <code>Car</code>, but we could have done that without adding the protocol, so why bother?</p><p>Here comes the clever part: Swift knows that any type conforming to <code>Vehicle</code> must implement both the <code>estimateTime()</code> and <code>travel()</code> methods, and so it actually lets us use <code>Vehicle</code> as the type of our parameter rather than <code>Car</code>. We can rewrite the function to this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">commute</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> using vehicle<span class="token punctuation">:</span> <span class="token class-name">Vehicle</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Now we’re saying this function can be called with any type of data, as long as that type conforms to the <code>Vehicle</code> protocol. The body of the function doesn’t need to change, because Swift knows for sure that the <code>estimateTime()</code> and <code>travel()</code> methods exist.</p><p>If you’re <em>still</em> wondering why this is useful, consider the following struct:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Bicycle</span><span class="token punctuation">:</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">estimateTime</span><span class="token punctuation">(</span><span class="token keyword">for</span> distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span></span>
<span class="line">        distance <span class="token operator">/</span> <span class="token number">10</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">travel</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;I&#39;m cycling </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">distance</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">km.&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> bike <span class="token operator">=</span> <span class="token class-name">Bicycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">commute</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span> using<span class="token punctuation">:</span> bike<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now we have a second struct that also conforms to <code>Vehicle</code>, and this is where the power of protocols becomes apparent: we can now either pass a <code>Car</code> or a <code>Bicycle</code> into the <code>commute()</code> function. Internally the function can have all the logic it wants, and when it calls <code>estimateTime()</code> or <code>travel()</code> Swift will automatically use the appropriate one – if we pass in a car it will say “I’m driving”, but if we pass in a bike it will say “I’m cycling”.</p><p>So, protocols let us talk about the kind of functionality we want to work with, rather than the exact types. Rather than saying “this parameter must be a car”, we can instead say “this parameter can be anything at all, as long as it’s able to estimate travel time and move to a new location.”</p><p>As well as methods, you can also write protocols to describe <em>properties</em> that must exist on conforming types. To do this, write <code>var</code>, then a property name, then list whether it should be readable and/or writeable.</p><p>For example, we could specify that all types that conform <code>Vehicle</code> must specify how many seats they have and how many passengers they currently have, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">var</span> currentPassengers<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token keyword">set</span> <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">estimateTime</span><span class="token punctuation">(</span><span class="token keyword">for</span> distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">travel</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That adds two properties:</p><ol><li>A string called <code>name</code>, which must be readable. That might mean it’s a constant, but it might also be a computed property with a getter.</li><li>An integer called <code>currentPassengers</code>, which must be read-write. That might mean it’s a variable, but it might also be a computed property with a getter and setter.</li></ol><p>Type annotation is required for both of them, because we can’t provide a default value in a protocol, just like how protocols can’t provide implementations for methods.</p><p>With those two extra requirements in place, Swift will warn us that both <code>Car</code> and <code>Bicycle</code> no longer conform to the protocol because they are missing the properties. To fix that, we could add the following properties to <code>Car</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Car&quot;</span></span></span>
<span class="line"><span class="token keyword">var</span> currentPassengers <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"><span class="token class-name">And</span> these to <span class="token class-name">Bicycle</span><span class="token punctuation">:</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Bicycle&quot;</span></span></span>
<span class="line"><span class="token keyword">var</span> currentPassengers <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Again, though, you could replace those with computed properties as long as you obey the rules – if you use <code>{ get set }</code> then you can’t conform to the protocol using a constant property.</p><p>So now our protocol requires two methods and two properties, meaning that all conforming types must implement those four things in order for our code to work. This in turn means Swift knows for sure that functionality is present, so we can write code relying on it.</p><p>For example, we could write a method that accepts an array of vehicles and uses it to calculate estimates across a range of options:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">getTravelEstimates</span><span class="token punctuation">(</span>using vehicles<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Vehicle</span><span class="token punctuation">]</span><span class="token punctuation">,</span> distance<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">for</span> vehicle <span class="token keyword">in</span> vehicles <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">let</span> estimate <span class="token operator">=</span> vehicle<span class="token punctuation">.</span><span class="token function">estimateTime</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> distance<span class="token punctuation">)</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">vehicle<span class="token punctuation">.</span>name</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">estimate</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> hours to travel </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">distance</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">km&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>I hope that shows you the real power of protocols – we accept a whole array of the <code>Vehicle</code> protocol, which means we can pass in a <code>Car</code>, a <code>Bicycle</code>, or any other struct that conforms to <code>Vehicle</code>, and it will automatically work:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token function">getTravelEstimates</span><span class="token punctuation">(</span>using<span class="token punctuation">:</span> <span class="token punctuation">[</span>car<span class="token punctuation">,</span> bike<span class="token punctuation">]</span><span class="token punctuation">,</span> distance<span class="token punctuation">:</span> <span class="token number">150</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>As well as accepting protocols as parameters, you can also return protocols from a function if needed.</p><p>Tip: You can conform to as many protocols as you need, just by listing them one by one separated with a comma. If you ever need to subclass something <em>and</em> conform to a protocol, you should put the parent class name first, then write your protocols afterwards.</p>`,48),S=a('<div class="hint-container info"><p class="hint-container-title">1. How to create and use protocols - Additional</p><ul><li>Optional: <a href="https://hackingwithswift.com/quick-start/understanding-swift/why-does-swift-need-protocols" target="_blank" rel="noopener noreferrer">Why does Swift need protocols?</a></li><li>Test: <a href="https://hackingwithswift.com/review/sixty/protocols" target="_blank" rel="noopener noreferrer">Protocols</a></li></ul></div><h3 id="_2-how-to-use-opaque-return-types" tabindex="-1"><a class="header-anchor" href="#_2-how-to-use-opaque-return-types"><span>2. How to use opaque return types</span></a></h3>',2),I={class:"hint-container details"},T=n("summary",null,"2. How to use opaque return types",-1),C=a(`<p>Swift provides one really obscure, really complex, but really <em>important</em> feature called opaque return types, which let us remove complexity in our code. Honestly I wouldn’t cover it in a beginners course if it weren’t for one very important fact: you will see it immediately as soon as you create your very first SwiftUI project.</p><p><strong>Important</strong>: You don’t need to understand in detail how opaque return types work, only that they exist and do a very specific job. As you’re following along here you might start to wonder why this feature is useful, but trust me: it <em>is</em> important, and it <em>is</em> useful, so try to power through!</p><p>Let’s implement two simple functions:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">getRandomNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Int</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">...</span><span class="token number">6</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">getRandomBool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Bool</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Tip</strong>: <code>Bool.random()</code> returns either true or false. Unlike random integers and decimals, we don’t need to specify any parameters because there are no customization options.</p><p>So, <code>getRandomNumber()</code> returns a random integer, and <code>getRandomBool()</code> returns a random Boolean.</p><p>Both <code>Int</code> and <code>Bool</code> conform to a common Swift protocol called <code>Equatable</code>, which means “can be compared for equality.” The <code>Equatable</code> protocol is what allows us to use <code>==</code>, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">getRandomNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">getRandomNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Because both of these types conform to <code>Equatable</code>, we could try amending our function to return an <code>Equatable</code> value, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">getRandomNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Int</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">...</span><span class="token number">6</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">getRandomBool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Bool</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>However, that code won’t work, and Swift will throw up an error message that is unlikely to be helpful at this point in your Swift career: “protocol &#39;Equatable&#39; can only be used as a generic constraint because it has Self or associated type requirements”. What Swift’s error means is that returning <code>Equatable</code> doesn’t make sense, and understanding <em>why</em> it doesn’t make sense is the key to understanding opaque return types.</p><p>First up: yes, you <em>can</em> return protocols from functions, and often it’s a really helpful thing to do. For example, you might have a function that finds car rentals for users: it accepts the number of passengers that it needs to carry, along with how much luggage they want, but it might send back one of several structs: <code>Compact</code>, <code>‌SUV</code>, <code>Minivan</code>, and so on.</p><p>We can handle this by returning a <code>Vehicle</code> protocol that is adopted by all those structs, and so whoever calls the function will get back <em>some</em> kind of car matching their request without us having to write 10 different functions to handle all car varieties. Each of those car types will implement all the methods and properties of <code>Vehicle</code>, which means they are interchangeable – from a coding perspective we don’t care which of the options we get back.</p><p>Now think about sending back an <code>Int</code> or a <code>Bool</code>. Yes, both conform to <code>Equatable</code>, but they <em>aren’t</em> interchangeable – we can’t use <code>==</code> to compare an <code>Int</code> and a <code>Bool</code>, because Swift won’t let us regardless of what protocols they conform to.</p><p>Returning a protocol from a function is useful because it lets us hide information: rather than stating the exact type that is being returned, we get to focus on the <em>functionality</em> that is returned. In the case of a <code>Vehicle</code> protocol, that might mean reporting back the number of seats, the approximate fuel usage, and a price. This means we can change our code later without breaking things: we could return a <code>RaceCar</code>, or a <code>PickUpTruck</code>, etc, as long as they implement the properties and methods required by <code>Vehicle</code>.</p><p>Hiding information in this way is really useful, but it just isn’t possible with <code>Equatable</code> because it isn’t possible to compare two different <code>Equatable</code> things. Even if we call <code>getRandomNumber()</code> twice to get two integers, we can’t compare them because we’ve hidden their exact data type – we’ve hidden the fact that they are two integers that actually could be compared.</p><p>This is where opaque return types come in: they let us hide information in our code, but <em>not</em> from the Swift compiler. This means we reserve the right to make our code flexible internally so that we can return different things in the future, but Swift always understands the <em>actual</em> data type being returned and will check it appropriately.</p><p>To upgrade our two functions to opaque return types, add the keyword <code>some</code> before their return type, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">getRandomNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Int</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">...</span><span class="token number">6</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">getRandomBool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Bool</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>And now we <em>can</em> call <code>getRandomNumber()</code> twice and compare the results using <code>==</code>. From our perspective we still only have some <code>Equatable</code> data, but Swift knows that behind the scenes they are actually two integers.</p><p>Returning an opaque return type means we still get to focus on the functionality we want to return rather than the specific type, which in turn allows us to change our mind in the future without breaking the rest of our code. For example, <code>getRandomNumber()</code> could switch to using <code>Double.random(in:)</code> and the code would still work great.</p><p>But the advantage here is that Swift always knows the real underlying data type. It’s a subtle distinction, but returning <code>Vehicle</code> means &quot;any sort of Vehicle type but we don&#39;t know what&quot;, whereas returning <code>some Vehicle</code> means &quot;a specific sort of <code>Vehicle</code> type but we don&#39;t want to say which one.”</p><p>At this point I expect your head is spinning, so let me give you a real example of why this matters in SwiftUI. SwiftUI needs to know exactly what kind of layout you want to show on the screen, and so we write code to describe it.</p><p>In English, we might say something like this: “there’s a screen with a toolbar at the top, a tab bar at the bottom, and in the middle is a scrolling grid of color icons, each of which has a label below saying what the icon means written in a bold font, and when you tap an icon a message appears.”</p><p>When SwiftUI asks for our layout, that description – the whole thing – becomes the return type for the layout. We need to be explicit about every single thing we want to show on the screen, including positions, colors, font sizes, and more. Can you imagine typing that as your return type? It would be a mile long! And every time you changed the code to generate your layout, you’d need to change the return type to match.</p><p>This is where opaque return types come to the rescue: we can return the type <code>some View</code>, which means that some kind of view screen will be returned but we don’t want to have to write out its mile-long type. At the same time, Swift knows the real underlying type because that’s how opaque return types work: Swift always knows the exact type of data being sent back, and SwiftUI will use that create its layouts.</p><p>Like I said at the beginning, opaque return types are a really obscure, really complex, but really <em>important</em> feature, and I wouldn’t cover them in a beginners course if it weren’t for the fact that they are used extensively in SwiftUI.</p><p>So, when you see <code>some View</code> in your SwiftUI code, it’s effectively us telling Swift “this is going to send back some kind of view to lay out, but I don’t want to write out the exact thing – you figure it out for yourself.”</p>`,28),j=n("h3",{id:"_3-how-to-create-and-use-extensions",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_3-how-to-create-and-use-extensions"},[n("span",null,"3. How to create and use extensions")])],-1),H={class:"hint-container details"},B=n("summary",null,"3. How to create and use extensions",-1),A=a(`<p>Extensions let us add functionality to any type, whether we created it or someone else created it – even one of Apple’s own types.</p><p>To demonstrate this, I want to introduce you to a useful method on strings, called <code>trimmingCharacters(in:)</code>. This removes certain kinds of characters from the start or end of a string, such as alphanumeric letters, decimal digits, or, most commonly, whitespace and new lines.</p><p>Whitespace is the general term of the space character, the tab character, and a variety of other variants on those two. New lines are line breaks in text, which might <em>sound</em> simple but in practice of course there is no single one way of making them, so when we ask to trim new lines it will automatically take care of all the variants for us.</p><p>For example, here’s a string that has whitespace on either side:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">var</span> quote <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;   The truth is rarely pure and never simple   &quot;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>If we wanted to trim the whitespace and newlines on either side, we could do so like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> trimmed <span class="token operator">=</span> quote<span class="token punctuation">.</span><span class="token function">trimmingCharacters</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token punctuation">.</span>whitespacesAndNewlines<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The <code>.whitespacesAndNewlines</code> value comes from Apple’s Foundation API, and actually so does <code>trimmingCharacters(in:)</code> – like I said way back at the beginning of this course, Foundation is really packed with useful code!</p><p>Having to call <code>trimmingCharacters(in:)</code> every time is a bit wordy, so let’s write an extension to make it shorter:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">trimmed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">trimmingCharacters</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token punctuation">.</span>whitespacesAndNewlines<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Let’s break that down…</p><ol><li>We start with the <code>extension</code> keyword, which tells Swift we want to add functionality to an existing type.</li><li>Which type? Well, that comes next: we want to add functionality to <code>String</code>.</li><li>Now we open a brace, and all the code until the final closing brace is there to be added to strings.</li><li>We’re adding a new method called <code>trimmed()</code>, which returns a new string.</li><li>Inside there we call the same method as before: <code>trimmingCharacters(in:)</code>, sending back its result.</li><li>Notice how we can use <code>self</code> here – that automatically refers to the current string. This is possible because we’re currently in a string extension.</li></ol><p>And now everywhere we want to remove whitespace and newlines we can just write the following:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> trimmed <span class="token operator">=</span> quote<span class="token punctuation">.</span><span class="token function">trimmed</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Much easier!</p><p>That’s saved some typing, but is it <em>that</em> much better than a regular function?</p><p>Well, the truth is that we could have written a function like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">trim</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">    string<span class="token punctuation">.</span><span class="token function">trimmingCharacters</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token punctuation">.</span>whitespacesAndNewlines<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Then used it like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> trimmed2 <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span>quote<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That’s less code than using an extension, both in terms of making the function and using it. This kind of function is called a <em>global</em> function, because it’s available everywhere in our project.</p><p>However, the extension has a number of benefits over the global function, including:</p><ol><li>When you type <code>quote</code>. Xcode brings up a list of methods on the string, including all the ones we add in extensions. This makes our extra functionality easy to find.</li><li>Writing global functions makes your code rather messy – they are hard to organize and hard to keep track of. On the other hand, extensions are naturally grouped by the data type they are extending.</li><li>Because your extension methods are a full part of the original type, they get full access to the type’s internal data. That means they can use properties and methods marked with <code>private</code> access control, for example.</li></ol><p>What’s more, extensions make it easier to modify values in place – i.e., to change a value directly, rather than return a new value.</p><p>For example, earlier we wrote a <code>trimmed()</code> method that returns a new string with whitespace and newlines removed, but if we wanted to modify the string <em>directly</em> we could add this to the extension:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">trimmed</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Because the <code>quote</code> string was created as a variable, we can trim it in place like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">quote<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Notice how the method has slightly different naming now: when we return a new value we used <code>trimmed()</code>, but when we modified the string directly we used <code>trim()</code>. This is intentional, and is part of Swift’s design guidelines: if you’re returning a new value rather than changing it in place, you should use word endings like <code>ed</code> or <code>ing</code>, like <code>reversed()</code>.</p><p>Tip: Previously I introduced you to the <code>sorted()</code> method on arrays. Now you know this rule, you should realize that if you create a variable array you can use <code>sort()</code> on it to sort the array in place rather than returning a new copy.</p><p>You can also use extensions to add <em>properties</em> to types, but there is one rule: they must only be <em>computed</em> properties, not stored properties. The reason for this is that adding new stored properties would affect the actual size of the data types – if we added a bunch of stored properties to an integer then every integer everywhere would need to take up more space in memory, which would cause all sorts of problems.</p><p>Fortunately, we can still get a lot done using computed properties. For example, one property I like to add to strings is called <code>lines</code>, which breaks the string up into an array of individual lines. This wraps another string method called <code>components(separatedBy:)</code>, which breaks the string up into a string array by splitting it on a boundary of our choosing. In this case we’d want that boundary to be new lines, so we’d add this to our string extension:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">var</span> lines<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">components</span><span class="token punctuation">(</span>separatedBy<span class="token punctuation">:</span> <span class="token punctuation">.</span>newlines<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>With that in place we can now read the <code>lines</code> property of any string, like so:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> lyrics <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;&quot;&quot;</span>
<span class="line">But I keep cruising</span>
<span class="line">Can&#39;t stop, won&#39;t stop moving</span>
<span class="line">It&#39;s like I got this music in my mind</span>
<span class="line">Saying it&#39;s gonna be alright</span>
<span class="line">&quot;&quot;&quot;</span></span></span>
<span class="line"></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>lyrics<span class="token punctuation">.</span>lines<span class="token punctuation">.</span>count<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Whether they are single lines or complex pieces of functionality, extensions always have the same goal: to make your code easier to write, easier to read, and easier to maintain in the long term.</p><p>Before we’re done, I want to show you one really useful trick when working with extensions. You’ve seen previously how Swift automatically generates a memberwise initializer for structs, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> title<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token keyword">let</span> pageCount<span class="token punctuation">:</span> <span class="token class-name">Int</span></span>
<span class="line">    <span class="token keyword">let</span> readingHours<span class="token punctuation">:</span> <span class="token class-name">Int</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> lotr <span class="token operator">=</span> <span class="token class-name">Book</span><span class="token punctuation">(</span>title<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Lord of the Rings&quot;</span></span><span class="token punctuation">,</span> pageCount<span class="token punctuation">:</span> <span class="token number">1178</span><span class="token punctuation">,</span> readingHours<span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>I also mentioned how creating your own initializer means that Swift will no longer provide the memberwise one for us. This is intentional, because a custom initializer means we want to assign data based on some custom logic, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> title<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token keyword">let</span> pageCount<span class="token punctuation">:</span> <span class="token class-name">Int</span></span>
<span class="line">    <span class="token keyword">let</span> readingHours<span class="token punctuation">:</span> <span class="token class-name">Int</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">init</span><span class="token punctuation">(</span>title<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> pageCount<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title</span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>pageCount <span class="token operator">=</span> pageCount</span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>readingHours <span class="token operator">=</span> pageCount <span class="token operator">/</span> <span class="token number">50</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If Swift were to keep the memberwise initializer in this instance, it would skip our logic for calculating the approximate reading time.</p><p>However, <em>sometimes</em> you want both – you want the ability to use a custom initializer, but also retain Swift’s automatic memberwise initializer. In this situation it’s worth knowing exactly what Swift is doing: if we implement a custom initializer <em>inside our struct</em>, then Swift disables the automatic memberwise initializer.</p><p>That extra little detail might give you a hint on what’s coming next: if we implement a custom initializer inside an <em>extension</em>, then Swift <em>won’t</em> disable the automatic memberwise initializer. This makes sense if you think about it: if adding a new initializer inside an extension also disabled the default initializer, one small change from us could break all sorts of other Swift code.</p><p>So, if we wanted our <code>Book</code> struct to have the default memberwise initializer as well as our custom initializer, we’d place the custom one in an extension, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">init</span><span class="token punctuation">(</span>title<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> pageCount<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title</span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>pageCount <span class="token operator">=</span> pageCount</span>
<span class="line">        <span class="token keyword">self</span><span class="token punctuation">.</span>readingHours <span class="token operator">=</span> pageCount <span class="token operator">/</span> <span class="token number">50</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,45),V=a('<div class="hint-container info"><p class="hint-container-title">3. How to create and use extensions - Additional</p><ul><li>Optional: <a href="https://hackingwithswift.com/quick-start/understanding-swift/when-should-you-use-extensions-in-swift" target="_blank" rel="noopener noreferrer">When should you use extensions in Swift?</a></li><li>Test: <a href="https://hackingwithswift.com/review/sixty/extensions" target="_blank" rel="noopener noreferrer">Extensions</a></li></ul></div><h3 id="_4-how-to-create-and-use-protocol-extensions" tabindex="-1"><a class="header-anchor" href="#_4-how-to-create-and-use-protocol-extensions"><span>4. How to create and use protocol extensions</span></a></h3>',2),E={class:"hint-container details"},P=n("summary",null,"4. How to create and use protocol extensions",-1),N=a(`<p>Protocols let us define contracts that conforming types must adhere to, and extensions let us add functionality to existing types. But what would happen if we could write extensions on <em>protocols</em>?</p><p>Well, wonder no more because Swift supports exactly this using the aptly named <em>protocol extensions</em>: we can extend a whole protocol to add method implementations, meaning that any types conforming to that protocol get those methods.</p><p>Let’s start with a trivial example. It’s very common to write a condition checking whether an array has any values in, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> guests <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;Mario&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Luigi&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Peach&quot;</span></span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">if</span> guests<span class="token punctuation">.</span>isEmpty <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Guest count: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">guests<span class="token punctuation">.</span>count</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Some people prefer to use the Boolean <code>!</code> operator, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token operator">!</span>guests<span class="token punctuation">.</span>isEmpty <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Guest count: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">guests<span class="token punctuation">.</span>count</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>I’m not really a big fan of either of those approaches, because they just don’t read naturally to me “if not some array is empty”?</p><p>We can fix this with a really simple extension for <code>Array</code>, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">Array</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> isNotEmpty<span class="token punctuation">:</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">        isEmpty <span class="token operator">==</span> <span class="token boolean">false</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Tip: Xcode’s playgrounds run their code from top to bottom, so make sure you put that extension <em>before</em> where it’s used.</p><p>Now we can write code that I think is easier to understand:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">if</span> guests<span class="token punctuation">.</span>isNotEmpty <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Guest count: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">guests<span class="token punctuation">.</span>count</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>But we can do better. You see, we just added <code>isNotEmpty</code> to arrays, but what about sets and dictionaries? Sure, we could repeat ourself and copy the code into extensions for those, but there’s a better solution: <code>Array</code>, <code>Set</code>, and <code>Dictionary</code> all conform to a built-in protocol called <code>Collection</code>, through which they get functionality such as <code>contains()</code>, <code>sorted()</code>, <code>reversed()</code>, and more.</p><p>This is important, because <code>Collection</code> is also what requires the <code>isEmpty</code> property to exist. So, if we write an extension on <code>Collection</code>, we can still access <code>isEmpty</code> because it’s required. This means we can change <code>Array</code> to <code>Collection</code> in our code to get this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">Collection</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> isNotEmpty<span class="token punctuation">:</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">        isEmpty <span class="token operator">==</span> <span class="token boolean">false</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>With that one word change in place, we can now use <code>isNotEmpty</code> on arrays, sets, and dictionaries, as well as any other types that conform to <code>Collection</code>. Believe it or not, that tiny extension exists in thousands of Swift projects because so many other people find it easier to read.</p><p>More importantly, by extending the protocol we’re adding functionality that would otherwise need to be done inside individual structs. This is really powerful, and leads to a technique Apple calls <em>protocol-oriented programming</em> – we can list some required methods in a protocol, then add default implementations of those inside a protocol extension. All conforming types then get to use those default implementations, or provide their own as needed.</p><p>For example, if we had a protocol like this one:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That means all conforming types must add a <code>sayHello()</code> method, but we can also add a default implementation of that as an extension like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Hi, I&#39;m </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">name</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>And now conforming types <em>can</em> add their own <code>sayHello()</code> method if they want, but they don’t need to – they can always rely on the one provided inside our protocol extension.</p><p>So, we could create an employee without the <code>sayHello()</code> method:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Employee</span><span class="token punctuation">:</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>But because it conforms to <code>Person</code>, we could use the default implementation we provided in our extension:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Taylor Swift&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">taylor<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Swift uses protocol extensions a <em>lot</em>, but honestly you don’t need to understand them in great detail just yet – you can build fantastic apps without ever using a protocol extension. At this point you know they exist and that’s enough!</p>`,27),D=a('<div class="hint-container info"><p class="hint-container-title">4. How to create and use protocol extensions - Additional</p><ul><li>Optional: <a href="https://hackingwithswift.com/quick-start/understanding-swift/when-are-protocol-extensions-useful-in-swift" target="_blank" rel="noopener noreferrer">When are protocol extensions useful in Swift?</a></li><li>Test: <a href="https://hackingwithswift.com/review/sixty/protocol-extensionsqwep7" target="_blank" rel="noopener noreferrer">Protocol extensions</a></li></ul></div><h3 id="_5-summary-protocols-and-extensions" tabindex="-1"><a class="header-anchor" href="#_5-summary-protocols-and-extensions"><span>5. Summary: Protocols and extensions</span></a></h3>',2),W={class:"hint-container details"},R=n("summary",null,"5. Summary: Protocols and extensions",-1),z=n("p",null,"In these chapters we’ve covered some complex but powerful features of Swift, but don’t feel bad if you struggled a bit – these really are hard to grasp at first, and they’ll only really sink in once you’ve had time to try them out in your own code.",-1),U=n("p",null,"Let’s recap what we learned:",-1),F=n("ul",null,[n("li",null,"Protocols are like contracts for code: we specify the functions and methods that we required, and conforming types must implement them."),n("li",null,"Opaque return types let us hide some information in our code. That might mean we want to retain flexibility to change in the future, but also means we don’t need to write out gigantic return types."),n("li",null,"Extensions let us add functionality to our own custom types, or to Swift’s built-in types. This might mean adding a method, but we can also add computed properties."),n("li",null,"Protocol extensions let us add functionality to many types all at once – we can add properties and methods to a protocol, and all conforming types get access to them.")],-1),Y=n("p",null,[e("When we boil it down to that these features seem easy, but they aren’t. You need to know "),n("em",null,"about"),e(" them, to know that they exist, but you need to use them only superficially in order to continue your learning journey.")],-1),O=n("h3",{id:"_6-checkpoint-8",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_6-checkpoint-8"},[n("span",null,"6. Checkpoint 8")])],-1),L={class:"hint-container details"},K=n("summary",null,"6. Checkpoint 8",-1),M=a("<p>Now that you understand how protocols and extensions work, it’s time to pause our learning and take on a challenge so you can put it all into practice.</p><p>Your challenge is this: make a protocol that describes a building, adding various properties and methods, then create two structs, <code>House</code> and <code>Office</code>, that conform to it. Your protocol should require the following:</p><ol><li>A property storing how many rooms it has.</li><li>A property storing the cost as an integer (e.g. 500,000 for a building costing $500,000.)</li><li>A property storing the name of the estate agent responsible for selling the building.</li><li>A method for printing the sales summary of the building, describing what it is along with its other properties. I’ll provide some hints in a moment, but first I recommend you go ahead and try it yourself.</li></ol><p>Still here? Okay, here are some hints:</p><ol><li>Start by designing the protocol fully before you go near any structs.</li><li>Remember you can’t provide implementations for methods in your protocol.</li><li>You get to decide whether your properties should be get-only or have getters and setters. For example, maybe the number of rooms is constant, but perhaps you also want to take into account someone adding an extension.</li><li>You can control the read-write status of a property using <code>{ get }</code> or <code>{ get set }</code>.</li></ol>",5),G=n("p",null,[n("strong",null,"Bonus"),e(": If you have even more time on your hands and want to explore this topic a little further, I created an extra tutorial just for you: "),n("a",{href:"https://www.hackingwithswift.com/quick-start/beginners/how-to-get-the-most-from-protocol-extensions",target:"_blank",rel:"noopener noreferrer"},"How to get the most from protocol extensions"),e(". This is entirely optional, and definitely goes way beyond beginner Swift – you do "),n("em",null,"not"),e(" need to follow this tutorial in order to continue.")],-1),X=n("hr",null,null,-1);function Z(u,$){const t=r("router-link"),o=r("VPCard"),c=r("VidStack");return k(),h("div",null,[n("h1",f,[n("a",g,[n("span",null,m(u.$frontmatter.title)+" 관련",1)])]),n("nav",y,[n("ul",null,[n("li",null,[s(t,{to:"#protocols-and-extensions"},{default:i(()=>[e("Protocols and extensions")]),_:1}),n("ul",null,[n("li",null,[s(t,{to:"#_1-how-to-create-and-use-protocols"},{default:i(()=>[e("1. How to create and use protocols")]),_:1})]),n("li",null,[s(t,{to:"#_2-how-to-use-opaque-return-types"},{default:i(()=>[e("2. How to use opaque return types")]),_:1})]),n("li",null,[s(t,{to:"#_3-how-to-create-and-use-extensions"},{default:i(()=>[e("3. How to create and use extensions")]),_:1})]),n("li",null,[s(t,{to:"#_4-how-to-create-and-use-protocol-extensions"},{default:i(()=>[e("4. How to create and use protocol extensions")]),_:1})]),n("li",null,[s(t,{to:"#_5-summary-protocols-and-extensions"},{default:i(()=>[e("5. Summary: Protocols and extensions")]),_:1})]),n("li",null,[s(t,{to:"#_6-checkpoint-8"},{default:i(()=>[e("6. Checkpoint 8")]),_:1})])])])])]),v,s(o,p(l({title:"100 Days of SwiftUI - Day 13",desc:"Protocols and extensions",link:"https://www.hackingwithswift.com/100/swiftui/13",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),b,n("details",x,[_,s(o,p(l({title:"100 Days of SwiftUI - Day 13 - 1. How to create and use protocols",desc:"1. How to create and use protocols",link:"https://hackingwithswift.com/quick-start/beginners/how-to-create-and-use-protocols",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(c,{src:"youtube/1-5SXsVd1zY"}),q]),S,n("details",I,[T,s(o,p(l({title:"100 Days of SwiftUI - Day 13 - 2. How to use opaque return types",desc:"2. How to use opaque return types",link:"https://hackingwithswift.com/quick-start/beginners/how-to-use-opaque-return-types",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(c,{src:"youtube/Fyhm8RxwpKs"}),C]),j,n("details",H,[B,s(o,p(l({title:"100 Days of SwiftUI - Day 13 - 3. How to create and use extensions",desc:"3. How to create and use extensions",link:"https://hackingwithswift.com/quick-start/beginners/how-to-create-and-use-extensions",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(c,{src:"youtube/ALsr3hANqD0"}),A]),V,n("details",E,[P,s(o,p(l({title:"100 Days of SwiftUI - Day 13 - 4. How to create and use protocol extensions",desc:"4. How to create and use protocol extensions",link:"https://hackingwithswift.com/quick-start/beginners/how-to-create-and-use-protocol-extensions",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(c,{src:"youtube/YrVwyL_mcts"}),N]),D,n("details",W,[R,s(o,p(l({title:"100 Days of SwiftUI - Day 13 - 5. Summary: Protocols and extensions",desc:"5. Summary: Protocols and extensions",link:"https://hackingwithswift.com/quick-start/beginners/summary-protocols-and-extensions",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(c,{src:"youtube/U0IgKPgyAgw"}),z,U,F,Y]),O,n("details",L,[K,s(o,p(l({title:"100 Days of S6. Checkpoint 8wiftUI - Day 13 - ",desc:"6. Checkpoint 8",link:"https://hackingwithswift.com/quick-start/beginners/checkpoint-8",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),s(c,{src:"youtube/Ga800-Qgft4"}),M]),G,X])}const nn=d(w,[["render",Z],["__file","13.html.vue"]]),sn=JSON.parse('{"path":"/swift/100-days-of-swiftui/13.html","title":"Day 13","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Day 13","description":"100 Days of SwiftUI > Day 13","category":["Swift"],"tag":["crashcourse","paul-hudson","swift","swiftui","hacking-with-swift","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"100 Days of SwiftUI > Day 13"},{"property":"og:description","content":"Day 13"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/swift/100-days-of-swiftui/13.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/swift/100-days-of-swiftui/13.html"}],["meta",{"property":"og:site_name","content":"🥁Crashcourse"}],["meta",{"property":"og:title","content":"Day 13"}],["meta",{"property":"og:description","content":"100 Days of SwiftUI > Day 13"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"paul-hudson"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swiftui"}],["meta",{"property":"article:tag","content":"hacking-with-swift"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Day 13\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Protocols and extensions","slug":"protocols-and-extensions","link":"#protocols-and-extensions","children":[{"level":3,"title":"1. How to create and use protocols","slug":"_1-how-to-create-and-use-protocols","link":"#_1-how-to-create-and-use-protocols","children":[]},{"level":3,"title":"2. How to use opaque return types","slug":"_2-how-to-use-opaque-return-types","link":"#_2-how-to-use-opaque-return-types","children":[]},{"level":3,"title":"3. How to create and use extensions","slug":"_3-how-to-create-and-use-extensions","link":"#_3-how-to-create-and-use-extensions","children":[]},{"level":3,"title":"4. How to create and use protocol extensions","slug":"_4-how-to-create-and-use-protocol-extensions","link":"#_4-how-to-create-and-use-protocol-extensions","children":[]},{"level":3,"title":"5. Summary: Protocols and extensions","slug":"_5-summary-protocols-and-extensions","link":"#_5-summary-protocols-and-extensions","children":[]},{"level":3,"title":"6. Checkpoint 8","slug":"_6-checkpoint-8","link":"#_6-checkpoint-8","children":[]}]}],"git":{"createdTime":1703642364000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":9}]},"readingTime":{"minutes":20.08,"words":6025},"filePathRelative":"swift/100-days-of-swiftui/13.md","localizedDate":"2023년 12월 27일","excerpt":"\\n\\n<hr>\\n"}');export{nn as comp,sn as data};
