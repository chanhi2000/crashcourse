import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as m,a as s,t as u,b as a,n as c,g as r,d as e,e as o,r as t,o as k}from"./app-U_bew1in.js";const v={},b={id:"frontmatter-title-관련",tabindex:"-1"},h={class:"header-anchor",href:"#frontmatter-title-관련"},g=s("nav",{class:"table-of-contents"},[s("ul")],-1),_=s("hr",null,null,-1),f=o(`<p>앞에서 설명한 <code>--lin</code>k 옵션은 같은 서버의 컨테이너끼리 연결하는 옵션입니다. 이번에는 앰배서더 컨테이너(Ambassador Container)라는 것을 이용하여 다른 서버에 있는 컨테이너에 연결해보겠습니다.</p><p>앰배서더 컨테이너는 특별한 컨테이너가 아닌 그냥 일반적인 Docker 컨테이너입니다. 앰배서더 컨테이너는 <code>socat</code>이라는 프로그램을 이용하여 TCP 연결을 다른 곳으로 전달하도록 구성되어 있습니다.</p><figure><img src="https://pyrasis.com/assets/images/jHLsAlwaysUpToDateDocker/Unit06/4.png" alt="앰배서더 컨테이너 기본 개념" tabindex="0" loading="lazy"><figcaption>앰배서더 컨테이너 기본 개념</figcaption></figure><p>앰배서더 컨테이너의 Dockerfile을 보면 상당히 복잡하게 보이지만 생각보다 간단합니다. <code>docker run</code> 명령을 실행할 때 전달한 환경 변수를 이용하여 <code>socat</code>을 실행하는 셸 스크립트입니다.</p><div class="language-docker line-numbers-mode" data-highlighter="prismjs" data-ext="docker" data-title="docker"><pre><code><span class="line"><span class="token instruction"><span class="token keyword">CMD</span> env | grep _TCP= | <span class="token operator">\\</span></span>
<span class="line">  sed <span class="token string">&#39;s/.*_PORT_\\([0-9]*\\)_TCP=tcp:\\/\\/\\(.*\\):\\(.*\\)/socat \\</span>
<span class="line">  TCP4-LISTEN:\\1,fork,reuseaddr TCP4:\\2:\\3 \\&amp;/&#39;</span>  <span class="token operator">\\</span></span>
<span class="line">  | sh &amp;&amp; top</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>docker run</code> 명령에서 <code>--link</code> 옵션을 사용하거나 <code>-e EXAMPLE_PORT_1234_TCP=tcp://192.168.0.10:1234</code>라고 설정해주면 다음과 같이 환경 변수에 포트 정보가 설정됩니다.</p><p><code>env</code> 명령으로 환경 변수를 출력하고, <code>grep</code> 명령으로 <code>_TCP=</code>를 포함하는 문자열을 찾습니다. 그리고 <code>sed</code> 명령으로 정규표현식을 사용하여 문자열에서 포트 번호와 IP 주소를 추출합니다. 그 뒤 추출한 포트 번호와 IP 주소를을 이용하여 <code>socat</code> 명령을 실행합니다.</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token assign-left variable">EXAMPLE_PORT</span><span class="token operator">=</span>tcp://192.168.0.10:1234</span>
<span class="line"><span class="token assign-left variable">EXAMPLE_PORT_1234_TCP_ADDR</span><span class="token operator">=</span><span class="token number">192.168</span>.0.10</span>
<span class="line"><span class="token assign-left variable">EXAMPLE_NAME</span><span class="token operator">=</span>/example_ambassador/example</span>
<span class="line"><span class="token assign-left variable"><span class="token environment constant">HOSTNAME</span></span><span class="token operator">=</span>0cf479687cb0</span>
<span class="line"><span class="token assign-left variable">EXAMPLE_PORT_1234_TCP_PORT</span><span class="token operator">=</span><span class="token number">1234</span></span>
<span class="line"><span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span>/</span>
<span class="line"><span class="token assign-left variable">EXAMPLE_PORT_1234_TCP_PROTO</span><span class="token operator">=</span>tcp</span>
<span class="line"><span class="token assign-left variable">EXAMPLE_PORT_1234_TCP</span><span class="token operator">=</span>tcp://192.168.0.10:1234</span>
<span class="line"><span class="token assign-left variable"><span class="token environment constant">TERM</span></span><span class="token operator">=</span>xterm</span>
<span class="line"><span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span>
<span class="line"><span class="token assign-left variable"><span class="token environment constant">PWD</span></span><span class="token operator">=</span>/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>위 예제 환경에서는 <code>socat</code> 명령으로 로컬의 TCP 프로토콜 <code>1234</code>번 포트를 <code>192.168.0.10</code>의 <code>1234</code>번 포트로 데이터를 전달하도록 설정합니다. 이러한 구조를 앰배서더 패턴(Ambassador Pattern)이라 합니다.</p><p>그냥 다른 서버의 컨테이너에서 포트를 노출시키고, 해당 포트에 연결하면 간단한데 왜 이렇게 복잡한 방법을 사용할까요? 컨테이너에서 포트를 노출시키면 해당 서버의 IP 주소나 도메인을 알아야 합니다. 이렇게 되면 작성한 애플리케이션의 소스 레벨에서 IP 주소나 도메인을 설정해주어야 합니다. 만약 서버의 IP주소, 도메인이 바뀌면 소스를 수정해야 하는데, 앰배서더 컨테이너를 이용하면 별칭으로 접근하므로 소스를 수정하지 않아도 됩니다. 즉 외부에 있는 서버라도 같은 서버의 Docker 내부망에 있는 것과 같은 효과가 납니다.</p>`,10),y={class:"hint-container info"},P=s("p",{class:"hint-container-title"},"socat",-1),T=s("p",null,[e("socat은 "),s("strong",null,"SO"),e("cket "),s("strong",null,"CAT"),e("을 뜻하며 소켓 통신을 다른 채널로 전달하는 프로그램입니다. 채널은 파일, 파이프, 장치(시리얼, pseudo 터미널 등), 소켓(유닉스 소켓, TCP, UDP 등)이 있습니다.")],-1),D=s("code",null,"192.168.0.10",-1),C=o(`<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> pull redis:latest</span>
<span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis redis:latest</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>--name redis</code> 옵션으로 컨테이너 이름을 <code>redis</code>로 지정합니다.</p>`,2),R=s("code",null,"svendowideit",-1),w=o(`<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--link</span> redis:redis <span class="token parameter variable">--name</span> redis_ambassador <span class="token punctuation">\\</span></span>
<span class="line">  <span class="token parameter variable">-p</span> <span class="token number">6379</span>:6379 svendowideit/ambassador</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>-d</code> 옵션으로 컨테이너를 백그라운드로 실행합니다.</li><li><code>--link redis:redis</code> 옵션으로 <code>redis</code> 컨테이너를 <code>redis</code> 별칭으로 연결합니다.</li><li><code>--name redis_ambassador</code> 옵션으로 컨테이너 이름을 <code>redis_ambassador</code>로 지정합니다.</li><li><code>-p 6379:6379</code> 옵션으로 컨테이너의 <code>6379</code>번 포트와 호스트의 <code>6379</code> 연결하고 외부에 노출합니다.</li><li>Docker Hub에 있는 <code>svendowideit/ambassador</code> 이미지를 받은 뒤 컨테이너로 생성합니다(doc<code>ker run</code> 명령은 로컬에 이미지가 없으면 자동으로 이미지를 받아옵니다).</li></ul>`,2),E=s("code",null,"192.168.0.10",-1),A=o(`<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis_ambassador <span class="token parameter variable">--expose</span> <span class="token number">6379</span> <span class="token punctuation">\\</span></span>
<span class="line">  <span class="token parameter variable">-e</span> <span class="token assign-left variable">REDIS_PORT_6379_TCP</span><span class="token operator">=</span>tcp://192.168.0.10:6379 svendowideit/ambassador</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>-d</code> 옵션으로 컨테이너를 백그라운드로 실행합니다.</li><li><code>--name redis_ambassador</code> 옵션으로 컨테이너 이름을 <code>redis_ambassador</code>로 지정합니다.</li><li><code>--expose 6379</code> 옵션으로 다른 컨테이너에서 <code>6379</code>번 포트에 연결할 수 있도록 설정합니다. 즉 Redis 클라이언트가 이 <code>redis_ambassador</code> 컨테이너의 <code>6379</code> 포트에 접속하게 됩니다. <code>--expose</code> 옵션은 <code>-p</code> 옵션과는 달리 호스트의 포트를 외부에 노출하지 않습니다.</li><li><code>-e REDIS_PORT_6379_TCP=tcp://192.168.0.10:6379</code> 옵션으로 IP 주소와 포트를 설정하여 다른 서버에 있는 <code>redis_ambassador</code> 컨테이너에 연결합니다.</li><li>Docker Hub에 있는 <code>svendowideit/ambassador</code> 이미지 받은 뒤 컨테이너로 생성합니다.</li></ul><p>이제 Redis 클라이언트를 이용하여 <code>redis_ambassador</code> 컨테이너에 접속합니다.</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> run <span class="token parameter variable">-i</span> <span class="token parameter variable">-t</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--link</span> redis_ambassador redis:latest redis-cli <span class="token parameter variable">-h</span> redis_ambassador</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,4),x=s("li",null,[s("code",null,"-i -t"),e(" 옵션으로 콘솔에서 입출력을 할 수 있도록 설정합니다.")],-1),O=s("code",null,"--rm",-1),j=o("<li><code>--link redis_ambassador</code> 옵션으로 <code>redis_ambassador</code> 컨테이너를 연결합니다.</li><li><code>redis:latest redis-cli -h redis_ambassador</code>는 <code>redis:latest</code> 이미지를 받은 뒤 <code>redis-cli</code>로 <code>redis_ambassador</code> 컨테이너에 연결합니다.</li>",2),I=s("code",null,"ping",-1),L=s("code",null,"PONG",-1),M=o(`<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">ping</span></span>
<span class="line"><span class="token comment">#</span></span>
<span class="line"><span class="token comment"># PONG</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>`,2);function U(l,H){const i=t("VPCard"),d=t("SiteInfo"),n=t("FontIcon");return k(),m("div",null,[s("h1",b,[s("a",h,[s("span",null,u(l.$frontmatter.title)+" 관련",1)])]),a(i,c(r({title:"목차",desc:"언제나 최신 Docker",link:"/docker/always-up-to-date-docker/README.md",logo:"https://pyrasis.com/assets/images/pyrasis.png",background:"rgba(31,41,55,0.2)"})),null,16),g,_,a(d,{name:"6장 - 3. 다른 서버의 Docker 컨테이너에 연결하기",desc:"언제나 최신 Docker",url:"https://pyrasis.com/jHLsAlwaysUpToDateDocker/Unit06/03",logo:"https://pyrasis.com/assets/images/pyrasis.png",preview:"https://pyrasis.com/assets/images/jHLsAlwaysUpToDateDocker/Unit06/4.png"}),f,s("div",y,[P,T,a(i,c(r({title:"socat",desc:"Multipurpose relay",link:"http://www.dest-unreach.org/socat/",background:"rgba(255,255,255,0.2)"})),null,16)]),s("p",null,[e("이제 앰배서더 컨테이너를 이용해서 다른 서버의 컨테이너에 연결해보겠습니다. 그리고 원활한 테스트를 위해 "),a(n,{icon:"iconfont icon-redis"}),e("Redis를 사용하겠습니다.")]),s("p",null,[e("먼저 "),a(n,{icon:"iconfont icon-redis"}),e("Redis 서버로 쓸 컴퓨터에서 "),a(n,{icon:"iconfont icon-redis"}),e("Redis 컨테이너를 생성합니다. 이 서버의 IP 주소는 "),D,e("이라 하겠습니다.")]),C,s("p",null,[e("."),a(n,{icon:"iconfont icon-redis"}),e("Redis 컨테이너를 위한 앰배서더 컨테이너를 생성합니다. "),R,e("는 앰배서더 패턴을 만든 사람 이름입니다.")]),w,s("p",null,[e("이제 "),a(n,{icon:"iconfont icon-redis"}),e("Redis 클라이언트를 사용할 컴퓨터에서 앰배서더 컨테이너를 생성합니다. "),a(n,{icon:"iconfont icon-redis"}),e("Redis 서버의 IP 주소는 "),E,e("입니다.")]),A,s("ul",null,[x,s("li",null,[O,e(" 옵션으로 컨테이너를 실행만 하고 컨테이너 자체는 삭제합니다. "),a(n,{icon:"iconfont icon-redis"}),e("Redis 클라이언트처럼 1회성으로 사용할 때 편리합니다.")]),j]),s("p",null,[e("."),a(n,{icon:"iconfont icon-redis"}),e("Redis 클라이언트가 실행되면 "),I,e(" 명령을 입력합니다. 결과로 "),L,e("이 출력되면 다른 서버의 "),a(n,{icon:"iconfont icon-redis"}),e("Redis 컨테이너에 정상적으로 연결된 것입니다.")]),M])}const X=p(v,[["render",U],["__file","06C.html.vue"]]),V=JSON.parse('{"path":"/docker/always-up-to-date-docker/06C.html","title":"06C. 다른 서버의 Docker 컨테이너에 연결하기","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"06C. 다른 서버의 Docker 컨테이너에 연결하기","description":"언제나 최신 Docker > 06C. 다른 서버의 Docker 컨테이너에 연결하기","category":["DevOps","Docker"],"tag":["crashcourse","pyrasis.com","docker","devops"],"head":[[{"meta":null},{"property":"og:title","content":"언제나 최신 Docker > 06C. 다른 서버의 Docker 컨테이너에 연결하기"},{"property":"og:description","content":"06C. 다른 서버의 Docker 컨테이너에 연결하기"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/docker/always-up-to-date-docker/06C.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/docker/always-up-to-date-docker/06C.html"}],["meta",{"property":"og:site_name","content":"🥁Crashcourse"}],["meta",{"property":"og:title","content":"06C. 다른 서버의 Docker 컨테이너에 연결하기"}],["meta",{"property":"og:description","content":"언제나 최신 Docker > 06C. 다른 서버의 Docker 컨테이너에 연결하기"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pyrasis.com/assets/images/jHLsAlwaysUpToDateDocker/Unit06/4.png"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://pyrasis.com/assets/images/jHLsAlwaysUpToDateDocker/Unit06/4.png"}],["meta",{"name":"twitter:image:alt","content":"06C. 다른 서버의 Docker 컨테이너에 연결하기"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"pyrasis.com"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:tag","content":"devops"}],["meta",{"property":"article:published_time","content":"2022-10-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"06C. 다른 서버의 Docker 컨테이너에 연결하기\\",\\"image\\":[\\"https://pyrasis.com/assets/images/jHLsAlwaysUpToDateDocker/Unit06/4.png\\"],\\"datePublished\\":\\"2022-10-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]],"date":"2022-10-03T00:00:00.000Z","isOriginal":false,"cover":"https://pyrasis.com/assets/images/jHLsAlwaysUpToDateDocker/Unit06/4.png"},"headers":[],"git":{"createdTime":1716977950000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":3}]},"readingTime":{"minutes":1.54,"words":461},"filePathRelative":"docker/always-up-to-date-docker/06C.md","localizedDate":"2022년 10월 3일","excerpt":"\\n"}');export{X as comp,V as data};
