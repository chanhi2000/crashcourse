import{_ as u}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,a as s,t as w,b as e,w as t,n as o,g as i,e as c,r,o as k,d as l}from"./app-U_bew1in.js";const m={},f={id:"frontmatter-title-관련",tabindex:"-1"},g={class:"header-anchor",href:"#frontmatter-title-관련"},v={class:"table-of-contents"},b=s("hr",null,null,-1),y=c('<h2 id="project-5-part-two" tabindex="-1"><a class="header-anchor" href="#project-5-part-two"><span>Project 5, part two</span></a></h2><p>Language is complicated.</p><blockquote><p>One of my favorite TV comedies is called Blackadder, and featured a conversation between Dr Samuel Johnson (who had recently finished his dictionary of the English language), and Blackadder (butler to Prince George):</p><p>Samuel Johnson: “Here it is, sir. The very cornerstone of English scholarship. This book, sir, contains every word in our beloved language.”</p><p>Blackadder: “Every single one, sir?”</p><p>Samuel Johnson: “Every single word, sir!”</p><p>Blackadder: “Oh, well, in that case, sir, I hope you will not object if I also offer the doctor my most enthusiastic contrafibularities.”</p><p>Samuel Johnson: “What?”</p><p>Blackadder: “Contrafibularities, sir? It is a common word down our way.”</p><p>Samuel Johnson: “Damn!” <em>[adds it to his dictionary]</em></p><p>Blackadder: “Oh, I&#39;m sorry, sir. I&#39;m anaspeptic, phrasmotic, even compunctuous to have caused you such pericombobulation.”</p></blockquote><p>We can see further evidence of how complicated language is by looking at the way Swift handles strings. Have you ever wondered why you can’t read individual letters from strings using integer positions? In code, this kind of thing isn’t built into Swift: <code>let letter = someString[5]</code></p><p>The reason for this is that Swift uses a rather complicated – but extremely important! – system of storing its characters, known as <em>extended grapheme clusters</em>. This means for Swift to read character 8 of a string it needs to start at 0 and count through individual letters until it reaches the 8th one; it can’t jump straight there.</p><p>As a result, Swift doesn’t let us use <code>str[7]</code> to read the 8th character – even though they could enable such behavior trivially, it could easily result in folks using integer subscripting inside a loop, which would have <em>terrible</em> performance.</p><p>All this matters because today you’re going to be using <code>UITextChecker</code> to check whether a string is spelled correctly. This comes from UIKit, which was written in Objective-C, so we need to be very careful how we give it Swift strings to use.</p><p><strong>Today you have three topics to work through, and you’ll learn about using <code>UITextChecker</code> to find invalid words, inserting table view rows with animation, and more.</strong></p><h3 id="prepare-for-submission-lowercased-and-indexpath" tabindex="-1"><a class="header-anchor" href="#prepare-for-submission-lowercased-and-indexpath"><span>Prepare for submission: <code>lowercased()</code> and <code>IndexPath</code></span></a></h3>',9),x={class:"hint-container details"},T=s("summary",null,"Prepare for submission: lowercased() and IndexPath",-1),S=c(`<p>You can breathe again: we&#39;re done with closures for now. I know that wasn&#39;t easy, but once you understand basic closures you really have come a long way in your Swift adventure.</p><p>We&#39;re going to do some much easier coding now, because believe it or not we&#39;re not that far from making this game actually work!</p><p>We have now gone over the structure of a closure: trailing closure syntax, unowned self, a parameter being passed in, then the need for <code>self</code>. to make capturing clear. We haven&#39;t really talked about the actual content of our closure, because there isn&#39;t a lot to it. As a reminder, here&#39;s how it looks:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">guard</span> <span class="token keyword">let</span> answer <span class="token operator">=</span> ac<span class="token operator">?</span><span class="token punctuation">.</span>textFields<span class="token operator">?</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">self</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>answer<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>The first line safely unwraps the array of text fields – it&#39;s optional because there might not be any. The second line pulls out the text from the text field and passes it to our (all-new-albeit-empty) <code>submit()</code> method.</p><p>This method needs to check whether the player&#39;s word can be made from the given letters. It needs to check whether the word has been used already, because obviously we don&#39;t want duplicate words. It also needs to check whether the word is actually a valid English word, because otherwise the user can just type in nonsense.</p><p>If all three of those checks pass, <code>submit()</code> needs to add the word to the <code>usedWords</code> array, then insert a new row in the table view. We could just use the table view&#39;s <code>reloadData()</code> method to force a full reload, but that&#39;s not very efficient when we&#39;re changing just one row.</p><p>First, let’s create dummy methods for the three checks we’re going to do: is the word possible, is it original, and is it real? Each of these will accept a word string and return true or false, but for now we’ll just always return true – we’ll come back to these soon. Add these methods now:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">isPossible</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token boolean">true</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">isOriginal</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token boolean">true</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">isReal</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token boolean">true</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>With those three methods in place, we can write our first pass at the <code>submit()</code> method:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">submit</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> answer<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> lowerAnswer <span class="token operator">=</span> answer<span class="token punctuation">.</span><span class="token function">lowercased</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token function">isPossible</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> lowerAnswer<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token function">isOriginal</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> lowerAnswer<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token function">isReal</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> lowerAnswer<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                usedWords<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>answer<span class="token punctuation">,</span> at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">                <span class="token keyword">let</span> indexPath <span class="token operator">=</span> <span class="token class-name">IndexPath</span><span class="token punctuation">(</span>row<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> section<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">                tableView<span class="token punctuation">.</span><span class="token function">insertRows</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token punctuation">[</span>indexPath<span class="token punctuation">]</span><span class="token punctuation">,</span> with<span class="token punctuation">:</span> <span class="token punctuation">.</span>automatic<span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If a user types &quot;cease&quot; as a word that can be made out of our started word &quot;agencies&quot;, it&#39;s clear that is correct because there is one &quot;c&quot;, two &quot;e&quot;s, one &quot;a&quot; and one &quot;s&quot;. But what if they type &quot;Cease&quot;? Now it has a capital C, and &quot;agencies&quot; doesn&#39;t have a capital C. Yes, that&#39;s right: strings are case-sensitive, which means Cease is not cease is not CeasE is not CeAsE.</p><p>The solution to this is quite simple: all the starter words are lowercase, so when we check the player&#39;s answer we immediately lowercase it using its <code>lowercased()</code> method. This is stored in the <code>lowerAnswer</code> constant because we want to use it several times.</p><p>We then have three <code>if</code> statements, one inside another. These are called nested statements, because you nest one inside the other. Only if all three statements are true (the word is possible, the word hasn&#39;t been used yet, and the word is a real word), does the main block of code execute.</p><p>Once we know the word is good, we do three things: insert the new word into our <code>usedWords</code> array at index 0. This means &quot;add it to the start of the array,&quot; and means that the newest words will appear at the top of the table view.</p><p>The next two things are related: we insert a new row into the table view. Given that the table view gets all its data from the used words array, this might seem strange. After all, we just inserted the word into the <code>usedWords</code> array, so why do we need to insert anything into the table view?</p><p>The answer is animation. Like I said, we could just call the <code>reloadData()</code> method and have the table do a full reload of all rows, but it means a lot of extra work for one small change, and also causes a jump – the word wasn&#39;t there, and now it is.</p><p>This can be hard for users to track visually, so using <code>insertRows()</code> lets us tell the table view that a new row has been placed at a specific place in the array so that it can animate the new cell appearing. Adding one cell is also significantly easier than having to reload everything, as you might imagine!</p><p>There are two quirks here that require a little more detail. First, <code>IndexPath</code> is something we looked at briefly in project 1, as it contains a section and a row for every item in your table. As with project 1 we aren&#39;t using sections here, but the row number should equal the position we added the item in the array – position 0, in this case.</p><p>Second, the <code>with</code> parameter lets you specify how the row should be animated in. Whenever you&#39;re adding and removing things from a table, the <code>.automatic</code> value means &quot;do whatever is the standard system animation for this change.&quot; In this case, it means &quot;slide the new row in from the top.&quot;</p><p>Our three checking methods always return true regardless of what word is entered, but apart from that the game is starting to come together. Press <kbd>Cmd</kbd>+<kbd>R</kbd> to play back what you have: you should be able to tap the + button and enter words into the alert.</p>`,21),_=s("h3",{id:"checking-for-valid-answers",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#checking-for-valid-answers"},[s("span",null,"Checking for valid answers")])],-1),q={class:"hint-container details"},I=s("summary",null,"Checking for valid answers",-1),j=c(`<p>As you’ve seen, the <code>return</code> keyword exits a method at any time it&#39;s used. If you use <code>return</code> by itself, it exits the method and does nothing else. But if you use <code>return</code> with a value, it sends that value back to whatever called the method. We’ve used it previously to send back the number of rows in a table, for example.</p><p>Before you can send a value back, you need to tell Swift that you expect to return a value. Swift will automatically check that a value is returned and it&#39;s of the right data type, so this is important. We just put in stubs (empty methods that do nothing) for three new methods, each of which returns a value. Let&#39;s take a look at one in more detail:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">isOriginal</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token boolean">true</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The method is called <code>isOriginal()</code>, and it takes one parameter that&#39;s a string. But before the opening brace there&#39;s something important: <code>-&gt; Bool</code>. This tells Swift that the method will return a boolean value, which is the name for a value that can be either true or false.</p><p>The body of the method has just one line of code: <code>return true</code>. This is how the <code>return</code> statement is used to send a value back to its caller: we&#39;re returning true from this method, so the caller can use this method inside an <code>if</code> statement to check for true or false.</p><p>This method can have as much code as it needs in order to evaluate fully whether the word has been used or not, including calling any other methods it needs. We&#39;re going to change it so that it calls another method, which will check whether our <code>usedWords</code> array already contains the word that was provided. Replace its current <code>return true</code> code with this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">return</span> <span class="token operator">!</span>usedWords<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>There are two new things here. First, <code>contains()</code> is a method that checks whether the array it’s called on (<code>usedWords</code>) contains the value specified in parameter 2 (<code>word</code>). If it does contain the value, <code>contains()</code> returns true; if not, it returns false. Second, the <code>!</code> symbol. You&#39;ve seen this before as the way to force unwrap optional variables, but here it&#39;s something different: it means <em>not</em>.</p><p>The difference is small but important: when used before a variable or constant, <code>!</code> means &quot;not&quot; or &quot;opposite&quot;. So if <code>contains()</code> returns true, <code>!</code> flips it around to make it false, and vice versa. When used after a variable or constant, <code>!</code> means &quot;force unwrap this optional variable.&quot;</p><p>This is used because our method is called <code>isOriginal()</code>, and should return true if the word has never been used before. If we had used <code>return usedWords.contains(word)</code>, then it would do the opposite: it would return true if the word had been used and false otherwise. So, by using <code>!</code> we&#39;re flipping it around so that the method returns true if the word is new.</p><p>That&#39;s one method down. Next is the <code>isPossible()</code>, which also takes a string as its only parameter and returns a <code>Bool</code> – true or false. This one is more complicated, but I&#39;ve tried to make the algorithm as simple as possible.</p><p>How can we be sure that &quot;cease&quot; can be made from &quot;agencies&quot;, using each letter only once? The solution I&#39;ve adopted is to loop through every letter in the player&#39;s answer, seeing whether it exists in the eight-letter start word we are playing with. If it does exist, we remove the letter from the start word, then continue the loop. So, if we try to use a letter twice, it will exist the first time, but then get removed so it doesn&#39;t exist the next time, and the check will fail.</p><p>In project 4 we used the <code>contains()</code> method to see if one string exists inside another. Here we need something more precise: if it exists, <em>where</em>? That extra information allows us to remove the character from our word so that it won’t be used twice. Swift has a separate method for this called <code>firstIndex(of:)</code>, which will return the first position of the substring if it exists or nil otherwise.</p><p>To put that into practice, here’s the <code>isPossible()</code> method:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">isPossible</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">guard</span> <span class="token keyword">var</span> tempWord <span class="token operator">=</span> title<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">lowercased</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">false</span> <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> letter <span class="token keyword">in</span> word <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token keyword">let</span> position <span class="token operator">=</span> tempWord<span class="token punctuation">.</span><span class="token function">firstIndex</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> letter<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            tempWord<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> position<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token boolean">false</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> <span class="token boolean">true</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If the letter was found in the string, we use <code>remove(at:)</code> to remove the used letter from the <code>tempWord</code> variable. This is why we need the <code>tempWord</code> variable at all: because we&#39;ll be removing letters from it so we can check again the next time the loop goes around.</p><p>The method ends with <code>return true</code>, because this line is reached only if every letter in the user&#39;s word was found in the start word no more than once. If any letter isn&#39;t found, or is used more than possible, one of the <code>return false</code> lines would have been hit, so by this point we&#39;re sure the word is good.</p><p><strong>Important</strong>: we have told Swift that we are returning a boolean value from this method, and it will check every possible outcome of the code to make sure a boolean value is returned no matter what.</p><p>Time for the final method. Replace the current <code>isReal()</code> method with this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">isReal</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> checker <span class="token operator">=</span> <span class="token class-name">UITextChecker</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">let</span> range <span class="token operator">=</span> <span class="token class-name">NSRange</span><span class="token punctuation">(</span>location<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> word<span class="token punctuation">.</span>utf16<span class="token punctuation">.</span>count<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">let</span> misspelledRange <span class="token operator">=</span> checker<span class="token punctuation">.</span><span class="token function">rangeOfMisspelledWord</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">:</span> word<span class="token punctuation">,</span> range<span class="token punctuation">:</span> range<span class="token punctuation">,</span> startingAt<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> wrap<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> language<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;en&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> misspelledRange<span class="token punctuation">.</span>location <span class="token operator">==</span> <span class="token class-name">NSNotFound</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>There&#39;s a new class here, called <code>UITextChecker</code>. This is an iOS class that is designed to spot spelling errors, which makes it perfect for knowing if a given word is real or not. We&#39;re creating a new instance of the class and putting it into the chec\`ker constant for later.</p><p>There&#39;s a new type here too, called <code>NSRange</code>. This is used to store a string range, which is a value that holds a start position and a length. We want to examine the whole string, so we use 0 for the start position and the string&#39;s length for the length.</p><p>Next, we call the <code>rangeOfMisspelledWord(in:)</code> method of our <code>UITextChecker</code> instance. This wants five parameters, but we only care about the first two and the last one: the first parameter is our string, <code>word</code>, the second is our range to scan (the whole string), and the last is the language we should be checking with, where <code>en</code> selects English.</p><p>Parameters three and four aren&#39;t useful here, but for the sake of completeness: parameter three selects a point in the range where the text checker should start scanning, and parameter four lets us set whether the <code>UITextChecker</code> should start at the beginning of the range if no misspelled words were found starting from parameter three. Neat, but not helpful here.</p><p>Calling <code>rangeOfMisspelledWord(in:)</code> returns another <code>NSRange</code> structure, which tells us where the misspelling was found. But what we care about was whether any misspelling was found, and if nothing was found our <code>NSRange</code> will have the special location <code>NSNotFound</code>. Usually <code>location</code> would tell you where the misspelling started, but <code>NSNotFound</code> is telling us the word is spelled correctly – i.e., it&#39;s a valid word.</p><p><strong>Note</strong>: In case you were curious, <code>NSRange</code> pre-dates Swift, and therefore doesn’t have access to optionals – <code>NSNotFound</code> is effectively a magic number that means “not found”, assigned to a constant to make it easier to use.</p><p>Here the <code>return</code> statement is used in a new way: as part of an operation involving <code>==</code>. This is a very common way to code, and what happens is that <code>==</code> returns true or false depending on whether <code>misspelledRange.location</code> is equal to <code>NSNotFound</code>. That true or false is then given to <code>return</code> as the return value for the method.</p><p>We could have written that same line across multiple lines, but it&#39;s not common:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">if</span> misspelledRange<span class="token punctuation">.</span>location <span class="token operator">==</span> <span class="token class-name">NSNotFound</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token boolean">true</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token boolean">false</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That completes the third of our missing methods, so the project is almost complete. Run it now and give it a thorough test!</p><p>Before we continue, there’s one small thing I want to touch on briefly. In the <code>isPossible()</code> method we looped over each letter by treating the word as an array, but in this new code we use <code>word.utf16</code> instead. Why?</p><p>The answer is an annoying backwards compatibility quirk: Swift’s strings natively store international characters as individual characters, e.g. the letter “é” is stored as precisely that. However, UIKit was written in Objective-C before Swift’s strings came along, and it uses a different character system called UTF-16 – short for 16-bit Unicode Transformation Format – where the accent and the letter are stored separately.</p><p>It’s a subtle difference, and often it isn’t a difference at all, but it’s becoming increasingly problematic because of the rise of emoji – those little images that are frequently used in messages. Emoji are actually just special character combinations behind the scenes, and they are measured differently with Swift strings and UTF-16 strings: Swift strings count them as 1-letter strings, but UTF-16 considers them to be 2-letter strings. This means if you use <code>count</code> with UIKit methods, you run the risk of miscounting the string length.</p><p>I realize this seems like pointless additional complexity, so let me try to give you a simple rule: when you’re working with UIKit, SpriteKit, or any other Apple framework, use <code>utf16.count</code> for the character count. If it’s just your own code - i.e. looping over characters and processing each one individually – then use <code>count</code> instead.</p>`,34),P=s("h3",{id:"or-else-what",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#or-else-what"},[s("span",null,"Or else what?")])],-1),W={class:"hint-container details"},O=s("summary",null,"Or else what?",-1),C=c(`<p>here remains one problem to fix with our code, and it&#39;s quite a tedious problem. If the word is possible and original and real, we add it to the list of found words then insert it into the table view. But what if the word isn&#39;t possible? Or if it&#39;s possible but not original? In this case, we reject the word and don&#39;t say why, so the user gets no feedback.</p><p>So, the final part of our project is to give users feedback when they make an invalid move. This is tedious because it&#39;s just adding <code>else</code> statements to all the <code>if</code> statements in <code>submit()</code>, each time configuring a message to show to users.</p><p>Here&#39;s the adjusted method:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">submit</span><span class="token punctuation">(</span>answer<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> lowerAnswer <span class="token operator">=</span> answer<span class="token punctuation">.</span><span class="token function">lowercased</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">let</span> errorTitle<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">    <span class="token keyword">let</span> errorMessage<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token function">isPossible</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> lowerAnswer<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token function">isOriginal</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> lowerAnswer<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token function">isReal</span><span class="token punctuation">(</span>word<span class="token punctuation">:</span> lowerAnswer<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                usedWords<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>answer<span class="token punctuation">,</span> at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">                <span class="token keyword">let</span> indexPath <span class="token operator">=</span> <span class="token class-name">IndexPath</span><span class="token punctuation">(</span>row<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> section<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">                tableView<span class="token punctuation">.</span><span class="token function">insertRows</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token punctuation">[</span>indexPath<span class="token punctuation">]</span><span class="token punctuation">,</span> with<span class="token punctuation">:</span> <span class="token punctuation">.</span>automatic<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">                <span class="token keyword">return</span></span>
<span class="line">            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">                errorTitle <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Word not recognised&quot;</span></span></span>
<span class="line">                errorMessage <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;You can&#39;t just make them up, you know!&quot;</span></span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            errorTitle <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Word used already&quot;</span></span></span>
<span class="line">            errorMessage <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Be more original!&quot;</span></span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">guard</span> <span class="token keyword">let</span> title <span class="token operator">=</span> title<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">lowercased</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span></span>
<span class="line">        errorTitle <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Word not possible&quot;</span></span></span>
<span class="line">        errorMessage <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;You can&#39;t spell that word from </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">title</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">let</span> ac <span class="token operator">=</span> <span class="token class-name">UIAlertController</span><span class="token punctuation">(</span>title<span class="token punctuation">:</span> errorTitle<span class="token punctuation">,</span> message<span class="token punctuation">:</span> errorMessage<span class="token punctuation">,</span> preferredStyle<span class="token punctuation">:</span> <span class="token punctuation">.</span>alert<span class="token punctuation">)</span></span>
<span class="line">    ac<span class="token punctuation">.</span><span class="token function">addAction</span><span class="token punctuation">(</span><span class="token class-name">UIAlertAction</span><span class="token punctuation">(</span>title<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;OK&quot;</span></span><span class="token punctuation">,</span> style<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token function">present</span><span class="token punctuation">(</span>ac<span class="token punctuation">,</span> animated<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>As you can see, every <code>if</code> statement now has a matching <code>else</code> statement so that the user gets appropriate feedback. All the <code>else</code>s are effectively the same (albeit with changing text): set the values for <code>errorTitle</code> and <code>errorMessage</code> to something useful for the user. The only interesting exception is the last one, where we use string interpolation to show the view controller&#39;s title as a lowercase string.</p><p>If the user enters a valid answer, a call to <code>return</code> forces Swift to exit the method immediately once the table has been updated. This is helpful, because at the end of the method there is code to create a new <code>UIAlertController</code> with the error title and message that was set, add an OK button without a handler (i.e., just dismiss the alert), then show the alert. So, this error will only be shown if something went wrong.</p><p>This demonstrates one important tip about Swift constants: both <code>errorTitle</code> and <code>errorMessage</code> were declared as constants, which means their value cannot be changed once set. I didn&#39;t give either of them an initial value, and that&#39;s OK – Swift lets you do this as long as you do provide a value before the constants are read, and also as long as you don&#39;t try to change the value again later on.</p><p>Other than that, your project is done. Go and play!</p>`,8),A=s("hr",null,null,-1);function N(d,D){const n=r("router-link"),a=r("VPCard"),p=r("VidStack");return k(),h("div",null,[s("h1",f,[s("a",g,[s("span",null,w(d.$frontmatter.title)+" 관련",1)])]),s("nav",v,[s("ul",null,[s("li",null,[e(n,{to:"#project-5-part-two"},{default:t(()=>[l("Project 5, part two")]),_:1}),s("ul",null,[s("li",null,[e(n,{to:"#prepare-for-submission-lowercased-and-indexpath"},{default:t(()=>[l("Prepare for submission: lowercased() and IndexPath")]),_:1})]),s("li",null,[e(n,{to:"#checking-for-valid-answers"},{default:t(()=>[l("Checking for valid answers")]),_:1})]),s("li",null,[e(n,{to:"#or-else-what"},{default:t(()=>[l("Or else what?")]),_:1})])])])])]),b,e(a,o(i({title:"100 Days of Swift - Day 28",desc:"Project 5, part two",link:"https://www.hackingwithswift.com/100/28",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),y,s("details",x,[T,e(a,o(i({title:"100 Days of Swift - Day 28 - Prepare for submission: lowercased() and IndexPath",desc:"Prepare for submission: lowercased() and IndexPath",link:"https://hackingwithswfit.com/read/5/4/prepare-for-submission-lowercased-and-indexpath",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),e(p,{src:"youtube/jjOcsdYZE9c"}),S]),_,s("details",q,[I,e(a,o(i({title:"100 Days of Swift - Day 28 - Checking for valid answers",desc:"Checking for valid answers",link:"https://hackingwithswfit.com/read/5/5/checking-for-valid-answers",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),e(p,{src:"youtube/mZdSnxVG9pM"}),j]),P,s("details",W,[O,e(a,o(i({title:"100 Days of Swift - Day 28 - Or else what?",desc:"Or else what?",link:"https://hackingwithswfit.com/read/5/6/or-else-what",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),e(p,{src:"youtube/Dh__ZeZJbOg"}),C]),A])}const U=u(m,[["render",N],["__file","28.html.vue"]]),F=JSON.parse('{"path":"/swift/100-days-of-swift/28.html","title":"Day 28","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Day 28","description":"100 Days of Swift > Day 28","category":["Swift"],"tag":["crashcourse","paul-hudson","swift","hacking-with-swift","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"100 Days of Swift > Day 28"},{"property":"og:description","content":"Day 28"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/swift/100-days-of-swift/28.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/swift/100-days-of-swift/28.html"}],["meta",{"property":"og:site_name","content":"🥁Crashcourse"}],["meta",{"property":"og:title","content":"Day 28"}],["meta",{"property":"og:description","content":"100 Days of Swift > Day 28"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"paul-hudson"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"hacking-with-swift"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Day 28\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Project 5, part two","slug":"project-5-part-two","link":"#project-5-part-two","children":[{"level":3,"title":"Prepare for submission: lowercased() and IndexPath","slug":"prepare-for-submission-lowercased-and-indexpath","link":"#prepare-for-submission-lowercased-and-indexpath","children":[]},{"level":3,"title":"Checking for valid answers","slug":"checking-for-valid-answers","link":"#checking-for-valid-answers","children":[]},{"level":3,"title":"Or else what?","slug":"or-else-what","link":"#or-else-what","children":[]}]}],"git":{"createdTime":1703642364000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":9}]},"readingTime":{"minutes":12.15,"words":3646},"filePathRelative":"swift/100-days-of-swift/28.md","localizedDate":"2023년 12월 27일","excerpt":"\\n\\n<hr>\\n"}');export{U as comp,F as data};
