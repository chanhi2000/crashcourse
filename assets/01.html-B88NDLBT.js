import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,a as e,t as d,b as t,n as p,g as m,d as a,w as h,e as o,r as s,o as u}from"./app-U_bew1in.js";const g={},y={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},k={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},f=e("nav",{class:"table-of-contents"},[e("ul")],-1),P=e("hr",null,null,-1),_=o(`<p><code>ParsecT</code> is the main parser monad transformer and the central data type in <code>megaparsec</code>. <code>ParsecT e s m a</code> is parametrized like this:</p><ul><li><code>e</code> is the type of custom component of error messages. If we do not want anything custom (and for now we do not), we just use <code>Void</code> from the <code>Data.Void</code> module.</li><li><code>s</code> is the type of input stream. <code>megaparsec</code> works out-of-the-box with <code>String</code>, strict and lazy <code>Text</code>, and strict and lazy <code>ByteStrings</code>. It is also possible to work with custom input streams.</li><li><code>m</code> is the inner monad of the <code>ParsecT</code> monad transformer.</li><li><code>a</code> is the monadic value, result of parsing.</li></ul><p>Since most of the time <code>m</code> is nothing but <code>Identity</code>, the <code>Parsec</code> type synonym is quite useful:</p><div class="language-haskell line-numbers-mode" data-highlighter="prismjs" data-ext="haskell" data-title="haskell"><pre><code><span class="line"><span class="token keyword">type</span> <span class="token constant">Parsec</span> <span class="token hvariable">e</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">ParsecT</span> <span class="token hvariable">e</span> <span class="token hvariable">s</span> <span class="token constant">Identity</span> <span class="token hvariable">a</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>Parsec</code> is simply the non-transformer version of <code>ParsecT</code>.</p>`,5),v=e("code",null,"megaparsec",-1),b=e("code",null,"MonadParsec",-1),w=e("code",null,"MonadState",-1),T=e("code",null,"MonadReader",-1),x=e("code",null,"MonadParsec",-1),M=o(`<p>Speaking of type synonyms, the best way to start writing parser with <code>megaparsec</code> is to define a custom type synonym for your parser. This is a good idea for two reasons:</p><p>It will be easier to add top level signatures like <code>Parser Int</code> where <code>Parser</code> is your parsing monad. Without the signatures, things like <code>e</code> will often be ambiguous‚Äîit is the flip side of the polymorphic API of the library.</p><p>Working with concrete types with all type variables fixed helps GHC optimize a lot better. GHC cannot do much in terms of optimization if your parsers stay polymorphic. Although <code>megaparsec</code> API is polymorphic, it is expected that end user will stick to a concrete type of parsing monad, so inlining and the fact that most functions have their definition dumped into so-called interface files will allow GHC produce very efficient non-polymorphic code.</p><p>Let‚Äôs define a type synonym (typically called <code>Parser</code>) like this:</p><div class="language-haskell line-numbers-mode" data-highlighter="prismjs" data-ext="haskell" data-title="haskell"><pre><code><span class="line"><span class="token keyword">type</span> <span class="token constant">Parser</span> <span class="token operator">=</span> <span class="token constant">Parsec</span> <span class="token constant">Void</span> <span class="token constant">Text</span></span>
<span class="line"><span class="token comment">--                   ^    ^</span></span>
<span class="line"><span class="token comment">--                   |    |</span></span>
<span class="line"><span class="token comment">-- Custom error component Type of input stream</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Until we start dealing with custom parsing errors, when you see Parser in the chapter, assume this type.</p><hr>`,7);function C(n,I){const r=s("VPCard"),c=s("RouteLink");return u(),l("div",null,[e("h1",y,[e("a",k,[e("span",null,d(n.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),f,P,t(r,p(m({title:"Megaparsec tutorial > ParsecT and Parsec monads",desc:"ParsecT and Parsec monads",link:"https://markkarpov.com/tutorial/megaparsec.html#parsect-and-parsec-monads",logo:"https://markkarpov.com/static/img/site-icon.png",background:"rgba(86,86,125,0.2)"})),null,16),_,e("p",null,[a("We can also draw an analogy between the monad transformers in "),v,a(" and MTL monad transformers and classes. Indeed, there is also the "),b,a(" type class which is similar in its purpose to type classes such as "),w,a(" and "),T,a(". We will return to "),x,a(),t(c,{to:"/haskell/megaparsec/10.html"},{default:h(()=>[a("later")]),_:1}),a(" and discuss it in more details.")]),M])}const S=i(g,[["render",C],["__file","01.html.vue"]]),z=JSON.parse('{"path":"/haskell/megaparsec/01.html","title":"01. ParsecT and Parsec monads","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"01. ParsecT and Parsec monads","description":"üêëMegaparsec tutorial > 01. ParsecT and Parsec monads","category":["Haskell"],"tag":["crashcourse","haskell","parsec","attoparsec","trifecta"],"head":[[{"meta":null},{"property":"og:title","content":"üêëMegaparsec tutorial > 01. ParsecT and Parsec monads"},{"property":"og:description","content":"01. ParsecT and Parsec monads"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/haskell/megaparsec/01.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/haskell/megaparsec/01.html"}],["meta",{"property":"og:site_name","content":"ü•ÅCrashcourse"}],["meta",{"property":"og:title","content":"01. ParsecT and Parsec monads"}],["meta",{"property":"og:description","content":"üêëMegaparsec tutorial > 01. ParsecT and Parsec monads"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"haskell"}],["meta",{"property":"article:tag","content":"parsec"}],["meta",{"property":"article:tag","content":"attoparsec"}],["meta",{"property":"article:tag","content":"trifecta"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"01. ParsecT and Parsec monads\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1709471553000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":4}]},"readingTime":{"minutes":1.58,"words":473},"filePathRelative":"haskell/megaparsec/01.md","localizedDate":"2024ÎÖÑ 3Ïõî 3Ïùº","excerpt":"\\n\\n<hr>\\n"}');export{S as comp,z as data};
