import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as e,t as r,b as s,w as a,n as d,g as u,e as m,r as o,o as h,d as t}from"./app-U_bew1in.js";const f={},k={id:"frontmatter-title-관련",tabindex:"-1"},b={class:"header-anchor",href:"#frontmatter-title-관련"},v={class:"table-of-contents"},g=e("hr",null,null,-1),y=m(`<blockquote><p>Assembly code generated from Rust for parameter passing</p></blockquote><hr><p>Here we will be exploring the performance implications of passing the <code>self</code> parameter by value, reference, and smart pointers (<code>Box</code>, <code>Rc</code> and <code>Arc</code>). The generated assembly code will help us understand what happens under the hood.</p><p>We will be working with the <code>Complex</code> struct defined below. The code shows how a struct and its associated methods declarations in Rust. Note that like Python, the <code>self</code> parameter that refers to the associated object is passed explicitly in the method declaration.</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>rc<span class="token punctuation">::</span></span><span class="token class-name">Rc</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>sync<span class="token punctuation">::</span></span><span class="token class-name">Arc</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token attribute attr-name">#[derive(Copy, Clone)]</span></span>
<span class="line"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Complex</span> <span class="token punctuation">{</span></span>
<span class="line">    real<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span></span>
<span class="line">    imaginary<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">impl</span> <span class="token class-name">Complex</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">magnitude_self_copy</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>real<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imaginary<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">magnitude_self_reference</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>real<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imaginary<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// Passing smart pointers</span></span>
<span class="line">    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">magnitude_self_box</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>real<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imaginary<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">magnitude_self_rc</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>real<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imaginary<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">magnitude_self_arc</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Arc</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>real<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imaginary<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>self</code> parameter in a method can specify the expected ownership model for the object. The following table shows <code>self</code> with different ownership models used in the methods associated with the <code>Complex</code> struct.</p><table><thead><tr><th style="text-align:center;"><code>Self</code> <strong>type</strong></th><th style="text-align:left;">Passed parameter (highlighted in green)</th><th style="text-align:left;">Implication</th></tr></thead><tbody><tr><td style="text-align:center;"><code>self</code></td><td style="text-align:left;"><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/self.svg" alt="Passing self by value" loading="lazy"></td><td style="text-align:left;">By default, Rust assumes that a parameter passed by value is moved. The ownership of the parameter passes to the called function. In this example, however, the <code>Complex</code> type implements <code>Copy</code> and <code>Clone</code> traits. In this case, the compiler is copying the complete object to the method.</td></tr><tr><td style="text-align:center;"><code>&amp;self</code></td><td style="text-align:left;"><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/ref_self.svg" alt="Passing self by reference" loading="lazy"></td><td style="text-align:left;">The method is immutably borrowing the object. Here the compiler will pass the address of <code>Complex</code> object to the method.</td></tr><tr><td style="text-align:center;"><code>self : Box&lt;Self&gt;</code></td><td style="text-align:left;"><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/box_self.svg" alt="Passing self by a Box pointer" loading="lazy"></td><td style="text-align:left;"><code>Box</code> is like the <code>unique_ptr</code> in C++. Here the object is allocated on the heap. The method gets complete ownership of the object and will cease to exist after the method returns. The memory would be released back to the heap.</td></tr><tr><td style="text-align:center;"><code>self : Rc&lt;Self&gt;</code></td><td style="text-align:left;"><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/rc_self.svg" alt="Passing self by a RC pointer" loading="lazy"></td><td style="text-align:left;">Here a shared smart pointer has been passed to the method. Multiple pointers to this object may be active in the same thread. The method will share ownership to <code>self</code>. The function will decrement shared reference counts stored along with the <code>Complex</code> object. If this was the only reference to the object, the object would be destroyed, and the memory would be released to the heap. If the reference counts do not go to zero, the object will live even after the method returns.</td></tr><tr><td style="text-align:center;"><code>self : Arc&lt;Self&gt;</code></td><td style="text-align:left;"><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/arc_self.svg" alt="Passing self by a Arc pointer" loading="lazy"></td><td style="text-align:left;">Here a multi-thread safe <code>Arc</code> smart pointer is being passed to the method. The method will now own the <code>Arc</code> smart pointer. When the method goes out of scope, the shared reference counts saved along with <code>Complex</code> will be atomically decremented. If the reference counts reach 0, the object in the heap will be deleted. Note that the reference counts are now decremented using atomic read-modify-write operations.</td></tr></tbody></table><p>Now let’s examine the assembly code generated for each method shown above. To aid in the understanding a flow chart as well as annotated assembly is presented for each method.</p><hr><h2 id="self-is-passed-by-value-to-the-method" tabindex="-1"><a class="header-anchor" href="#self-is-passed-by-value-to-the-method"><span>Self is passed by value to the method</span></a></h2><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">magnitude_self_copy</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>real<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imaginary<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The assembly code generated for the above function is shown below. One interesting thing to note here is that the compiler has optimized the passing of the <code>Complex</code> object by storing the <code>real</code> and <code>imaginary</code> fields in <code>xmm0</code> and <code>xmm1</code> registers, respectively. The method computes the result, and the final return value is returned via the <code>xmm0</code> register. The following flow chart better illustrates this flow.</p><h3 id="flow-chart" tabindex="-1"><a class="header-anchor" href="#flow-chart"><span>Flow chart</span></a></h3><figure><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/self-by-value-calculate-magnitude.svg" alt="Assembly code overview for passing self by value" tabindex="0" loading="lazy"><figcaption>Assembly code overview for passing self by value</figcaption></figure><h3 id="assembly-code" tabindex="-1"><a class="header-anchor" href="#assembly-code"><span>Assembly code</span></a></h3><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line"><span class="token comment">; The compiler has optimized the code to pass the real and </span></span>
<span class="line"><span class="token comment">; imaginary parts in the xmm0 and xmm1 registers.</span></span>
<span class="line">example::Complex::magnitude_self_copy:</span>
<span class="line">        mulsd   xmm0<span class="token punctuation">,</span> xmm0  <span class="token comment">; Square the real part</span></span>
<span class="line">        mulsd   xmm1<span class="token punctuation">,</span> xmm1  <span class="token comment">; Square the imaginary part</span></span>
<span class="line">        addsd   xmm1<span class="token punctuation">,</span> xmm0  <span class="token comment">; Add the two squared numbers and store the result in xmm1</span></span>
<span class="line">        xorps   xmm0<span class="token punctuation">,</span> xmm0  <span class="token comment">; Clear xmm0. This will zero out the upper bits of the reg.</span></span>
<span class="line">        sqrtsd  xmm0<span class="token punctuation">,</span> xmm1  <span class="token comment">; Perform the square root on the squared sum and store in xmm0</span></span>
<span class="line">        ret                 <span class="token comment">; Return to the called with the result in xmm0</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="self-reference-t-is-passed-to-the-method" tabindex="-1"><a class="header-anchor" href="#self-reference-t-is-passed-to-the-method"><span>Self reference &amp;T is passed to the method</span></a></h2><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">magnitude_self_reference</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>real<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imaginary<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A reference to self (<code>&amp;self</code>) has been passed in the above function. Here the address of the <code>Complex</code> object is passed to the method via the <code>rdi</code> register. The generated code then accesses the <code>real</code> and <code>imaginary</code> parts via a vector operation. The squaring of the numbers is also performed as a vector operation in <code>xmm0</code>. The vector results are then unpacked into the <code>xmm1</code> and <code>xmm2</code> registers. The <code>xmm1</code> and <code>xmm2</code> registers are then added together and the result is stored in <code>xmm1</code>. The square root of the result is then computed and stored in <code>xmm0</code>. The final result is returned via the <code>xmm0</code> register.</p><h3 id="flow-chart-1" tabindex="-1"><a class="header-anchor" href="#flow-chart-1"><span>Flow chart</span></a></h3><figure><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/self-by-reference-calculate-magnitude.svg" alt="Assembly code overview for passing self by reference" tabindex="0" loading="lazy"><figcaption>Assembly code overview for passing self by reference</figcaption></figure><h3 id="assembly-code-1" tabindex="-1"><a class="header-anchor" href="#assembly-code-1"><span>Assembly code</span></a></h3><p>We see that the compiler has generated very different code for the <code>&amp;self</code> method compared to the <code>self</code> method. In the <code>&amp;self</code> method, the compiler has to copy the real and imaginary parts from the memory. The compiler, however, makes up for this loss of performance by using vector operations to perform the squaring and addition of the numbers.</p><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line"><span class="token comment">; The caller will pass the pointer to the Complex struct in the rdi register.</span></span>
<span class="line">example::Complex::magnitude_self_reference:</span>
<span class="line">        movupd      xmm0<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rdi<span class="token punctuation">]</span>    <span class="token comment">; Vectorized load of the real and imaginary parts</span></span>
<span class="line">        mulpd       xmm0<span class="token punctuation">,</span> xmm0                 <span class="token comment">; Square the real and imaginary parts (vectorized)</span></span>
<span class="line">        movapd      xmm1<span class="token punctuation">,</span> xmm0                 <span class="token comment">; Vectorized copy of the real and imaginary parts to xmm1</span></span>
<span class="line">        unpckhpd    xmm1<span class="token punctuation">,</span> xmm0                 <span class="token comment">; Unpack the real and imaginary parts into xmm1 and xmm0</span></span>
<span class="line">        addsd       xmm1<span class="token punctuation">,</span> xmm0                 <span class="token comment">; Add the real and imaginary parts</span></span>
<span class="line">        xorps       xmm0<span class="token punctuation">,</span> xmm0                 <span class="token comment">; Clear the complete xmm0 to 0</span></span>
<span class="line">        sqrtsd      xmm0<span class="token punctuation">,</span> xmm1                 <span class="token comment">; square root of xmm1 -&gt; xmm0</span></span>
<span class="line">        ret                                    <span class="token comment">; return xmm0</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="self-points-to-the-object-on-the-heap-via-box" tabindex="-1"><a class="header-anchor" href="#self-points-to-the-object-on-the-heap-via-box"><span>Self points to the object on the heap via Box</span></a></h2><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">magnitude_self_box</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>real<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imaginary<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A <code>Box</code> smart pointer to self is being passed here. The <code>Box</code> contains a pointer to the <code>Complex</code> object stored on the heap. The following table shows the heap representation.</p><table><thead><tr><th style="text-align:left;">Byte offset</th><th style="text-align:left;">Field</th><th style="text-align:left;">Field size in bytes</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td style="text-align:left;"><code>Complex</code> value</td><td style="text-align:left;">16</td></tr></tbody></table><p>The generated assembly code looks like the <code>&amp;self</code> case. This happens because the method owns the <code>Box</code> that points to the <code>Complex</code> on the heap. Once the method exits, the self <code>Box</code> will go out of scope. The <code>Box</code> smart pointer will then free the associated memory (The <code>Box</code> in Rust is like the <code>unique_ptr</code> in C++).</p><h3 id="flow-chart-2" tabindex="-1"><a class="header-anchor" href="#flow-chart-2"><span>Flow chart</span></a></h3><figure><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/box-self-calculate-magnitude.svg" alt="Assembly code overview for passing self as a Box smart pointer" tabindex="0" loading="lazy"><figcaption>Assembly code overview for passing self as a Box smart pointer</figcaption></figure><h3 id="assembly-code-2" tabindex="-1"><a class="header-anchor" href="#assembly-code-2"><span>Assembly code</span></a></h3><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line"><span class="token comment">; The caller stores the Complex object on the heap.</span></span>
<span class="line"><span class="token comment">; The heap address is passed in the rdi register.</span></span>
<span class="line">example::Complex::magnitude_self_box:</span>
<span class="line">        push        rax                         <span class="token comment">; Preserve the current value of rax on the stack.</span></span>
<span class="line">        movupd      xmm0<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rdi<span class="token punctuation">]</span>     <span class="token comment">; Vectorized load of the real and imaginary parts</span></span>
<span class="line">        mulpd       xmm0<span class="token punctuation">,</span> xmm0                  <span class="token comment">; Square the real and imaginary parts (vectorized)</span></span>
<span class="line">        movapd      xmm1<span class="token punctuation">,</span> xmm0                  <span class="token comment">; Vectorized copy of the real and imaginary parts to xmm1</span></span>
<span class="line">        unpckhpd    xmm1<span class="token punctuation">,</span> xmm0                  <span class="token comment">; Unpack the real and imaginary parts into xmm1 and xmm0</span></span>
<span class="line">        addsd       xmm1<span class="token punctuation">,</span> xmm0                  <span class="token comment">; Add the squared real and imaginary parts</span></span>
<span class="line">        xorps       xmm0<span class="token punctuation">,</span> xmm0                  <span class="token comment">; Clear the complete xmm0 to 0</span></span>
<span class="line">        sqrtsd      xmm0<span class="token punctuation">,</span> xmm1                  <span class="token comment">; square root of xmm1 -&gt; xmm0</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">;♻️This method owns the Box. Now that the function is about to return so </span></span>
<span class="line">        <span class="token comment">; the Box is going out of scope and is about to be dropped.</span></span>
<span class="line">        <span class="token comment">; Dropping here means that the heap memory allocated for the Complex object</span></span>
<span class="line">        <span class="token comment">; can now be freed. Note that the rdi register already points to the memory that</span></span>
<span class="line">        <span class="token comment">; needs to be freed.</span></span>
<span class="line">        movsd       qword ptr <span class="token punctuation">[</span>rsp<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm0       <span class="token comment">; Save xmm0 on the stack</span></span>
<span class="line">        mov         esi<span class="token punctuation">,</span> <span class="token number">16</span>                     <span class="token comment">; Size of the memory to be freed (Complex is 16 bytes)</span></span>
<span class="line">        mov         edx<span class="token punctuation">,</span> <span class="token number">8</span>                      <span class="token comment">; The data is 8-byte aligned.</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; The parameters to the de-allocation function are:</span></span>
<span class="line">        <span class="token comment">; rdi : Address of memory to be freed</span></span>
<span class="line">        <span class="token comment">; esi : Size of memory to be freed.</span></span>
<span class="line">        <span class="token comment">; edx: Alignment of the memory to be freed.</span></span>
<span class="line">        call        qword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> __rust_dealloc@GOTPCREL<span class="token punctuation">]</span>   <span class="token comment">; The parameters to the de-allocation function are:</span></span>
<span class="line">        movsd       xmm0<span class="token punctuation">,</span> qword ptr <span class="token punctuation">[</span>rsp<span class="token punctuation">]</span>       <span class="token comment">; Restore the xmm0 from the stack. This is the return value.</span></span>
<span class="line">        pop         rax                         <span class="token comment">; Restore the value of the rax register</span></span>
<span class="line">        ret                                     <span class="token comment">; Return the result in xmm0</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="a-reference-counted-smart-pointer-rc-to-self-is-passed" tabindex="-1"><a class="header-anchor" href="#a-reference-counted-smart-pointer-rc-to-self-is-passed"><span>A reference-counted smart pointer <code>Rc</code> to self is passed</span></a></h2><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">magnitude_self_rc</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>real<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imaginary<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The above method is designed to take ownership of <code>Rc</code>, a reference counting smart pointer. The <code>Rc</code> points to the following data on the heap:</p><table><thead><tr><th style="text-align:left;">Byte offset</th><th style="text-align:left;">Field</th><th style="text-align:left;">Field size in bytes</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td style="text-align:left;"><code>strong</code> reference count</td><td style="text-align:left;">8</td></tr><tr><td style="text-align:left;">8</td><td style="text-align:left;"><code>weak</code> reference count</td><td style="text-align:left;">8</td></tr><tr><td style="text-align:left;">16</td><td style="text-align:left;"><code>Complex</code> value</td><td style="text-align:left;">16</td></tr></tbody></table><p>When a <code>Rc</code> is created it starts with the strong reference count set to 1. If a <code>Rc</code> is cloned, it does not copy the pointed data, it just increments the reference count. This way multiple shared references may point to the same heap memory. Also, when a <code>Rc</code> is dropped, the reference count is decremented. If the reference count falls to 0, the memory block on the heap is de-allocated.</p><p>The generated assembly code looks like the <code>&amp;self</code> case. The major differences are due to <code>Rc</code> reference count decrement handling. Notice that the offsets for the access of the <code>real</code> and <code>imaginary</code> parts are 16 and 24, respectively. This is due to the two 64-bit reference counts that are present before the <code>Complex</code> object.</p><p>Once the <code>real</code> and <code>imaginary</code> parts have been saved in <code>xmm1</code>, the reference counts are decremented in preparation of the method going out of scope. If the reference count hits zero, the object pointed from the <code>Rc</code> will be deleted. If not, the memory block containing the reference counts and <code>Complex</code> objects live as there are other Rc smart pointers pointing to the same memory block.</p><div class="hint-container tip"><p class="hint-container-title">Note</p><p>We have ignored the weak reference in this discussion.</p></div><h3 id="flow-chart-3" tabindex="-1"><a class="header-anchor" href="#flow-chart-3"><span>Flow chart</span></a></h3><figure><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/rc-self-calculate-magnitude.svg" alt="Assembly code overview for passing self as an Rc smart pointer" tabindex="0" loading="lazy"><figcaption>Assembly code overview for passing self as an Rc smart pointer</figcaption></figure><h3 id="assembly-code-3" tabindex="-1"><a class="header-anchor" href="#assembly-code-3"><span>Assembly code</span></a></h3><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line"><span class="token comment">; The caller passes a heap address in the rdi register that points to:</span></span>
<span class="line"><span class="token comment">; Offset 00: Strong reference count</span></span>
<span class="line"><span class="token comment">; Offset 08: Weak reference count</span></span>
<span class="line"><span class="token comment">; Offset 16: Complex object</span></span>
<span class="line"></span>
<span class="line">example::Complex::magnitude_self_rc:</span>
<span class="line">        sub     rsp<span class="token punctuation">,</span> <span class="token number">24</span>                         <span class="token comment">; Create a 24-byte space for local variables</span></span>
<span class="line">        movupd  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rdi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span>    <span class="token comment">; Vector fetch the real and imaginary parts of the struct from memory</span></span>
<span class="line">        dec     qword ptr <span class="token punctuation">[</span>rdi<span class="token punctuation">]</span>                 <span class="token comment">; Decrement the strong reference</span></span>
<span class="line">        jne     .LBB4_3                         <span class="token comment">; If not zero, proceed with the calculation.</span></span>
<span class="line">        dec     qword ptr <span class="token punctuation">[</span>rdi <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">]</span>             <span class="token comment">; Decrement the weak reference</span></span>
<span class="line">        jne     .LBB4_3                         <span class="token comment">; If not zero, proceed with the calculation. </span></span>
<span class="line">        mov     esi<span class="token punctuation">,</span> <span class="token number">32</span>                         <span class="token comment">; Size of the memory to be freed (Complex is 16 bytes)</span></span>
<span class="line">                                                <span class="token comment">; plus two 8-byte reference counters.</span></span>
<span class="line">        mov     edx<span class="token punctuation">,</span> <span class="token number">8</span>                          <span class="token comment">; The data is 8-byte aligned.</span></span>
<span class="line">        movapd  xmmword ptr <span class="token punctuation">[</span>rsp<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1         <span class="token comment">; Vector save xmm1 on the stack (real and imaginary parts)</span></span>
<span class="line">        call    qword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> __rust_dealloc@GOTPCREL<span class="token punctuation">]</span> <span class="token comment">; De-allocate the memory</span></span>
<span class="line">        movapd  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rsp<span class="token punctuation">]</span>         <span class="token comment">; Vector restore xmm1 from the stack (real and imaginary parts)</span></span>
<span class="line">.LBB4_3:</span>
<span class="line">        mulpd       xmm1<span class="token punctuation">,</span> xmm1                  <span class="token comment">; Vector square the real and imaginary parts</span></span>
<span class="line">        movapd      xmm0<span class="token punctuation">,</span> xmm1                  <span class="token comment">; Copy the result to xmm0</span></span>
<span class="line">        unpckhpd    xmm0<span class="token punctuation">,</span> xmm1                  <span class="token comment">; Unpack the real and imaginary parts into xmm1 and xmm0</span></span>
<span class="line">        addsd       xmm0<span class="token punctuation">,</span> xmm1                  <span class="token comment">; Add the squared real and imaginary parts</span></span>
<span class="line">        sqrtsd      xmm0<span class="token punctuation">,</span> xmm0                  <span class="token comment">; Square root of xmm0 -&gt; xmm0</span></span>
<span class="line">        add         rsp<span class="token punctuation">,</span> <span class="token number">24</span>                     <span class="token comment">; Free the space saved for local storage</span></span>
<span class="line">        ret                                     <span class="token comment">; Return the result in xmm0</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="an-atomic-reference-counted-shared-reference-arc-to-self-is-passed" tabindex="-1"><a class="header-anchor" href="#an-atomic-reference-counted-shared-reference-arc-to-self-is-passed"><span>An atomic reference counted shared reference Arc to self is passed</span></a></h2><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">magnitude_self_arc</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Arc</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>real<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>imaginary<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Arc</code> is a smart pointer that operates across threads. This requires that reference count increments and decrements are atomic. An atomic read-modify-write operation is performed to manage reference counts across threads.</p><p>The <code>Arc</code> smart pointer points to a heap allocation that contains <code>AtomicUsize</code> strong and weak references. The <code>Complex</code> object is stored after the two references (see the following table for the memory representation).</p><table><thead><tr><th style="text-align:left;">Byte offset</th><th style="text-align:left;">Field</th><th style="text-align:left;">Field size in bytes</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td style="text-align:left;"><code>AtomicUsize</code> strong reference count</td><td style="text-align:left;">8</td></tr><tr><td style="text-align:left;">8</td><td style="text-align:left;"><code>AtomicUsize</code> weak reference count</td><td style="text-align:left;">8</td></tr><tr><td style="text-align:left;">16</td><td style="text-align:left;"><code>Complex</code> value</td><td style="text-align:left;">16</td></tr></tbody></table><p>The code generated for <code>Arc</code> is similar to the code generated for <code>Rc</code>. The significant differences from the <code>Rc</code> assembly code are:</p><ul><li><code>lock sub qword ptr [rdi]</code>, 1 is generated for handling the atomic decrement of the reference count.</li><li>The drop check and weak reference count decrement are handled in <code>alloc::sync::Arc&lt;T&gt;::drop_slow</code> function.</li></ul><h3 id="flow-chart-4" tabindex="-1"><a class="header-anchor" href="#flow-chart-4"><span>Flow chart</span></a></h3><figure><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/arc-self-calculate-magnitude.svg" alt="Assembly code overview for passing self as an Arc smart pointer" tabindex="0" loading="lazy"><figcaption>Assembly code overview for passing self as an Arc smart pointer</figcaption></figure><h4 id="drop-slow-utility-function" tabindex="-1"><a class="header-anchor" href="#drop-slow-utility-function"><span>Drop slow utility function</span></a></h4><figure><img src="https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/arc-self-drop-slow.svg" alt="Assembly code for the drop slow function" tabindex="0" loading="lazy"><figcaption>Assembly code for the drop slow function</figcaption></figure><h3 id="assembly-code-4" tabindex="-1"><a class="header-anchor" href="#assembly-code-4"><span>Assembly code</span></a></h3><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line"><span class="token comment">; The caller passes a heap address in the rdi register that points to:</span></span>
<span class="line"><span class="token comment">; Offset 00: Strong reference </span></span>
<span class="line"><span class="token comment">; Offset 08: Weak reference</span></span>
<span class="line"><span class="token comment">; Offset 16: Complex object</span></span>
<span class="line">example::Complex::magnitude_self_arc:</span>
<span class="line">        sub     rsp<span class="token punctuation">,</span> <span class="token number">24</span>                         <span class="token comment">; Create 24-byte space for local variables</span></span>
<span class="line">        movupd  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rdi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span>    <span class="token comment">; Fetch the real and imaginary parts of the struct from memory</span></span>
<span class="line">        lock    dec     qword ptr <span class="token punctuation">[</span>rdi<span class="token punctuation">]</span>         <span class="token comment">; Lock and perform an atomic decrement of the strong reference</span></span>
<span class="line">        jne     .LBB5_2                         <span class="token comment">; If not zero, skip ahead to the computation.</span></span>
<span class="line">        movapd  xmmword ptr <span class="token punctuation">[</span>rsp<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1         <span class="token comment">; Save real and imaginary parts on the stack</span></span>
<span class="line">        call    alloc::sync::Arc<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>::drop_slow  <span class="token comment">; Call the drop_slow function to for further delete processing.</span></span>
<span class="line">        movapd  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rsp<span class="token punctuation">]</span>         <span class="token comment">; Now restore the real and imaginary parts from the stack.</span></span>
<span class="line">.LBB5_2:</span>
<span class="line">        mulpd       xmm1<span class="token punctuation">,</span> xmm1                  <span class="token comment">; square real and imaginary parts</span></span>
<span class="line">        movapd      xmm0<span class="token punctuation">,</span> xmm1                  <span class="token comment">; Copy the result to xmm0</span></span>
<span class="line">        unpckhpd    xmm0<span class="token punctuation">,</span> xmm1                  <span class="token comment">; Unpack the high parts of xmm1 into xmm0</span></span>
<span class="line">        addsd       xmm0<span class="token punctuation">,</span> xmm1                  <span class="token comment">; Add the squared numbers and save them to xmm0</span></span>
<span class="line">        sqrtsd      xmm0<span class="token punctuation">,</span> xmm0                  <span class="token comment">; Square root of xmm0 -&gt; xmm0</span></span>
<span class="line">        add         rsp<span class="token punctuation">,</span> <span class="token number">24</span>                     <span class="token comment">; Free the space saved for local storage</span></span>
<span class="line">        ret                                     <span class="token comment">; Return the result in xmm0</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">; This function frees memory if the atomic reference counts have reached 0.</span></span>
<span class="line"><span class="token comment">; The function is invoked with rdi pointing to the address where the address of the complete Arc is stored.</span></span>
<span class="line">alloc::sync::Arc<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>::drop_slow:</span>
<span class="line">        cmp     rdi<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span>         <span class="token comment">; Check if Arc block address is set to -1</span></span>
<span class="line">        je      .LBB0_2         <span class="token comment">; If it is skip ahead and return.</span></span>
<span class="line">        lock    dec  qword ptr <span class="token punctuation">[</span>rdi <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token comment">; Perform an atomic decrement of the weak reference.</span></span>
<span class="line">        jne     .LBB0_2         <span class="token comment">; If the weak reference is 0, proceed to free the Arc block</span></span>
<span class="line">        mov     esi<span class="token punctuation">,</span> <span class="token number">32</span>         <span class="token comment">; Arc block size is 32: 8-strong, 8-weak, 16-Complex</span></span>
<span class="line">        mov     edx<span class="token punctuation">,</span> <span class="token number">8</span>          <span class="token comment">; Alignment is 8 bytes</span></span>
<span class="line">        jmp     qword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> __rust_dealloc@GOTPCREL<span class="token punctuation">]</span>   <span class="token comment">; Free memory</span></span>
<span class="line">.LBB0_2:</span>
<span class="line">        ret</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="key-takeaways" tabindex="-1"><a class="header-anchor" href="#key-takeaways"><span>Key takeaways</span></a></h2><h3 id="for-small-types-copying-the-object-might-be-more-efficient-than-passing-a-reference" tabindex="-1"><a class="header-anchor" href="#for-small-types-copying-the-object-might-be-more-efficient-than-passing-a-reference"><span>For small types copying the object might be more efficient than passing a reference</span></a></h3><p>In our analysis, the most efficient code with the least memory overhead was generated for the <code>Complex::magnitude_self_copy</code> method. From small types, passing by value might be more efficient than passing a reference.</p><h3 id="passing-a-t-is-efficient" tabindex="-1"><a class="header-anchor" href="#passing-a-t-is-efficient"><span>Passing a &amp;T is efficient</span></a></h3><p>In most scenarios, passing a reference will be more efficient than passing by value as the compiler will not need to copy the entire contents to the called function.</p><h3 id="passing-a-box-will-result-in-object-de-allocation" tabindex="-1"><a class="header-anchor" href="#passing-a-box-will-result-in-object-de-allocation"><span>Passing a Box will result in object de-allocation</span></a></h3><p>Passing a <code>Box&lt;T&gt;</code> will result in the object being de-allocated. If this is not the desired behavior, then pass a <code>&amp;T</code> or <code>&amp;mut T</code> instead.</p><h3 id="prefer-passing-a-t-over-rc-and-arc-when-the-function-just-wishes-to-read-from-t" tabindex="-1"><a class="header-anchor" href="#prefer-passing-a-t-over-rc-and-arc-when-the-function-just-wishes-to-read-from-t"><span>Prefer passing a &amp;T over Rc and Arc when the function just wishes to read from T</span></a></h3><p>From the generated code we see that passing an owned <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code> introduce significant overhead. Prefer passing a reference <code>&amp;T</code> in scenarios where no sharing changes are expected.</p><p>The <a href="https://www.reddit.com/r/rust/comments/lfxy6b/pass_arct_by_clone_or_by_reference" target="_blank" rel="noopener noreferrer">Reddit discussion</a> on the subject defines the following rules for <code>Arc&lt;T&gt;</code>:</p><ul><li>If a function always needs to own its own copy of the <code>Arc</code>, pass <code>Arc&lt;T&gt;</code> directly by value. The caller can decide whether to clone or move an existing <code>Arc</code> into it.</li><li>If the function just very rarely needs to make a copy of the <code>Arc</code>, <code>&amp;Arc&lt;T&gt;</code> can make sense so that you are not forced to do atomic operations in the common case, at the cost of not being able to just move the arc in the uncommon case.</li><li>If the function just wants to read from the <code>T</code>, just pass <code>&amp;T</code>.</li></ul><h3 id="consider-the-memory-overhead-of-rc-and-arc" tabindex="-1"><a class="header-anchor" href="#consider-the-memory-overhead-of-rc-and-arc"><span>Consider the memory overhead of <code>Rc</code> and <code>Arc</code></span></a></h3><p>On a 64-bit machine, <code>Rc</code> and <code>Arc</code> add a 16 byte overhead on the heap.</p><hr><h2 id="view-in-the-compiler-explorer" tabindex="-1"><a class="header-anchor" href="#view-in-the-compiler-explorer"><span>View in the Compiler Explorer</span></a></h2><p>See the direct mapping from the Rust code to the assembly for <a href="https://godbolt.org/z/b344MYPc6" target="_blank" rel="noopener noreferrer">all the methods we have covered in this article.</a></p><hr>`,80);function x(l,w){const n=o("router-link"),c=o("VPCard");return h(),i("div",null,[e("h1",k,[e("a",b,[e("span",null,r(l.$frontmatter.title)+" 관련",1)])]),e("nav",v,[e("ul",null,[e("li",null,[s(n,{to:"#self-is-passed-by-value-to-the-method"},{default:a(()=>[t("Self is passed by value to the method")]),_:1}),e("ul",null,[e("li",null,[s(n,{to:"#flow-chart"},{default:a(()=>[t("Flow chart")]),_:1})]),e("li",null,[s(n,{to:"#assembly-code"},{default:a(()=>[t("Assembly code")]),_:1})])])]),e("li",null,[s(n,{to:"#self-reference-t-is-passed-to-the-method"},{default:a(()=>[t("Self reference &T is passed to the method")]),_:1}),e("ul",null,[e("li",null,[s(n,{to:"#flow-chart-1"},{default:a(()=>[t("Flow chart")]),_:1})]),e("li",null,[s(n,{to:"#assembly-code-1"},{default:a(()=>[t("Assembly code")]),_:1})])])]),e("li",null,[s(n,{to:"#self-points-to-the-object-on-the-heap-via-box"},{default:a(()=>[t("Self points to the object on the heap via Box")]),_:1}),e("ul",null,[e("li",null,[s(n,{to:"#flow-chart-2"},{default:a(()=>[t("Flow chart")]),_:1})]),e("li",null,[s(n,{to:"#assembly-code-2"},{default:a(()=>[t("Assembly code")]),_:1})])])]),e("li",null,[s(n,{to:"#a-reference-counted-smart-pointer-rc-to-self-is-passed"},{default:a(()=>[t("A reference-counted smart pointer Rc to self is passed")]),_:1}),e("ul",null,[e("li",null,[s(n,{to:"#flow-chart-3"},{default:a(()=>[t("Flow chart")]),_:1})]),e("li",null,[s(n,{to:"#assembly-code-3"},{default:a(()=>[t("Assembly code")]),_:1})])])]),e("li",null,[s(n,{to:"#an-atomic-reference-counted-shared-reference-arc-to-self-is-passed"},{default:a(()=>[t("An atomic reference counted shared reference Arc to self is passed")]),_:1}),e("ul",null,[e("li",null,[s(n,{to:"#flow-chart-4"},{default:a(()=>[t("Flow chart")]),_:1})]),e("li",null,[s(n,{to:"#assembly-code-4"},{default:a(()=>[t("Assembly code")]),_:1})])])]),e("li",null,[s(n,{to:"#key-takeaways"},{default:a(()=>[t("Key takeaways")]),_:1}),e("ul",null,[e("li",null,[s(n,{to:"#for-small-types-copying-the-object-might-be-more-efficient-than-passing-a-reference"},{default:a(()=>[t("For small types copying the object might be more efficient than passing a reference")]),_:1})]),e("li",null,[s(n,{to:"#passing-a-t-is-efficient"},{default:a(()=>[t("Passing a &T is efficient")]),_:1})]),e("li",null,[s(n,{to:"#passing-a-box-will-result-in-object-de-allocation"},{default:a(()=>[t("Passing a Box will result in object de-allocation")]),_:1})]),e("li",null,[s(n,{to:"#prefer-passing-a-t-over-rc-and-arc-when-the-function-just-wishes-to-read-from-t"},{default:a(()=>[t("Prefer passing a &T over Rc and Arc when the function just wishes to read from T")]),_:1})]),e("li",null,[s(n,{to:"#consider-the-memory-overhead-of-rc-and-arc"},{default:a(()=>[t("Consider the memory overhead of Rc and Arc")]),_:1})])])]),e("li",null,[s(n,{to:"#view-in-the-compiler-explorer"},{default:a(()=>[t("View in the Compiler Explorer")]),_:1})])])]),g,s(c,d(u({title:"Assembly code generated when self is passed by value, reference or as a smart pointer",desc:"Learn how enums are organized in memory. Also understand the generated assembly code for match on an enum.",link:"https://eventhelix.com/rust/rust-to-assembly-enum-match",logo:"https://eventhelix.com/images/EventHelix-white-rounded-bg-blue.png",background:"rgba(250,250,250,0.2)"})),null,16),y])}const T=p(f,[["render",x],["__file","assembly-code-generated-when-self-is-passed-by-value-reference-or-as-a-smart-pointer.html.vue"]]),j=JSON.parse('{"path":"/rust/eventhelix-rust-to-assembly/assembly-code-generated-when-self-is-passed-by-value-reference-or-as-a-smart-pointer.html","title":"Assembly code generated when self is passed by value, reference or as a smart pointer","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Assembly code generated when self is passed by value, reference or as a smart pointer","description":"Rust to Assembly > Assembly code generated when self is passed by value, reference or as a smart pointer","category":["Rust"],"tag":["crashcourse","digitalocean","rust","rs","wasm","assembly"],"head":[[{"meta":null},{"property":"og:title","content":"Assembly code generated when self is passed by value, reference or as a smart pointer"},{"property":"og:description","content":"Rust to Assembly > Assembly code generated when self is passed by value, reference or as a smart pointer"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/rust/eventhelix-rust-to-assembly/assembly-code-generated-when-self-is-passed-by-value-reference-or-as-a-smart-pointer.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/rust/eventhelix-rust-to-assembly/assembly-code-generated-when-self-is-passed-by-value-reference-or-as-a-smart-pointer.html"}],["meta",{"property":"og:site_name","content":"🥁Crashcourse"}],["meta",{"property":"og:title","content":"Assembly code generated when self is passed by value, reference or as a smart pointer"}],["meta",{"property":"og:description","content":"Rust to Assembly > Assembly code generated when self is passed by value, reference or as a smart pointer"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/self.svg"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"digitalocean"}],["meta",{"property":"article:tag","content":"rust"}],["meta",{"property":"article:tag","content":"rs"}],["meta",{"property":"article:tag","content":"wasm"}],["meta",{"property":"article:tag","content":"assembly"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Assembly code generated when self is passed by value, reference or as a smart pointer\\",\\"image\\":[\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/self.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/ref_self.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/box_self.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/rc_self.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/arc_self.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/self-by-value-calculate-magnitude.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/self-by-reference-calculate-magnitude.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/box-self-calculate-magnitude.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/rc-self-calculate-magnitude.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/arc-self-calculate-magnitude.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-value-reference-box-rc-arc/arc-self-drop-slow.svg\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Self is passed by value to the method","slug":"self-is-passed-by-value-to-the-method","link":"#self-is-passed-by-value-to-the-method","children":[{"level":3,"title":"Flow chart","slug":"flow-chart","link":"#flow-chart","children":[]},{"level":3,"title":"Assembly code","slug":"assembly-code","link":"#assembly-code","children":[]}]},{"level":2,"title":"Self reference &T is passed to the method","slug":"self-reference-t-is-passed-to-the-method","link":"#self-reference-t-is-passed-to-the-method","children":[{"level":3,"title":"Flow chart","slug":"flow-chart-1","link":"#flow-chart-1","children":[]},{"level":3,"title":"Assembly code","slug":"assembly-code-1","link":"#assembly-code-1","children":[]}]},{"level":2,"title":"Self points to the object on the heap via Box","slug":"self-points-to-the-object-on-the-heap-via-box","link":"#self-points-to-the-object-on-the-heap-via-box","children":[{"level":3,"title":"Flow chart","slug":"flow-chart-2","link":"#flow-chart-2","children":[]},{"level":3,"title":"Assembly code","slug":"assembly-code-2","link":"#assembly-code-2","children":[]}]},{"level":2,"title":"A reference-counted smart pointer Rc to self is passed","slug":"a-reference-counted-smart-pointer-rc-to-self-is-passed","link":"#a-reference-counted-smart-pointer-rc-to-self-is-passed","children":[{"level":3,"title":"Flow chart","slug":"flow-chart-3","link":"#flow-chart-3","children":[]},{"level":3,"title":"Assembly code","slug":"assembly-code-3","link":"#assembly-code-3","children":[]}]},{"level":2,"title":"An atomic reference counted shared reference Arc to self is passed","slug":"an-atomic-reference-counted-shared-reference-arc-to-self-is-passed","link":"#an-atomic-reference-counted-shared-reference-arc-to-self-is-passed","children":[{"level":3,"title":"Flow chart","slug":"flow-chart-4","link":"#flow-chart-4","children":[]},{"level":3,"title":"Assembly code","slug":"assembly-code-4","link":"#assembly-code-4","children":[]}]},{"level":2,"title":"Key takeaways","slug":"key-takeaways","link":"#key-takeaways","children":[{"level":3,"title":"For small types copying the object might be more efficient  than passing a reference","slug":"for-small-types-copying-the-object-might-be-more-efficient-than-passing-a-reference","link":"#for-small-types-copying-the-object-might-be-more-efficient-than-passing-a-reference","children":[]},{"level":3,"title":"Passing a &T is efficient","slug":"passing-a-t-is-efficient","link":"#passing-a-t-is-efficient","children":[]},{"level":3,"title":"Passing a Box will result in object de-allocation","slug":"passing-a-box-will-result-in-object-de-allocation","link":"#passing-a-box-will-result-in-object-de-allocation","children":[]},{"level":3,"title":"Prefer passing a &T over Rc and Arc when the function just  wishes to read from T","slug":"prefer-passing-a-t-over-rc-and-arc-when-the-function-just-wishes-to-read-from-t","link":"#prefer-passing-a-t-over-rc-and-arc-when-the-function-just-wishes-to-read-from-t","children":[]},{"level":3,"title":"Consider the memory overhead of Rc and Arc","slug":"consider-the-memory-overhead-of-rc-and-arc","link":"#consider-the-memory-overhead-of-rc-and-arc","children":[]}]},{"level":2,"title":"View in the Compiler Explorer","slug":"view-in-the-compiler-explorer","link":"#view-in-the-compiler-explorer","children":[]}],"git":{"createdTime":1703642364000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":7}]},"readingTime":{"minutes":10.27,"words":3082},"filePathRelative":"rust/eventhelix-rust-to-assembly/assembly-code-generated-when-self-is-passed-by-value-reference-or-as-a-smart-pointer.md","localizedDate":"2023년 12월 27일","excerpt":"\\n\\n<hr>\\n"}');export{T as comp,j as data};
