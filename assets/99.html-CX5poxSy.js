import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,a as e,t as u,b as t,w as o,n as s,g as i,e as r,r as c,o as m,d as l}from"./app-U_bew1in.js";const g={},w={id:"frontmatter-title-관련",tabindex:"-1"},y={class:"header-anchor",href:"#frontmatter-title-관련"},f={class:"table-of-contents"},k=e("hr",null,null,-1),b=r('<h2 id="milestone-projects-28-30" tabindex="-1"><a class="header-anchor" href="#milestone-projects-28-30"><span>Milestone: Projects 28-30</span></a></h2><p>Today is the last consolidation day of this 100 Days challenge, and we’ll be looking over what you’ve learned before diving straight into your toughest challenge yet.</p><p>I know the thought of a tough challenge might not be welcome at this point, because you’re almost certainly tired. But as the Greek philosopher Epictetus once said, “the greater the difficulty the more glory in surmounting it” – this is a biggie, but you’ll feel <em>great</em> when you’re done because you’ll have had to exercise so many of the skills you’ve learned over these past few months.</p><p>Although biometric authentication is an interesting topic – and certainly an important one if you happen to be on a team building apps for a bank! – the real highlights of these last days have been more Core Graphics practice and dipping a toe in Instruments. Both of these are skills that will last you years. Sure, you might not remember the exact code required to make clipping masks in Core Graphics, or the precise button to press in Instruments to find the problem you’re hunting for, but you know <em>where</em> to look, and, more importantly, you know <em>what</em> you’re looking for.</p><p>As you might have learned yourself, when you’re facing a problem half the battle is figuring out what you’re looking for – what words to use, or even vaguely what kind of UIKit class might contain your answer. Since this course started you’ve gained so much experience across so many of Apple’s frameworks, but you will already have forgotten half of it.</p><p>And you know what? That’s OK. In fact, that’s <em>normal</em>. What you <em>haven’t</em> lost is all the code you wrote, which you can use as a reference for all your projects going forward. You also haven’t lost the <em>concepts</em> – you’re used to the idea of a table view delegate now, just like you’re used to storyboards, or view controllers, or <code>Codable</code>, and more. Those are the things that last, and, helpfully, those are the things that <em>matter</em>.</p><p><strong>Today you have three topics to work through, one of which of is your challenge.</strong></p><h3 id="what-you-learned" tabindex="-1"><a class="header-anchor" href="#what-you-learned"><span>What you learned</span></a></h3>',8),v={class:"hint-container details"},I=e("summary",null,"What you learned",-1),_=r("<p>Project 29 was a serious game with a lot going on, not least the dynamically rendered buildings with destructible terrain, the scene transitions and the UIKit/SpriteKit integration.</p><p>And in project 30 we took our first steps outside of Xcode and into Instruments. I could write a whole book on Instruments, partly because it’s extremely powerful, but also because it’s extremely complicated. As per usual, I tried to cherrypick things so you can see useful, practical benefits from what I was teaching, and certainly you have the skills now to be able to diagnose and result a variety of performance problems on iOS.</p><p>Here are some of the things you learned in this milestone:</p><ul><li>How to access the keychain using SwiftKeychainWrapper.</li><li>How to force the keyboard to disappear by calling <code>resignFirstResponder()</code> on a text view. (And remember: it also works on text fields.)</li><li>How to detect when your app is moving to the background by registering for the <code>UIApplication.willResignActiveNotification</code> notification.</li><li>How to use <code>LAContext</code> from the LocalAuthentication framework to require Touch ID authentication.</li><li>Using the <code>stride()</code> function to loop across a range of numbers using a specific increment, e.g. from 0 to 100 in tens.</li><li>Creating colors using the hue, saturation, and brightness. As I said, keeping the saturation and brightness constant while choosing different hues helps you create similar color palettes easily.</li><li>SpriteKit texture atlases. These are automatically made by Xcode if you place images into a folder with the .atlas extension, and are drawn significantly quicker than regular graphics.</li><li>Using <code>usesPreciseCollisionDetection</code> to make collisions work better with small, fast-moving physics bodies.</li><li>Transitioning between scenes with the <code>presentScene()</code> method and passing in a transition effect. We’ll be using this again in project 36, so you’ll have ample time to practice transitions.</li><li>Using the blend mode <code>.clear</code> to erase parts of an image. Once that was done, we just recalculated the pixel-perfect physics to get destructible terrain.</li><li>Adding dynamic shadows to views using <code>layer.shadowRadius</code> and other properties – and particularly how to use the <code>layer.shadowPath</code> property to save shadow calculation.</li><li>The importance of using <code>dequeueReusableCell(withIdentifier:)</code> so that iOS can re-use cells rather than continually creating new ones.</li><li>How the <code>UIImage(named:)</code> initializer has an automatic cache to help load common images. When you don’t need that, use the <code>UIImage(contentsOfFile:)</code> initializer instead.</li></ul>",4),x=e("h3",{id:"key-points",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#key-points"},[e("span",null,"Key points")])],-1),S={class:"hint-container details"},T=e("summary",null,"Key points",-1),j=r(`<p>There are two things I’d like to review for this milestone.</p><p>First, the weak keyword. We used it in project 29 to add a property to our game scene:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">weak</span> <span class="token keyword">var</span> viewController<span class="token punctuation">:</span> <span class="token class-name">GameViewController</span><span class="token operator">!</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>We also added the opposite property to the game view controller:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">var</span> currentGame<span class="token punctuation">:</span> <span class="token class-name">GameScene</span><span class="token operator">!</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>This approach allowed the game scene to call methods on the view controller, and vice versa. At the time I explained why one was <code>weak</code> and the other was not – do you remember? I hope so, because it’s important!</p><p>There are four possibilities:</p><ol><li>Game scene holds strong view controller and view controller holds strong game scene.</li><li>Game scene holds strong view controller and view controller holds weak game scene.</li><li>Game scene holds weak view controller and view controller holds weak game scene.</li><li>Game scene holds weak view controller and view controller holds strong game scene.</li></ol><p>Remember, “strong” means “I want to own this; don’t let this memory be destroyed until I’m done with it,” and weak means “I want to use this but I don’t want to own it; I’m OK if it gets destroyed, so don’t keep it around on my account.”</p><p>Now, the view controller has an <code>SKView</code>, which is what renders SpriteKit content. That’s owned strongly, because obviously the view controller can’t really work without something to draw to. And that <code>SKView</code> has a <code>scene</code> property, which is the current <code>SKScene</code> visible on the screen. That’s <em>also</em> strongly owned. As a result, the view controller already - albeit indirectly – has strong ownership of the game scene.</p><p>As a result, both options 1 and 2 will cause a strong reference cycle, because they would cause the game scene to have a strong reference to something that has a strong reference back to the game scene. This isn’t necessarily <em>bad</em> as long as you remember to break the strong reference cycle, but let’s face it: why take the risk?</p><p>That leaves options 3 and 4: both have the game scene using a <code>weak</code> reference to the view controller, but one has a weak reference going back the other way and the other has a strong one. Which is better? Honestly, I’m not sure it matters: using a strong reference wouldn’t result in anything new because there’s already the indirect strong reference in place. So, use whichever you prefer!</p><p>The second thing I’d like to cover is much easier: it’s the <code>UIImage(contentsOfFile:)</code> initializer for <code>UIImage</code>. Like I said in project 30, the <code>UIImage(named:)</code> initializer has a built-in cache system to help load and store commonly used images – anything you load with that initializer will automatically be cached, and so load instantly if you request it again.</p><p>Of course, if you <em>don’t</em> want something to be cached, that’s the wrong solution, which is where <code>UIImage(contentsOfFile:)</code> comes in: give it a path and it will load the image, with no magic caching ever happening.</p><p>The downside is that <code>UIImage(named:)</code> automatically finds images inside your app bundle, whereas <code>UIImage(contentsOfFile:)</code> does not. So, you need to write code like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> path <span class="token operator">=</span> <span class="token class-name">Bundle</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span>forResource<span class="token punctuation">:</span> someImage<span class="token punctuation">,</span> ofType<span class="token punctuation">:</span> <span class="token nil constant">nil</span><span class="token punctuation">)</span><span class="token operator">!</span></span>
<span class="line">imageView<span class="token punctuation">.</span>image <span class="token operator">=</span> <span class="token class-name">UIImage</span><span class="token punctuation">(</span>contentsOfFile<span class="token punctuation">:</span> path<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>That’s hardly a lot of code, but it’s never nice writing even simple repetitive code – and look at that force unwrap after <code>path()</code>! Wouldn’t it be great to get rid of it? I’m going to show you how to do just that, and, as a bonus, I’m also going to teach you something new: convenience initializers.</p><p>You’ve already seen initializers – we’ve used dozens of them. They are special methods that create things, like <code>UILabel()</code> or <code>UIImage(named:)</code>. Swift has complex rules about its initializers, all designed to stop you trying to access something that hasn’t been created yet.</p><p>Fortunately, there’s one <em>easy</em> part, which is convenience initializers, which are effectively wrappers around basic initializers that are designed to make coding a bit more pleasant. A convenience initializer is able to do some work before calling a regular initializer, which in our case means we can add a wrapper around <code>UIImage(contentsOfFile:)</code> so that it’s nicer to call.</p><p>To make things even better, we’re also going to get rid of the force unwrap. Remember, <code>path(forResource:)</code> can return nil because the file you requested might not exist. Force unwrapping it works on occasion if you know something definitely exists, but it’s usually a better idea to use an alternative such as failable initializers.</p><p>You’ve already used failable initializers several times – both <code>UIImage(named:)</code> and <code>UIImage(contentsOfFile:)</code> are failable, for example. A failable initializer is one that might return a valid created object, or it might fail and return nil. We’re going to use this so that we can return <code>nil</code> if the image name can’t be found in the app bundle.</p><p>So, leveraging the power of Swift extensions that you learned in project 24, here’s a <code>UIImage</code> extension that creates a new, failable, convenience initializer called <code>UIImage(uncached:)</code>. It works like <code>UIImage(named:)</code> in that you don’t need to provide the full bundle path, but it <em>doesn’t</em> have the downside of caching images you don’t intend to use more than once.</p><p>Here’s the code:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">UIImage</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">convenience</span> <span class="token keyword">init</span><span class="token operator">?</span><span class="token punctuation">(</span>uncached name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token keyword">let</span> path <span class="token operator">=</span> <span class="token class-name">Bundle</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span>forResource<span class="token punctuation">:</span> name<span class="token punctuation">,</span> ofType<span class="token punctuation">:</span> <span class="token nil constant">nil</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>contentsOfFile<span class="token punctuation">:</span> path<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token nil constant">nil</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Note the <code>init?</code> syntax that marks this as an initializer that returns an optional.</p>`,25),U=e("h3",{id:"challenge",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#challenge"},[e("span",null,"Challenge")])],-1),D={class:"hint-container details"},C=e("summary",null,"Challenge",-1),A=r('<p>Your challenge is to create a memory pairs game that has players find pairs of cards – it’s sometimes called Concentration, Pelmanism, or Pairs. At the very least you should:</p><p>Come up with a list of pairs. Traditionally this is two pictures, but you could also use capital cities (e.g. one card says France and its match says Paris), languages (e.g one card says “hello” and the other says “bonjour”), and so on. Show a grid of face-down cards. How many is down to you, but if you’re targeting iPad I would have thought 4x4 or more. Let the player select any two cards, and show them face up as they are tapped. If they match remove them; if they don’t match, wait a second then turn them face down again. Show a You Win message once all are matched. You can use either SpriteKit or UIKit depending on which skill you want to practice the most, but I think you’ll find UIKit much easier.</p><p>Don’t under-estimate this challenge! To make it work you’re going to need to draw on a wide variety of skills, and it <em>will</em> push you. That’s the point, though, so take your time and give yourself space to think.</p><p>If you’re looking for a more advanced challenge, go for a variant of the game that uses word pairs and add a parental option that lets them create new cards. This would mean:</p><ul><li>Authenticating users using Touch ID or Face ID.</li><li>Showing a new view controller that lists all existing cards and lets them enter a new card.</li><li>You can use a <code>UIAlertController</code> with one or two text fields for your card entry, depending on what kind of game you’ve made.</li></ul><p>Please go ahead and try to solve the challenge now. My hints are below, but please try to avoid reading them unless you’re really struggling.</p><ul><li>Start small. Seriously! Find something really simple that works, and only try something bigger or better once your simplest possible solution actually works.</li><li>If you’re using UIKit, you could try to solve this using a <code>UICollectionView</code>. This gives you a natural grid, as well as touch handling for selecting cells, but make sure you think carefully about cells being re-used – this might prove more difficult than you thought.</li><li>An easier approach is to lay out your cards much like we did with the word letters in project 8, 7 Swifty Words. You could show your card backs as a button image, then when the button is tapped show the other side of the card – which might be as simple as changing the picture and making the button’s text label have a non-clear color, or perhaps using Core Graphics to render the text directly onto the card front image.</li><li>If you made the buttons work and want to try something fancier, you can actually create a flip animation to toggle between views – see my article <a href="https://www.hackingwithswift.com/example-code/uikit/how-to-flip-a-uiview-with-a-3d-effect-transitionwith" target="_blank" rel="noopener noreferrer">How to flip a UIView with a 3D effect: <code>transition(with:)</code></a> for more information.</li><li>In terms of tracking the game state it really only has three states: player has chosen zero cards, player has chosen one card (flip it over), and player has chosen two cards (flip the second one over). When they’ve chosen two cards you need to decide whether you have a match, then either remove the cards or flip them back down and go back to the first state.</li><li>For the content to show, you can just type in a list of words/images into your code if you want, but you’re welcome to use <code>Codable</code> if you want to push yourself.</li></ul><p>Again, this is <em>not</em> an easy challenge so please take your time and don’t feel bad when you find yourself having to look back at previous projects.</p>',8),K=e("div",{class:"hint-container tip"},[e("p",{class:"hint-container-title"},"Note"),e("p",null,"Don’t worry if you don’t complete challenges in the day they were assigned. Today’s challenge is particularly tough, so it will probably be something you solve over a few days. Take your time, look back on previous projects to see how you can re-use ideas, don’t be afraid to experiment, and remember to ask for help if you need it.")],-1),z=e("hr",null,null,-1);function W(h,P){const a=c("router-link"),n=c("VPCard");return m(),p("div",null,[e("h1",w,[e("a",y,[e("span",null,u(h.$frontmatter.title)+" 관련",1)])]),e("nav",f,[e("ul",null,[e("li",null,[t(a,{to:"#milestone-projects-28-30"},{default:o(()=>[l("Milestone: Projects 28-30")]),_:1}),e("ul",null,[e("li",null,[t(a,{to:"#what-you-learned"},{default:o(()=>[l("What you learned")]),_:1})]),e("li",null,[t(a,{to:"#key-points"},{default:o(()=>[l("Key points")]),_:1})]),e("li",null,[t(a,{to:"#challenge"},{default:o(()=>[l("Challenge")]),_:1})])])])])]),k,t(n,s(i({title:"100 Days of Swift - Day 99",desc:"Milestone (Projects 28-30)",link:"https://www.hackingwithswift.com/100/99",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgb(213,52,58,0.2)"})),null,16),b,e("details",v,[I,t(n,s(i({title:"100 Days of Swift - Day 99 - What you learned",desc:"What you learned",link:"https://hackingwithswift.com/guide/11/1/what-you-learned",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgb(213,52,58,0.2)"})),null,16),_]),x,e("details",S,[T,t(n,s(i({title:"100 Days of Swift - Day 99 - Key points",desc:"Key points",link:"https://hackingwithswift.com/guide/11/2/key-points",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgb(213,52,58,0.2)"})),null,16),j]),U,e("details",D,[C,t(n,s(i({title:"100 Days of Swift - Day 99 - Challenge",desc:"Challenge",link:"https://hackingwithswift.com/guide/11/3/challenge",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgb(213,52,58,0.2)"})),null,16),A]),K,z])}const R=d(g,[["render",W],["__file","99.html.vue"]]),V=JSON.parse('{"path":"/swift/100-days-of-swift/99.html","title":"Day 99","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Day 99","description":"100 Days of Swift > Day 99","category":["Swift"],"tag":["crashcourse","paul-hudson","swift","hacking-with-swift","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"100 Days of Swift > Day 99"},{"property":"og:description","content":"Day 99"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/swift/100-days-of-swift/99.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/swift/100-days-of-swift/99.html"}],["meta",{"property":"og:site_name","content":"🥁Crashcourse"}],["meta",{"property":"og:title","content":"Day 99"}],["meta",{"property":"og:description","content":"100 Days of Swift > Day 99"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"paul-hudson"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"hacking-with-swift"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Day 99\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Milestone: Projects 28-30","slug":"milestone-projects-28-30","link":"#milestone-projects-28-30","children":[{"level":3,"title":"What you learned","slug":"what-you-learned","link":"#what-you-learned","children":[]},{"level":3,"title":"Key points","slug":"key-points","link":"#key-points","children":[]},{"level":3,"title":"Challenge","slug":"challenge","link":"#challenge","children":[]}]}],"git":{"createdTime":1708602914000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":7}]},"readingTime":{"minutes":8.65,"words":2596},"filePathRelative":"swift/100-days-of-swift/99.md","localizedDate":"2024년 2월 22일","excerpt":"\\n\\n<hr>\\n"}');export{R as comp,V as data};
