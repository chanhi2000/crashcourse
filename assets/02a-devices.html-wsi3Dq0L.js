import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as u,a as e,t as h,b as a,w as t,n as p,g as v,d as s,e as o,r as l,o as m}from"./app-U_bew1in.js";const f={},y={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},b={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},g={class:"table-of-contents"},_=e("hr",null,null,-1),k=e("hr",null,null,-1),w={id:"_1-dev-directory",tabindex:"-1"},D={class:"header-anchor",href:"#_1-dev-directory"},x=e("code",null,"/dev",-1),S=e("code",null,"ls",-1),C=e("code",null,"cat",-1),T=e("code",null,"etc",-1),j=e("code",null,"/dev",-1),I=e("code",null,"ls",-1),z=e("code",null,"/dev",-1),L=o(`<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">ls</span> /dev</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1),P=e("code",null,"/dev/null",-1),B=e("code",null,"/dev/null",-1),N=e("code",null,"/dev",-1),J=e("code",null,"/dev",-1),Y=e("p",null,"Thankfully we no longer use that method, now we have something that we use to dynamically add and remove devices that are currently being used on the system and we'll be discussing this in the coming lessons.",-1),A=e("code",null,"/dev",-1),R=o(`<hr><h2 id="_2-device-types" tabindex="-1"><a class="header-anchor" href="#_2-device-types"><span>2. device types</span></a></h2><p>Before we chat about how devices are managed, let&#39;s actually take a look at some devices.</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">ls</span> <span class="token parameter variable">-l</span> /dev</span>
<span class="line"><span class="token comment"># brw-rw----   1 root disk      8,   0 Dec 20 20:13 sda</span></span>
<span class="line"><span class="token comment"># crw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null</span></span>
<span class="line"><span class="token comment"># srw-rw-rw-   1 root root           0 Dec 20 20:13 log</span></span>
<span class="line"><span class="token comment"># prw-r--r--   1 root root           0 Dec 20 20:13 fdata</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The columns are as follows from left to right:</p><ul><li>Permissions</li><li>Owner</li><li>Group</li><li>Major Device Number</li><li>Minor Device Number</li><li>Timestamp</li><li>Device Name</li></ul><p>Remember in the ls command you can see the type of file with the first bit on each line. Device files are denoted as the following:</p><ul><li><code>c</code> - character</li><li><code>b</code> - block</li><li><code>p</code> - pipe</li><li><code>s</code> - socket</li></ul><h3 id="character-device" tabindex="-1"><a class="header-anchor" href="#character-device"><span>Character Device</span></a></h3>`,9),M=e("code",null,"/dev/null",-1),F=o('<h3 id="block-device" tabindex="-1"><a class="header-anchor" href="#block-device"><span>Block Device</span></a></h3><p>These devices transfer data, but in large fixed-sized blocks. You&#39;ll most commonly see devices that utilize data blocks as block devices, such as harddrives, filesystems, etc.</p><h3 id="pipe-device" tabindex="-1"><a class="header-anchor" href="#pipe-device"><span>Pipe Device</span></a></h3><p>Named pipes allow two or more processes to communicate with each other, these are similar to character devices, but instead of having output sent to a device, it&#39;s sent to another process.</p><h3 id="socket-device" tabindex="-1"><a class="header-anchor" href="#socket-device"><span>Socket Device</span></a></h3><p>Socket devices facilitate communication between processes, similar to pipe devices but they can communicate with many processes at once.</p><h3 id="device-characterization" tabindex="-1"><a class="header-anchor" href="#device-characterization"><span>Device Characterization</span></a></h3><p>Devices are characterized using two numbers, <strong>major device number</strong> and <strong>minor device number</strong>. You can see these numbers in the above ls example, they are separated by a comma. For example, let&#39;s say a device had the device numbers: <strong>8</strong>, <strong>0</strong>:</p><p>The major device number represents the device driver that is used, in this case 8, which is often the major number for sd block devices. The minor number tells the kernel which unique device it is in this driver class, in this case 0 is used to represent the first device (a).</p>',9),U=e("code",null,"/dev",-1),V=e("hr",null,null,-1),O=e("h2",{id:"_3-device-names",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_3-device-names"},[e("span",null,"3. Device Names")])],-1),q=e("p",null,"Here are the most common device names that you will encounter:",-1),K=e("h3",{id:"scsi-devices",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#scsi-devices"},[e("span",null,"SCSI Devices")])],-1),W=e("p",null,`If you have any sort of mass storage on your machine, chances are it is using the SCSI (pronounced "scuzzy") protocol. SCSI stands for Small Computer System Interface, it is a protocol used for allow communication between disks, printers, scanners and other peripherals to your system. You may have heard of SCSI devices which aren't actually in use in modern systems, however our Linux systems correspond SCSI disks with hard disk drives in /dev. They are represented by a prefix of sd (SCSI disk):`,-1),Z=e("p",null,"Common SCSI device files:",-1),G=e("code",null,"/dev/sda",-1),E=e("code",null,"/dev/sdb",-1),H=e("code",null,"/dev/sda3",-1),$=e("h3",{id:"pseudo-devices",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#pseudo-devices"},[e("span",null,"Pseudo Devices")])],-1),Q=e("p",null,"As we discussed earlier, pseudo devices aren't really physically connected to your system, most common pseudo devices are character devices:",-1),X=e("code",null,"/dev/zero",-1),ee=e("code",null,"/dev/null",-1),se=e("code",null,"/dev/random",-1),ae=e("h3",{id:"pata-devices",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#pata-devices"},[e("span",null,"PATA Devices")])],-1),ne=e("p",null,"Sometimes in older systems you may see hard drives being referred to with an hd prefix:",-1),ie=e("code",null,"/dev/hda",-1),te=e("code",null,"/dev/hdd2",-1),oe=e("p",null,"Write to the pseudo devices and see what happens, be careful not to write your disks to those devices!",-1),le=e("hr",null,null,-1),de={id:"_4-sysfs",tabindex:"-1"},ce={class:"header-anchor",href:"#_4-sysfs"},re=e("code",null,"sysfs",-1),ue=e("code",null,"/dev",-1),he=e("code",null,"/dev",-1),pe=e("code",null,"/sys",-1),ve=e("code",null,"/dev",-1),me=e("code",null,"/sys",-1),fe=e("code",null,"/sys",-1),ye=e("code",null,"/sys",-1),be=o(`<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">ls</span> /sys/block/sda</span>
<span class="line"><span class="token comment"># alignment_offset  discard_alignment  holders   removable  sda6       trace</span></span>
<span class="line"><span class="token comment"># bdi               events             inflight  ro         size       uevent</span></span>
<span class="line"><span class="token comment"># capability        events_async       power     sda1       slaves</span></span>
<span class="line"><span class="token comment"># dev               events_poll_msecs  queue     sda2       stat</span></span>
<span class="line"><span class="token comment"># device            ext_range          range     sda5       subsystem</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),ge=e("code",null,"/sys",-1),_e=o(`<hr><h2 id="_5-udev" tabindex="-1"><a class="header-anchor" href="#_5-udev"><span>5. <code>udev</code></span></a></h2><p>Back in the old days and actually today if you really wanted to, you would create device nodes using a command such as:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">mknod</span> /dev/sdb1 b <span class="token number">8</span> <span class="token number">3</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,4),ke=e("code",null,"/dev/sdb1",-1),we=e("code",null,"rm",-1),De=e("code",null,"/dev",-1),xe=o(`<p>Luckily, we really don&#39;t need to do this anymore because of udev. The udev system dynamically creates and removes device files for us depending on whether or not they are connected. There is a udevd daemon that is running on the system and it listens for messages from the kernel about devices connected to the system. Udevd will parse that information and it will match the data with the rules that are specified in <code>/etc/udev/rules.d</code>, depending on those rules it will most likely create device nodes and symbolic links for the devices. You can write your own udev rules, but that is a little out of scope for this lesson. Fortunately, your system already comes with lots of udev rules so you may never need to write your own.</p><p>You can also view the udev database and sysfs using the <code>udevadm</code> command. This tool is very useful, but sometimes can get very convoluted, a simple command to view information for a device would be:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">udevadm info <span class="token parameter variable">--query</span><span class="token operator">=</span>all <span class="token parameter variable">--name</span><span class="token operator">=</span>/dev/sda</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Run the <code>udevadm</code> command given and check out the input.</p><hr><h2 id="_6-lsusb-lspci-lssci" tabindex="-1"><a class="header-anchor" href="#_6-lsusb-lspci-lssci"><span>6. <code>lsusb</code>, <code>lspci</code>, <code>lssci</code></span></a></h2><p>Just like we would use the ls command to list files and directories, we can use similar tools that list information about devices.</p><h3 id="listing-usb-devices" tabindex="-1"><a class="header-anchor" href="#listing-usb-devices"><span>Listing USB Devices</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">lsusb </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="listing-pci-devices" tabindex="-1"><a class="header-anchor" href="#listing-pci-devices"><span>Listing PCI Devices</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">lspci </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="listing-scsi-devices" tabindex="-1"><a class="header-anchor" href="#listing-scsi-devices"><span>Listing SCSI Devices</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">lsscsi </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Try out each of these commands and see the output you receive.</p><hr><h2 id="_7-dd" tabindex="-1"><a class="header-anchor" href="#_7-dd"><span>7. <code>dd</code></span></a></h2><p>The <code>dd</code> tool is super useful for converting and copying data. It reads input from a file or data stream and writes it to a file or data stream.</p><p>Consider the following command:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/home/pete/backup.img <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/sdb <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">1024</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,19),Se=e("code",null,"/dev/sdb",-1),Ce=o(`<ul><li><code>if=file</code> - Input file, read from a file instead of standard input</li><li><code>of=file</code> - Output file, write to a file instead of standard output</li><li><code>bs=bytes</code> - Block size, it reads and writes this many bytes of data at a time. You can use different size metrics by denoting the size with a k for kilobyte, m for megabyte, etc, so 1024 bytes is 1k</li><li><code>count=number</code> - Number of blocks to copy.</li></ul><p>You will see some <code>dd</code> commands that use the count option, usually with <code>dd</code> if you want to copy a file that is 1 megabyte, you&#39;ll usually want to see that file as 1 megabyte when it&#39;s done being copied. Let&#39;s say you run the following command:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/home/pete/backup.img <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/sdb <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Our <code>backup.img</code> file is 10M, however, we are saying in this command to copy over 1M 2 times, so only 2M is being copied, leaving our copied data incomplete. Count can come in handy in many situations, but if you are just copying over data, you can pretty much omit count and even bs for that matter. If you really want to optimize your data transfers, then you&#39;ll want to start using those options.</p><p><code>dd</code> is extremely powerful, you can use it to make backups of anything, including whole disk drives, restoring disks images, and more. Be careful, that powerful tool can come at a price if you aren&#39;t sure what you are doing.</p><p>Use the <code>dd</code> command to make a backup of your drive and set the output to a <code>.img</code> file.</p><hr>`,7);function Te(d,je){const n=l("FontIcon"),i=l("router-link"),c=l("VPCard");return m(),u("div",null,[e("h1",y,[e("a",b,[e("span",null,h(d.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),e("nav",g,[e("ul",null,[e("li",null,[a(i,{to:"#_1-dev-directory"},{default:t(()=>[s("1. "),a(n,{icon:"fas fa-folder-open"}),s("/dev directory")]),_:1})]),e("li",null,[a(i,{to:"#_2-device-types"},{default:t(()=>[s("2. device types")]),_:1}),e("ul",null,[e("li",null,[a(i,{to:"#character-device"},{default:t(()=>[s("Character Device")]),_:1})]),e("li",null,[a(i,{to:"#block-device"},{default:t(()=>[s("Block Device")]),_:1})]),e("li",null,[a(i,{to:"#pipe-device"},{default:t(()=>[s("Pipe Device")]),_:1})]),e("li",null,[a(i,{to:"#socket-device"},{default:t(()=>[s("Socket Device")]),_:1})]),e("li",null,[a(i,{to:"#device-characterization"},{default:t(()=>[s("Device Characterization")]),_:1})])])]),e("li",null,[a(i,{to:"#_3-device-names"},{default:t(()=>[s("3. Device Names")]),_:1}),e("ul",null,[e("li",null,[a(i,{to:"#scsi-devices"},{default:t(()=>[s("SCSI Devices")]),_:1})]),e("li",null,[a(i,{to:"#pseudo-devices"},{default:t(()=>[s("Pseudo Devices")]),_:1})]),e("li",null,[a(i,{to:"#pata-devices"},{default:t(()=>[s("PATA Devices")]),_:1})])])]),e("li",null,[a(i,{to:"#_4-sysfs"},{default:t(()=>[s("4. "),a(n,{icon:"fas fa-folder-open"}),s("sysfs")]),_:1})]),e("li",null,[a(i,{to:"#_5-udev"},{default:t(()=>[s("5. udev")]),_:1})]),e("li",null,[a(i,{to:"#_6-lsusb-lspci-lssci"},{default:t(()=>[s("6. lsusb, lspci, lssci")]),_:1}),e("ul",null,[e("li",null,[a(i,{to:"#listing-usb-devices"},{default:t(()=>[s("Listing USB Devices")]),_:1})]),e("li",null,[a(i,{to:"#listing-pci-devices"},{default:t(()=>[s("Listing PCI Devices")]),_:1})]),e("li",null,[a(i,{to:"#listing-scsi-devices"},{default:t(()=>[s("Listing SCSI Devices")]),_:1})])])]),e("li",null,[a(i,{to:"#_7-dd"},{default:t(()=>[s("7. dd")]),_:1})])])]),_,a(c,p(v({title:"Devices",desc:"Learn about Linux devices and how they interact with the kernel and user space.",link:"https://linuxjourney.com/lesson/dev-directory",logo:"https://linuxjourney.com/assets/devices-5088f49b6a0d4ce892e106ee1e837e401de62d8f1ee8648ac00bd9a0e9f576c2.png",background:"rgba(24,188,156,0.2)"})),null,16),k,e("h2",w,[e("a",D,[e("span",null,[s("1. "),a(n,{icon:"fas fa-folder-open"}),x,s(" directory")])])]),e("p",null,[s("When you connect a device to your machine, it generally needs a device driver to function properly. You can interact with device drivers through device files or device nodes, these are special files that look like regular files. Since these device files are just like regular files, you can use programs such as "),S,s(", "),C,s(", "),T,s(" to interact with them. These device files are generally stored in the "),j,s(" directory. Go ahead and "),I,s(" the "),a(n,{icon:"fas fa-folder-open"}),z,s(" directory on your system, you'll see a large amount of devices files that are on your system.")]),L,e("p",null,[s("Some of these devices you've already used and interacted with such as "),a(n,{icon:"fas fa-folder-open"}),P,s(". Remember when we send output to "),a(n,{icon:"fas fa-folder-open"}),B,s(", the kernel knows that this device takes all of our input and just discards it, so nothing gets returned.")]),e("p",null,[s("In the old days, if you wanted to add a device to your system, you'd add the device file in "),a(n,{icon:"fas fa-folder-open"}),N,s(" and then probably forget about it. Well repeat that a couple of times and you can see where there was a problem. The "),a(n,{icon:"fas fa-folder-open"}),J,s(" directory would get cluttered with static device files of devices that you've long since upgraded, stopped using, etc. Devices are also assigned device files in the order that the kernel finds them. So if everytime you rebooted your system, the devices could have different device files depending on when they were discovered.")]),Y,e("p",null,[s("Check out the contents of the "),a(n,{icon:"fas fa-folder-open"}),A,s(" directory, do you recognize any familiar devices?")]),R,e("p",null,[s("These devices transfer data, but one a character at a time. You'll see a lot of pseudo devices ("),a(n,{icon:"fas fa-folder-open"}),M,s(") as character devices, these devices aren't really physically connected to the machine, but they allow the operating system greater functionality.")]),F,e("p",null,[s("Look at your "),a(n,{icon:"fas fa-folder-open"}),U,s(" directory and find out what types of devices you can see.")]),V,O,q,K,W,Z,e("ul",null,[e("li",null,[a(n,{icon:"fas fa-folder-open"}),G,s(" - First hard disk")]),e("li",null,[a(n,{icon:"fas fa-folder-open"}),E,s(" - Second hard disk")]),e("li",null,[a(n,{icon:"fas fa-folder-open"}),H,s(" - Third partition on the first hard disk")])]),$,Q,e("ul",null,[e("li",null,[a(n,{icon:"fas fa-folder-open"}),X,s(" - accepts and discards all input, produces a continuous stream of NULL (zero value) bytes")]),e("li",null,[a(n,{icon:"fas fa-folder-open"}),ee,s(" - accepts and discards all input, produces no output")]),e("li",null,[a(n,{icon:"fas fa-folder-open"}),se,s(" - produces random numbers")])]),ae,ne,e("ul",null,[e("li",null,[a(n,{icon:"fas fa-folder-open"}),ie,s(" - First hard disk")]),e("li",null,[a(n,{icon:"fas fa-folder-open"}),te,s(" - Second partition on 4th hard disk")])]),oe,le,e("h2",de,[e("a",ce,[e("span",null,[s("4. "),a(n,{icon:"fas fa-folder-open"}),re])])]),e("p",null,[s("Sysfs was created long ago to better manage devices on our system that the "),a(n,{icon:"fas fa-folder-open"}),ue,s(" directory failed to do. Sysfs is a virtual filesystem, most often mounted to the /sys directory. It gives us more detailed information than what we would be able to see in the "),a(n,{icon:"fas fa-folder-open"}),he,s(" directory. Both directories "),a(n,{icon:"fas fa-folder-open"}),pe,s(" and /dev seem to be very similar and they are in some regards, but they do have major differences. Basically, the "),a(n,{icon:"fas fa-folder-open"}),ve,s(" directory is simple, it allows other programs to access devices themselves, while the "),a(n,{icon:"fas fa-folder-open"}),me,s(" filesystem is used to view information and manage the device.")]),e("p",null,[s("The /sys filesystem basically contains all the information for all devices on your system, such as the manufacturer and model, where the device is plugged in, the state of the device, the hierarchy of devices and more. The files you see here aren't device nodes, so you don't really interact with devices from the "),a(n,{icon:"fas fa-folder-open"}),fe,s(" directory, rather you are managing devices.")]),e("p",null,[s("Take a look at the contents of the "),a(n,{icon:"fas fa-folder-open"}),ye,s(" directory:")]),be,e("p",null,[s("Check out the contents of the "),a(n,{icon:"fas fa-folder-open"}),ge,s(" directory and see what files are located in there.")]),_e,e("p",null,[s("This command will make a device node "),a(n,{icon:"fas fa-folder-open"}),ke,s(" and it will make it a block device (b) with a major number of 8 and a minor number of 3.")]),e("p",null,[s("To remove a device, you would simply "),we,s(" the device file in the "),a(n,{icon:"fas fa-folder-open"}),De,s(" directory.")]),xe,e("p",null,[s("This command is copying the contents of backup.img to "),a(n,{icon:"fas fa-folder-open"}),Se,s(". It will copy the data in blocks of 1024 bytes until there is no more data to be copied.")]),Ce])}const Le=r(f,[["render",Te],["__file","02a-devices.html.vue"]]),Pe=JSON.parse('{"path":"/devops/linux-journey/02-journeyman/02a-devices.html","title":"Journeyman > 02a. Devices","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Journeyman > 02a. Devices","description":"Linux Journey > Journeyman > 02a. Devices","category":["Linux"],"tag":["crashcourse","linux","os","networking"],"head":[[{"meta":null},{"property":"og:title","content":"Linux Journey > Journeyman > 02a. Devices"},{"property":"og:description","content":"02a. Devices"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/devops/linux-journey/02-journeyman/02a-devices.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/devops/linux-journey/02-journeyman/02a-devices.html"}],["meta",{"property":"og:site_name","content":"ü•ÅCrashcourse"}],["meta",{"property":"og:title","content":"Journeyman > 02a. Devices"}],["meta",{"property":"og:description","content":"Linux Journey > Journeyman > 02a. Devices"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:tag","content":"os"}],["meta",{"property":"article:tag","content":"networking"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Journeyman > 02a. Devices\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1. /dev directory","slug":"_1-dev-directory","link":"#_1-dev-directory","children":[]},{"level":2,"title":"2. device types","slug":"_2-device-types","link":"#_2-device-types","children":[{"level":3,"title":"Character Device","slug":"character-device","link":"#character-device","children":[]},{"level":3,"title":"Block Device","slug":"block-device","link":"#block-device","children":[]},{"level":3,"title":"Pipe Device","slug":"pipe-device","link":"#pipe-device","children":[]},{"level":3,"title":"Socket Device","slug":"socket-device","link":"#socket-device","children":[]},{"level":3,"title":"Device Characterization","slug":"device-characterization","link":"#device-characterization","children":[]}]},{"level":2,"title":"3. Device Names","slug":"_3-device-names","link":"#_3-device-names","children":[{"level":3,"title":"SCSI Devices","slug":"scsi-devices","link":"#scsi-devices","children":[]},{"level":3,"title":"Pseudo Devices","slug":"pseudo-devices","link":"#pseudo-devices","children":[]},{"level":3,"title":"PATA Devices","slug":"pata-devices","link":"#pata-devices","children":[]}]},{"level":2,"title":"4. sysfs","slug":"_4-sysfs","link":"#_4-sysfs","children":[]},{"level":2,"title":"5. udev","slug":"_5-udev","link":"#_5-udev","children":[]},{"level":2,"title":"6. lsusb, lspci, lssci","slug":"_6-lsusb-lspci-lssci","link":"#_6-lsusb-lspci-lssci","children":[{"level":3,"title":"Listing USB Devices","slug":"listing-usb-devices","link":"#listing-usb-devices","children":[]},{"level":3,"title":"Listing PCI Devices","slug":"listing-pci-devices","link":"#listing-pci-devices","children":[]},{"level":3,"title":"Listing SCSI Devices","slug":"listing-scsi-devices","link":"#listing-scsi-devices","children":[]}]},{"level":2,"title":"7. dd","slug":"_7-dd","link":"#_7-dd","children":[]}],"git":{"createdTime":1703642364000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":8}]},"readingTime":{"minutes":6.78,"words":2035},"filePathRelative":"devops/linux-journey/02-journeyman/02a-devices.md","localizedDate":"2023ÎÖÑ 12Ïõî 27Ïùº","excerpt":"\\n\\n<hr>\\n"}');export{Le as comp,Pe as data};
