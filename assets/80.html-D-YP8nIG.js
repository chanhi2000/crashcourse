import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as k,a as n,t as h,b as s,w as o,n as i,g as p,e as l,d as a,r,o as g}from"./app-U_bew1in.js";const m={},f={id:"frontmatter-title-관련",tabindex:"-1"},w={class:"header-anchor",href:"#frontmatter-title-관련"},b={class:"table-of-contents"},y=n("hr",null,null,-1),v=l('<h2 id="project-24-part-one" tabindex="-1"><a class="header-anchor" href="#project-24-part-one"><span>Project 24, part one</span></a></h2><p>In today’s technique project we’re going to zoom in on one specific detail of Swift programming: strings. Steve Jobs famously said “this is what customers pay us for: to sweat all these details so it&#39;s easy and pleasant for them to use our computers,” and strings are a good example of one of those details – they look like they ought to be simple, but if you want to get them <em>right</em> you need to spend some time working at it.</p><p>As you’ll see, there’s more to strings than just being a sequence of characters. In fact, Swift’s string handling is the most advanced I’ve seen in any language, and as a result if you play by Swift’s rules you’ll find your apps work great in every conceivable language – something that most developers for other languages need to work hard at.</p><p>Today you’re also going to learn an important skill that might cause you to go back and look through earlier projects for places you can use it: how to add formatting to your strings. This is done using a class called <code>NSAttributedString</code>, and although we’re only using it at an introductory level here as your skills progress you’ll learn how it can add images to strings – it’s really powerful!</p><p><strong>Today you have four topics to work through, and you’ll learn about string subscripts, <code>contains(where:)</code>, <code>NSAttributedString</code>, and more.</strong></p><h3 id="setting-up" tabindex="-1"><a class="header-anchor" href="#setting-up"><span>Setting up</span></a></h3>',6),S={class:"hint-container details"},x=n("summary",null,"Setting up",-1),_=n("p",null,"After a long project 23, it’s time to ease off and look at something that you might think would be much easier: strings. Yes, those pieces of text we take for granted in almost every program we write – they ought to be fairly straightforward things, but it turns out that they are complicated little beasts and take a little thinking.",-1),q=n("p",null,[a("In this technique project we’re going to look at why strings often confuse newcomers to Swift, we’ll try out a variety of properties and methods that are useful, and we’re also going to look at how to add "),n("em",null,"formatting"),a(" to strings – bold, italics, color, and more – using a separate class called "),n("code",null,"NSAttributedString"),a(". Supported for attributed strings is baked into most of UIKit, so you can use it with "),n("code",null,"UILabel"),a(", "),n("code",null,"UITextView"),a(", and more.")],-1),j=n("p",null,"In Xcode, go to the File menu and choose New > Playground. Name it Project24, make sure iOS is selected as the platform, then choose Next and save it somewhere you can find later.",-1),N=n("h3",{id:"strings-are-not-arrays",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#strings-are-not-arrays"},[n("span",null,"Strings are not arrays")])],-1),A={class:"hint-container details"},I=n("summary",null,"Strings are not arrays",-1),T=l(`<p>One of the things that confuses learners is that Swift’s strings look like arrays of letters, but that’s not really true.</p><p>Sure, we can loop over them like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Taylor&quot;</span></span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">for</span> letter <span class="token keyword">in</span> name <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Give me a </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">letter</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">!&quot;</span></span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>However, we <em>can’t</em> read individual letters from the string. So, this kind of code won’t work:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The reason for this is that letters in a string aren’t just a series of alphabetical characters – they can contain accents such as á, é, í, ó, or ú, they can contain combining marks that generate wholly new characters by building up symbols, or they can even be emoji.</p><p>Because of this, if you want to read the fourth character of <code>name</code> you need to start at the beginning and count through each letter until you come to the one you’re looking for:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> letter <span class="token operator">=</span> name<span class="token punctuation">[</span>name<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span>startIndex<span class="token punctuation">,</span> offsetBy<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Apple could change this easily enough by adding a rather complex extension like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">subscript</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">[</span><span class="token function">index</span><span class="token punctuation">(</span>startIndex<span class="token punctuation">,</span> offsetBy<span class="token punctuation">:</span> i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>With that in place, we can now read <code>name[3]</code> just fine. However, it creates the possibility that someone might write code that loops over a string reading individual letters, which they might not realize creates a loop within a loop and has the potential to be slow.</p><p>Similarly, reading <code>name.count</code> isn’t a quick operation: Swift literally needs to go over every letter counting up however many there are, before returning that. As a result, it’s always better to use <code>someString.isEmpty</code> rather than <code>someString.count == 0</code> if you’re looking for an empty string.</p>`,12),F=n("h3",{id:"working-with-strings-in-swift",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#working-with-strings-in-swift"},[n("span",null,"Working with strings in Swift")])],-1),D={class:"hint-container details"},U=n("summary",null,"Working with strings in Swift",-1),C=l(`<p>We’ve used strings in lots of the projects so far, and I’ve tried to introduce you to a handful of important properties and methods as we go. Here, though, I’m going to run through some of those, plus a few more, while also looking at how we can write extensions to make strings a little more useful.</p><p>First, there are methods for checking whether a string starts with or ends with a substring: <code>hasPrefix()</code> and <code>hasSuffix()</code>. They look like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> password <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;12345&quot;</span></span></span>
<span class="line">password<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;123&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">password<span class="token punctuation">.</span><span class="token function">hasSuffix</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;345&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We can add extension methods to <code>String</code> to extend the way prefixing and suffixing works:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// remove a prefix if it exists</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">deletingPrefix</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> <span class="token keyword">prefix</span><span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">guard</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token keyword">prefix</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">self</span> <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">dropFirst</span><span class="token punctuation">(</span><span class="token keyword">prefix</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// remove a suffix if it exists</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">deletingSuffix</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> suffix<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">guard</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">hasSuffix</span><span class="token punctuation">(</span>suffix<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">self</span> <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">dropLast</span><span class="token punctuation">(</span>suffix<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That uses the <code>dropFirst()</code> and <code>dropLast()</code> method of <code>String</code>, which removes a certain number of letters from either end of the string.</p><p>We’ve used <code>lowercased()</code> and <code>uppercased()</code> in previous projects, but there’s also the <code>capitalized</code> property that gives the first letter of each word a capital letter. For example:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> weather <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;it&#39;s going to rain&quot;</span></span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>weather<span class="token punctuation">.</span>capitalized<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>That will print “It’s Going To Rain”.</p><p>We could add our own specialized capitalization that uppercases only the first letter in our string:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> capitalizedFirst<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">guard</span> <span class="token keyword">let</span> firstLetter <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>first <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span> <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> firstLetter<span class="token punctuation">.</span><span class="token function">uppercased</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">dropFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>One thing you <em>can’t</em> see in that is an interesting subtlety of working with strings: individual letters in strings aren’t instances of <code>String</code>, but are instead instances of <code>Character</code> – a dedicated type for holding single-letters of a string.</p><p>So, that <code>uppercased()</code> method is actually a method on <em>Character</em> rather than <em>String</em>. However, where things get <em>really</em> interesting is that <code>Character.uppercased()</code> actually returns a string, not an uppercased <code>Character</code>. The reason is simple: language is complicated, and although many languages have one-to-one mappings between lowercase and uppercase characters, some do not.</p><p>For example, in English “a” maps to “A”, “b” to “B”, and so on, but in German “ß” becomes “SS” when uppercased. “SS” is clearly two separate letters, so <code>uppercased()</code> has no choice but to return a string.</p><p>One last useful method of strings is <code>contains()</code>, which returns true if it contains another string. So, this will return true:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> input <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Swift is like Objective-C without the C&quot;</span></span></span>
<span class="line">input<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Swift&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>So, <code>contains()</code> takes a string parameter and returns true or false depending on whether that parameter exists in the string. Keep that in your head for a moment.</p><p>Now look at this code:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> languages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;Python&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Ruby&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Swift&quot;</span></span><span class="token punctuation">]</span></span>
<span class="line">languages<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Swift&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>That will also return true, because arrays have a <code>contains()</code> method that returns true or false depending on whether they contain the element you were looking for.</p><p>Now for the part that confuses people – brace yourself!</p><p>We have an array of strings (<code>[&quot;Python&quot;, &quot;Ruby&quot;, &quot;Swift&quot;]</code>) and we have an input string (<code>&quot;Swift is like Objective-C without the C&quot;</code>). How can we check whether any string in our array exists in our input string?</p><p>Well, we might start writing an extension on <code>String</code> like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">extension</span> <span class="token class-name">String</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">func</span> <span class="token function-definition function">containsAny</span><span class="token punctuation">(</span>of array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">for</span> item <span class="token keyword">in</span> array <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">return</span> <span class="token boolean">true</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">false</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We can now run our check like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">input<span class="token punctuation">.</span><span class="token function">containsAny</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> languages<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That certainly <em>works</em>, but it’s not elegant – and Swift has a better solution built right in.</p><p>You see, arrays have a <em>second</em> <code>contains()</code> method called <code>contains(where:)</code>. This lets us provide a closure that accepts an element from the array as its only parameter and returns true or false depending on whatever condition we decide we want. This closure gets run on all the items in the array until one returns true, at which point it stops.</p><p>Now let’s put together the pieces:</p><ul><li>When used with an array of strings, the <code>contains(where:)</code> method wants to call a closure that accepts a string and returns true or false.</li><li>The <code>contains()</code> method of <code>String</code> accepts a string as its parameter and returns true or false.</li><li>Swift massively blurs the lines between functions, methods, closures, and more.</li></ul><p>So, what we can actually do is pass one function directly into the other, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line">languages<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">where</span><span class="token punctuation">:</span> input<span class="token punctuation">.</span>contains<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Don’t feel bad if you need to read that single line of code several times – it’s not easy! Let’s break it down.</p><p><code>contains(where:)</code> will call its closure once for every element in the <code>languages</code> array until it finds one that returns true, at which point it stops.</p><p>In that code we’re passing <code>input.contains</code> as the closure that <code>contains(where:)</code> should run. This means Swift will call <code>input.contains(&quot;Python&quot;)</code> and get back false, then it will call <code>input.contains(&quot;Ruby&quot;)</code> and get back false again, and finally call <code>input.contains(&quot;Swift&quot;)</code> and get back true – then stop there.</p><p>So, because the <code>contains()</code> method of strings has the exact same signature that <code>contains(where:)</code> expects (take a string and return a Boolean), this works perfectly – do you see what I mean about how Swift blurs the lines between these things?</p>`,36),P=n("h3",{id:"formatting-strings-with-nsattributedstring",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#formatting-strings-with-nsattributedstring"},[n("span",null,[a("Formatting strings with "),n("code",null,"NSAttributedString")])])],-1),W={class:"hint-container details"},z=n("summary",null,"Formatting strings with NSAttributedString",-1),R=l(`<p>Swift’s strings are plain text, which works fine in the vast majority of cases we work with text. But sometimes we want <em>more</em> – we want to be able to add formatting like bold or italics, select from different fonts, or add some color, and for <em>those</em> jobs we have a new class called <code>NSAttributedString</code>.</p><p>Attributed strings are made up of two parts: a plain Swift string, plus a dictionary containing a series of attributes that describe how various segments of the string are formatted. In its most basic form you might want to create one set of attributes that affect the whole string, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;This is a test string&quot;</span></span></span>
<span class="line"><span class="token keyword">let</span> attributes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">NSAttributedString</span><span class="token punctuation">.</span><span class="token class-name">Key</span><span class="token punctuation">:</span> <span class="token keyword">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span></span>
<span class="line">    <span class="token punctuation">.</span>foregroundColor<span class="token punctuation">:</span> <span class="token class-name">UIColor</span><span class="token punctuation">.</span>white<span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">.</span>backgroundColor<span class="token punctuation">:</span> <span class="token class-name">UIColor</span><span class="token punctuation">.</span>red<span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">.</span>font<span class="token punctuation">:</span> <span class="token class-name">UIFont</span><span class="token punctuation">.</span><span class="token function">boldSystemFont</span><span class="token punctuation">(</span>ofSize<span class="token punctuation">:</span> <span class="token number">36</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> attributedString <span class="token operator">=</span> <span class="token class-name">NSAttributedString</span><span class="token punctuation">(</span>string<span class="token punctuation">:</span> string<span class="token punctuation">,</span> attributes<span class="token punctuation">:</span> attributes<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>It’s common to use an explicit type annotation when making attributed strings, because inside the dictionary we can just write things like <code>.foregroundColor</code> for the key rather than <code>NSAttributedString.Key.foregroundColor</code>.</p><p>The <em>values</em> of the attributes dictionary are of type <code>Any</code>, because <code>NSAttributedString</code> attributes can be all sorts of things: numbers, colors, fonts, paragraph styles, and more.</p><p>If you look in the output pane of your playground, you should be able to click on the box next to where it says “This is a test string” to get a live preview of how our string looks – you should see large, white text with a red background.</p><p>Of course, we could get the same effect with a regular string placed inside a <code>UILabel</code>: change the font and colors, and it would look the same. But what labels <em>can’t</em> do is add formatting to different parts of the string.</p><p>To demonstrate this we’re going to use <code>NSMutableAttributedString</code>, which is an attributed string that you can modify:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> attributedString <span class="token operator">=</span> <span class="token class-name">NSMutableAttributedString</span><span class="token punctuation">(</span>string<span class="token punctuation">:</span> string<span class="token punctuation">)</span></span>
<span class="line">attributedString<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token punctuation">.</span>font<span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token class-name">UIFont</span><span class="token punctuation">.</span><span class="token function">systemFont</span><span class="token punctuation">(</span>ofSize<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> range<span class="token punctuation">:</span> <span class="token class-name">NSRange</span><span class="token punctuation">(</span>location<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">attributedString<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token punctuation">.</span>font<span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token class-name">UIFont</span><span class="token punctuation">.</span><span class="token function">systemFont</span><span class="token punctuation">(</span>ofSize<span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> range<span class="token punctuation">:</span> <span class="token class-name">NSRange</span><span class="token punctuation">(</span>location<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">attributedString<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token punctuation">.</span>font<span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token class-name">UIFont</span><span class="token punctuation">.</span><span class="token function">systemFont</span><span class="token punctuation">(</span>ofSize<span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">,</span> range<span class="token punctuation">:</span> <span class="token class-name">NSRange</span><span class="token punctuation">(</span>location<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">attributedString<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token punctuation">.</span>font<span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token class-name">UIFont</span><span class="token punctuation">.</span><span class="token function">systemFont</span><span class="token punctuation">(</span>ofSize<span class="token punctuation">:</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span> range<span class="token punctuation">:</span> <span class="token class-name">NSRange</span><span class="token punctuation">(</span>location<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">attributedString<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token punctuation">.</span>font<span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token class-name">UIFont</span><span class="token punctuation">.</span><span class="token function">systemFont</span><span class="token punctuation">(</span>ofSize<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span> range<span class="token punctuation">:</span> <span class="token class-name">NSRange</span><span class="token punctuation">(</span>location<span class="token punctuation">:</span> <span class="token number">15</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>When you preview <em>that</em> you’ll see the font size get larger with each word – something a regular Swift string certainly can’t do even with help from <code>UILabel</code>.</p><p>There are lots of formatting options for attributed strings, including:</p><ul><li>Set <code>.underlineStyle</code> to a value from <code>NSUnderlineStyle</code> to strike out characters.</li><li>Set <code>.strikethroughStyle</code> to a value from <code>NSUnderlineStyle</code> (no, that’s not a typo) to strike out characters.</li><li>Set <code>.paragraphStyle</code> to an instance of <code>NSMutableParagraphStyle</code> to control text alignment and spacing.</li><li>Set <code>.link</code> to be a <code>URL</code> to make clickable links in your strings.</li></ul><p>And that’s just a subset of what you can do.</p><p>You might be wondering how useful all this knowledge is, but here’s the important part: <code>UILabel</code>, <code>UITextField</code>, <code>UITextView</code>, <code>UIButton</code>, <code>UINavigationBar</code>, and more all support attributed strings just as well as regular strings. So, for a label you would just use <code>attributedText</code> rather than <code>text</code>, and UIKit takes care of the rest.</p>`,14),B=n("hr",null,null,-1);function L(u,V){const t=r("router-link"),e=r("VPCard"),c=r("VidStack");return g(),k("div",null,[n("h1",f,[n("a",w,[n("span",null,h(u.$frontmatter.title)+" 관련",1)])]),n("nav",b,[n("ul",null,[n("li",null,[s(t,{to:"#project-24-part-one"},{default:o(()=>[a("Project 24, part one")]),_:1}),n("ul",null,[n("li",null,[s(t,{to:"#setting-up"},{default:o(()=>[a("Setting up")]),_:1})]),n("li",null,[s(t,{to:"#strings-are-not-arrays"},{default:o(()=>[a("Strings are not arrays")]),_:1})]),n("li",null,[s(t,{to:"#working-with-strings-in-swift"},{default:o(()=>[a("Working with strings in Swift")]),_:1})]),n("li",null,[s(t,{to:"#formatting-strings-with-nsattributedstring"},{default:o(()=>[a("Formatting strings with NSAttributedString")]),_:1})])])])])]),y,s(e,i(p({title:"100 Days of Swift - Day 80",desc:"Project 24, part one",link:"https://www.hackingwithswift.com/100/80",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),v,n("details",S,[x,s(e,i(p({title:"100 Days of Swift - Day 80 - Setting up",desc:"Setting up",link:"https://www.hackingwithswift.com/read/24/1/setting-up",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),s(c,{src:"youtube/V9cWsGJ4aLc"}),_,q,j]),N,n("details",A,[I,s(e,i(p({title:"100 Days of Swift - Day 80 - Strings are not arrays",desc:"Strings are not arrays",link:"https://www.hackingwithswift.com/read/24/2/strings-are-not-arrays",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),s(c,{src:"youtube/oeKUmAgyOdw"}),T]),F,n("details",D,[U,s(e,i(p({title:"100 Days of Swift - Day 80 - Working with strings in Swift",desc:"Working with strings in Swift",link:"https://www.hackingwithswift.com/read/24/3/working-with-strings-in-swift",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),s(c,{src:"youtube/AthqAjYhZLw"}),C]),P,n("details",W,[z,s(e,i(p({title:"100 Days of Swift - Day 80 - Formatting strings with NSAttributedString",desc:"Formatting strings with NSAttributedString",link:"https://www.hackingwithswift.com/read/24/4/formatting-strings-with-nsattributedstring",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),s(c,{src:"youtube/xNX45MXsXWc"}),R]),B])}const H=d(m,[["render",L],["__file","80.html.vue"]]),M=JSON.parse('{"path":"/swift/100-days-of-swift/80.html","title":"Day 80","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Day 80","description":"100 Days of Swift > Day 80","category":["Swift"],"tag":["crashcourse","paul-hudson","swift","hacking-with-swift","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"100 Days of Swift > Day 80"},{"property":"og:description","content":"Day 80"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/swift/100-days-of-swift/80.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/swift/100-days-of-swift/80.html"}],["meta",{"property":"og:site_name","content":"🥁Crashcourse"}],["meta",{"property":"og:title","content":"Day 80"}],["meta",{"property":"og:description","content":"100 Days of Swift > Day 80"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"paul-hudson"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"hacking-with-swift"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Day 80\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Project 24, part one","slug":"project-24-part-one","link":"#project-24-part-one","children":[{"level":3,"title":"Setting up","slug":"setting-up","link":"#setting-up","children":[]},{"level":3,"title":"Strings are not arrays","slug":"strings-are-not-arrays","link":"#strings-are-not-arrays","children":[]},{"level":3,"title":"Working with strings in Swift","slug":"working-with-strings-in-swift","link":"#working-with-strings-in-swift","children":[]},{"level":3,"title":"Formatting strings with NSAttributedString","slug":"formatting-strings-with-nsattributedstring","link":"#formatting-strings-with-nsattributedstring","children":[]}]}],"git":{"createdTime":1703642364000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":11}]},"readingTime":{"minutes":7.88,"words":2363},"filePathRelative":"swift/100-days-of-swift/80.md","localizedDate":"2023년 12월 27일","excerpt":"\\n\\n<hr>\\n"}');export{H as comp,M as data};
