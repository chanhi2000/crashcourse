import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,a as n,t as r,b as s,w as e,n as d,g as u,e as m,r as o,o as h,d as t}from"./app-U_bew1in.js";const k={},f={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},b={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},v={class:"table-of-contents"},y=n("hr",null,null,-1),g=m(`<hr><blockquote><p>Rust to assembly: Arrays, Tuples, Box, and Option handling</p></blockquote><p>We have already seen how Rust handles enums under the hood. We also looked at the code generation for the Box smart pointer. Here we put these items together in a Rust example that describes how arrays, tuples, Option enum, and Box smart pointer allocations are managed at the assembly level.</p><h2 id="code-example" tabindex="-1"><a class="header-anchor" href="#code-example"><span>Code example</span></a></h2><p>We will be dissecting the assembly generated for the following Rust code. The code defines functions that take arrays, tuples, Box, and Option as arguments and return them. We will be looking at the assembly generated for the functions that take these types as arguments.</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token comment">// A named tuple with two fields.</span></span>
<span class="line"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Coordinate</span><span class="token punctuation">(</span><span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token keyword">f64</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// A named tuple that contains two named tuples.</span></span>
<span class="line"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Line</span><span class="token punctuation">(</span><span class="token class-name">Coordinate</span><span class="token punctuation">,</span> <span class="token class-name">Coordinate</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// This function takes an optional named tuple and returns an optional Box smart pointer containing four</span></span>
<span class="line"><span class="token comment">// coordinates.</span></span>
<span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">make_quad_coordinates</span><span class="token punctuation">(</span>maybe_coordinate<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Coordinate</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token class-name">Coordinate</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// Check if the Option uses the Some variant. If it does, then extract the contents of the tuple</span></span>
<span class="line">    <span class="token comment">// into x and y variables. If a None variant is used, the function simply returns.</span></span>
<span class="line">    <span class="token comment">// The question mark is syntactic sugar for matching and extracting from a Some and returning on None.</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> maybe_coordinate<span class="token operator">?</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// Create a new Box smart pointer containing four coordinates. Note that this involves memory</span></span>
<span class="line">    <span class="token comment">// allocation on the heap.</span></span>
<span class="line">    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span></span>
<span class="line">        <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token class-name">Coordinate</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">,</span> <span class="token operator">-</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token class-name">Coordinate</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token operator">-</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// This function takes an optional named tuple and returns an optional tuple by value.</span></span>
<span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">cross_lines_from_quad_coordinates</span><span class="token punctuation">(</span></span>
<span class="line">    maybe_coordinate<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Coordinate</span><span class="token operator">&gt;</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token class-name">Line</span><span class="token punctuation">,</span> <span class="token class-name">Line</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// Pattern match and extract the contents of the array if the Option uses the Some variant.</span></span>
<span class="line">    <span class="token comment">// Return None if the Option uses the None variant.</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">make_quad_coordinates</span><span class="token punctuation">(</span>maybe_coordinate<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// Form two lines from four coordinates and return them as a tuple.</span></span>
<span class="line">    <span class="token comment">// The tuple is wrapped in a Some variant.</span></span>
<span class="line">    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Line</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Line</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Let us split the analysis into two functions:</p><ul><li><code>make_quad_coordinates</code> that takes an optional named tuple and returns an optional Box smart pointer containing four coordinates.</li><li><code>cross_lines_from_quad_coordinates</code> that takes an optional named tuple and returns an optional tuple by value.</li></ul><hr><h2 id="analyzing-make-quad-coordinates" tabindex="-1"><a class="header-anchor" href="#analyzing-make-quad-coordinates"><span>Analyzing <code>make_quad_coordinates</code></span></a></h2><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">make_quad_coordinates</span><span class="token punctuation">(</span>maybe_coordinate<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Coordinate</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token class-name">Coordinate</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> maybe_coordinate<span class="token operator">?</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span></span>
<span class="line">        <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token class-name">Coordinate</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">,</span> <span class="token operator">-</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token class-name">Coordinate</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token operator">-</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>When we analyze the code be on the lookout for the following:</p><ul><li>Since the function returns a <code>Box</code> smart pointer, the assembly code allocates memory on the heap. <code>__rust_alloc</code> is used to allocate memory on the heap.</li><li>If the heap allocation fails, the function throws an exception using a special instruction (<code>ud2</code>).</li><li>Rust <code>enums</code> typically result in generating a discriminant value that is used to select the variant. Rust code generator optimizes the <code>Option&lt;Box&gt;</code> implementation by using the NULL pointer as the discriminant value.</li></ul><hr><h2 id="understanding-the-data-layout" tabindex="-1"><a class="header-anchor" href="#understanding-the-data-layout"><span>Understanding the data layout</span></a></h2><p>Understanding the assembly code will be aided by understanding the memory layout of several data types used in the code. We will encounter the following data types:</p><ul><li><code>Coordinate</code> - a named tuple with two fields.</li><li><code>Line</code> - a named tuple that contains two named tuples.</li><li><code>Box&lt;[Coordinate; 4]&gt;</code> - a Box smart pointer that contains an array of four coordinates.</li><li><code>Option&lt;Coordinate&gt;</code> - an enum that contains a named tuple.</li><li><code>Option&lt;Box&lt;[Coordinate; 4]&gt;&gt;</code> - an enum that contains a Box smart pointer that contains anarray of four coordinates.</li></ul><p>Next, we look at the memory layout of the key data types used in the code.</p><h3 id="representation-of-option" tabindex="-1"><a class="header-anchor" href="#representation-of-option"><span>Representation of Option</span></a></h3><p>The memory layout of the <code>Option&lt;Coordinate&gt;</code> type is shown below. Byte offset 0 is the discriminant used to distinguish between the variants <code>Some</code> and <code>None</code>. The <code>Coordinate</code> tuple is stored in the next two entries.</p><table><thead><tr><th style="text-align:left;">Byte offset</th><th style="text-align:left;"><code>None</code></th><th style="text-align:left;"><code>Some</code></th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td style="text-align:left;">Discriminator (0)</td><td style="text-align:left;">Discriminator (1)</td></tr><tr><td style="text-align:left;">8</td><td style="text-align:left;"></td><td style="text-align:left;">f64</td></tr><tr><td style="text-align:left;">16</td><td style="text-align:left;"></td><td style="text-align:left;">f64</td></tr></tbody></table><h3 id="representation-of-option-box-coordinate-4" tabindex="-1"><a class="header-anchor" href="#representation-of-option-box-coordinate-4"><span>Representation of <code>Option&lt;Box&lt;[Coordinate; 4]&gt;&gt;</code></span></a></h3><p>The memory layout of the <code>Option&lt;Box&lt;[Coordinate; 4]&gt;&gt;</code> type is shown below. There are two memory locations in the <code>Option&lt;Box&lt;[Coordinate; 4]&gt;&gt;</code> type.</p><p>The first is the pointer to the array of coordinates. The second is the array of <code>Coordinate</code> objects.</p><h3 id="option-on-the-stack" tabindex="-1"><a class="header-anchor" href="#option-on-the-stack"><span>Option on the stack</span></a></h3><p>The Rust code generator optimizes the <code>Option&lt;Box&lt;&gt;&gt;</code> type to a single pointer on the stack. The pointer works as a pointer to the array of coordinates as well as the discriminator. If the pointer is <code>NULL</code>, the <code>Option</code> variant is assumed to be <code>None</code>. A nonzero pointer indicates that the <code>Option</code> variant is <code>Some</code>.</p><table><thead><tr><th style="text-align:left;">Byte offset</th><th style="text-align:left;"><code>None</code></th><th style="text-align:left;"><code>Some</code></th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td style="text-align:left;">The Box pointer is <code>NULL</code></td><td style="text-align:left;">The Box pointer contains a valid address that points to the heap.</td></tr></tbody></table><h3 id="coordinate-4-array-on-the-heap" tabindex="-1"><a class="header-anchor" href="#coordinate-4-array-on-the-heap"><span><code>[Coordinate; 4]</code> array on the heap</span></a></h3><p>The <code>[Coordinate; 4]</code> array is allocated on the heap. The heap pointer is stored in the Box pointer. The Box pointer points to the memory shown below. The array contains four Coordinate objects.</p><table><thead><tr><th style="text-align:left;">Byte offset</th><th style="text-align:left;">Content</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td style="text-align:left;">Coordinate</td></tr><tr><td style="text-align:left;">16</td><td style="text-align:left;">Coordinate</td></tr><tr><td style="text-align:left;">32</td><td style="text-align:left;">Coordinate</td></tr><tr><td style="text-align:left;">48</td><td style="text-align:left;">Coordinate</td></tr></tbody></table><h3 id="ieee-754-floating-point-standard" tabindex="-1"><a class="header-anchor" href="#ieee-754-floating-point-standard"><span>IEEE 754 floating point standard</span></a></h3><p>The <code>Coordinate</code> tuple contains two <code>f64</code> fields. The <code>f64</code> type is a 64-bit floating point number. The IEEE 754 floating point standard is used to represent the floating point numbers. The standard defines the following:</p><table><thead><tr><th style="text-align:left;">Sign</th><th style="text-align:left;">Exponent</th><th style="text-align:left;">Fraction (Mantissa)</th></tr></thead><tbody><tr><td style="text-align:left;">bit 63</td><td style="text-align:left;">bit 62 to 52 Bit</td><td style="text-align:left;">51 to 0</td></tr><tr><td style="text-align:left;">1 bit</td><td style="text-align:left;">11 bits</td><td style="text-align:left;">52 bits</td></tr></tbody></table><p>The key point here is that floating point numbers use a sign bit to define the sign of the number. The sign bit is the most significant bit. We will see in the assembly code that the generated code flips the sign bit of the <code>f64</code> field to negate the number.</p><hr><h2 id="flow-chart-for-make-quad-coordinates" tabindex="-1"><a class="header-anchor" href="#flow-chart-for-make-quad-coordinates"><span>Flow chart for <code>make_quad_coordinates</code></span></a></h2><p>The flow chart for the <code>make_quad_coordinates</code> function shows how the input <code>Option</code> discriminator is checked early in the function. If the <code>Option</code> is <code>None</code>, the function returns early. If the <code>Option</code> is <code>Some</code>, the function extracts the contents of the tuple and uses the <code>Box</code> smart pointer to allocate memory on the heap. The function then returns the <code>Box</code> pointer.</p><p>Key points to note:</p><ul><li>The flow chart also shows that the function will panic if memory allocation for forming the <code>Box</code> pointer fails.</li><li>The compiler maximizes the use of vector operations. Often, the generated code is operating on two <code>f64</code> values at a time.</li><li>The function will throw an exception if <code>Box</code> allocation fails.</li><li>The compiler uses the NULL pointer as the discriminator for the <code>Option&lt;Box&gt;</code> type. No discriminator field is needed.</li></ul><figure><img src="https://eventhelix.com/rust/rust-to-assembly-arrays-option-box/option-box.svg" alt="Rust Box memory allocation and error handling" tabindex="0" loading="lazy"><figcaption>Rust Box memory allocation and error handling</figcaption></figure><hr><h2 id="assembly-code-for-make-quad-coordinates" tabindex="-1"><a class="header-anchor" href="#assembly-code-for-make-quad-coordinates"><span>Assembly code for <code>make_quad_coordinates</code></span></a></h2><p>The assembly code for the <code>make_quad_coordinates</code> function is shown below. The code is annotated with comments that explain the assembly code.</p><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line"><span class="token comment">; The address of Option&lt;Coordinate&gt; is passed in the rdi register.</span></span>
<span class="line"><span class="token comment">; The representation of Option&lt;Coordinate&gt; is shown in the table above.</span></span>
<span class="line"></span>
<span class="line">.LCPI0_0:</span>
<span class="line">        .quad   <span class="token number">0x8000000000000000</span>              <span class="token comment">; Constants used for flipping the signed bit..</span></span>
<span class="line">        .quad   <span class="token number">0x8000000000000000</span>              <span class="token comment">; ..of a 64-bit floating point number.</span></span>
<span class="line">example::make_quad_coordinates:</span>
<span class="line">        sub     rsp<span class="token punctuation">,</span> <span class="token number">24</span>                         <span class="token comment">; Reserve space for local variables.</span></span>
<span class="line">        cmp     qword ptr <span class="token punctuation">[</span>rdi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>              <span class="token comment">; Check if the discriminator is set to 0 (None case)</span></span>
<span class="line">        je      .LBB0_1                         <span class="token comment">; If the discriminator is 0, jump to the exit point.</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; üëç Processing Some case of Option</span></span>
<span class="line">        movups  xmm0<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rdi <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">]</span>     <span class="token comment">; Get the 0·µó ∞ and 1À¢·µó entry from the Coordinate tuple via a vectorized load</span></span>
<span class="line">                                                <span class="token comment">; (Note the 8-byte offset is needed to skip the discriminator)</span></span>
<span class="line">        movaps  xmmword ptr <span class="token punctuation">[</span>rsp<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm0         <span class="token comment">; Save it into the x and y local variable on the stack.</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; Requesting memory allocation for Option&lt;Box&lt;[Coordinate; 4]&gt;&gt;.</span></span>
<span class="line">        <span class="token comment">; The array has 4 entries, and each entry needs 16 bytes (for the two f64s)</span></span>
<span class="line">        <span class="token comment">; This adds up to a total of 64 bytes.</span></span>
<span class="line">        <span class="token comment">; Note that no space is needed for the Option discriminator as all 0s (NULL)</span></span>
<span class="line">        <span class="token comment">; can be used to represent the None condition. Any nonzero heap address signifies</span></span>
<span class="line">        <span class="token comment">; the Some condition.</span></span>
<span class="line"></span>
<span class="line">        mov     edi<span class="token punctuation">,</span> <span class="token number">64</span>                                 <span class="token comment">; Request 64 byte memory</span></span>
<span class="line">        mov     esi<span class="token punctuation">,</span> <span class="token number">8</span>                                  <span class="token comment">; Alignment is set to 8 bytes</span></span>
<span class="line">        call    qword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> __rust_alloc@GOTPCREL<span class="token punctuation">]</span> <span class="token comment">; Request memory allocation. The result is returned in rax.</span></span>
<span class="line">        test    rax<span class="token punctuation">,</span> rax                                <span class="token comment">; Check if the memory allocation returned an all zero address (NULL)</span></span>
<span class="line">        je      .LBB0_5                                 <span class="token comment">; If yes, jump to the out of memory error handling</span></span>
<span class="line">        movaps  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rsp<span class="token punctuation">]</span>                 <span class="token comment">; Load the x and y local variable into xmm1 (vectorized load)</span></span>
<span class="line">        movups  xmmword ptr <span class="token punctuation">[</span>rax<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1                 <span class="token comment">; Copy x and y to the heap</span></span>
<span class="line">        movaps  xmm0<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> .LCPI0_0<span class="token punctuation">]</span>      <span class="token comment">; Load the constant with the most significant bit set</span></span>
<span class="line">        xorps   xmm0<span class="token punctuation">,</span> xmm1                              <span class="token comment">; Flip the sign bit of x and y to store -x and -y in xmm0</span></span>
<span class="line">        movups  xmmword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm0            <span class="token comment">; Copy -x and -y to the heap (vectorized store)</span></span>
<span class="line">        movlps  qword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm0              <span class="token comment">; Copy -x to the heap</span></span>
<span class="line">        shufps  xmm1<span class="token punctuation">,</span> xmm1<span class="token punctuation">,</span> <span class="token number">78</span>                          <span class="token comment">; Swap the x and y values in xmm1</span></span>
<span class="line">        movups  xmmword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1            <span class="token comment">; Copy y and x to the heap</span></span>
<span class="line">        pshufd  xmm0<span class="token punctuation">,</span> xmm0<span class="token punctuation">,</span> <span class="token number">238</span>                         <span class="token comment">; Bring the -y value to the lower 64 bits of xmm0</span></span>
<span class="line">        movq    qword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">56</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm0              <span class="token comment">; Copy -y to the heap</span></span>
<span class="line">        add     rsp<span class="token punctuation">,</span> <span class="token number">24</span>                                 <span class="token comment">; Pop off the local variables from the stack</span></span>
<span class="line">        ret                                             <span class="token comment">; Return the result in rax</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; üëé Processing None case of Option</span></span>
<span class="line">        <span class="token comment">; Rust implements optimizes Option&lt;Box&gt;, the None case is signaled by an all zero (NULL)</span></span>
<span class="line">        <span class="token comment">; returned to the caller. There is no discriminator needed.</span></span>
<span class="line"></span>
<span class="line">.LBB0_1:</span>
<span class="line">        xor     eax<span class="token punctuation">,</span> eax    <span class="token comment">; Setting the lower 32 bits of rax to 0</span></span>
<span class="line">                            <span class="token comment">; Upper bits must be 0 to return an all zero rax</span></span>
<span class="line">        add     rsp<span class="token punctuation">,</span> <span class="token number">24</span>     <span class="token comment">; Pop off the local variables</span></span>
<span class="line">        ret                 <span class="token comment">; Return NULL to signal None</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; ‚ùå Exception processing (memory allocation failed)</span></span>
<span class="line">.LBB0_5:</span>
<span class="line">        mov     edi<span class="token punctuation">,</span> <span class="token number">64</span>         <span class="token comment">; Size of the failed allocation (64-bit)</span></span>
<span class="line">        mov     esi<span class="token punctuation">,</span> <span class="token number">8</span>          <span class="token comment">; Alignment of the failed allocation (8-byte)</span></span>
<span class="line">        call    qword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> alloc::alloc::handle_alloc_error@GOTPCREL<span class="token punctuation">]</span> <span class="token comment">; Call alloc error handler</span></span>
<span class="line">        ud2                     <span class="token comment">; Raise invalid opcode exception to trigger the exception handler.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="analyzing-cross-lines-from-quad-coordinates" tabindex="-1"><a class="header-anchor" href="#analyzing-cross-lines-from-quad-coordinates"><span>Analyzing cross_lines_from_quad_coordinates</span></a></h2><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">cross_lines_from_quad_coordinates</span><span class="token punctuation">(</span></span>
<span class="line">    maybe_coordinate<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Coordinate</span><span class="token operator">&gt;</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token class-name">Line</span><span class="token punctuation">,</span> <span class="token class-name">Line</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">make_quad_coordinates</span><span class="token punctuation">(</span>maybe_coordinate<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Line</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Line</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The assembly code for <code>cross_lines_from_quad_coordinates</code> really surprised us. We were expecting to see a heap allocation in the return value from the call to the <code>make_quad_coordinates</code> function. Since the <code>Box</code> was going to be consumed in the function, we were expecting to see a de-allocation of the heap memory before the function returns. What we see is a very efficient generated code that inlined the <code>make_quad_coordinates</code> and eliminated the <code>Box</code> altogether. Thus, saving a memory allocation and de-allocation.</p><p>The key points in the generated assembly code are:</p><ul><li>The compiler inlines the <code>make_quad_coordinates</code> function. This results in deep optimization of the code.</li><li>The compiler eliminates the <code>Box</code> allocation and de-allocation.</li><li>The generated code also optimizes the memory writes by joining together two 64-bit writes into a single 128-bit write.</li></ul><hr><h2 id="representation-of-option-line-line" tabindex="-1"><a class="header-anchor" href="#representation-of-option-line-line"><span>Representation of <code>Option&lt;(Line, Line)&gt;</code></span></a></h2><p>Understanding the representation of <code>Option&lt;Line,Line&gt;</code> will assist in keeping track of the flow of the assembly code. The memory layout starts with the <code>Option</code> discriminator. The value of 0 indicates the <code>None</code> case. A value of 1 indicates the <code>Some</code> case. The <code>Some</code> case is followed by the two Line structs. The <code>Line</code> struct is a tuple of two <code>Coordinate</code> structs. The <code>Coordinate</code> struct is a tuple of two <code>f64</code> values.</p><table><thead><tr><th style="text-align:left;">Byte offset</th><th style="text-align:left;"><code>None</code></th><th style="text-align:left;"><code>Some</code></th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td style="text-align:left;">Discriminator (0)</td><td style="text-align:left;">Discriminator (1)</td></tr><tr><td style="text-align:left;">8</td><td style="text-align:left;"></td><td style="text-align:left;">tuple.0 First Coordinate (x): f64</td></tr><tr><td style="text-align:left;">16</td><td style="text-align:left;"></td><td style="text-align:left;">tuple.0 First Coordinate (y): f64</td></tr><tr><td style="text-align:left;">24</td><td style="text-align:left;"></td><td style="text-align:left;">tuple.0 Second Coordinate (x): f64</td></tr><tr><td style="text-align:left;">32</td><td style="text-align:left;"></td><td style="text-align:left;">tuple.0 Second Coordinate (y): f64</td></tr><tr><td style="text-align:left;">40</td><td style="text-align:left;"></td><td style="text-align:left;">tuple.1 First Coordinate (x): f64</td></tr><tr><td style="text-align:left;">48</td><td style="text-align:left;"></td><td style="text-align:left;">tuple.1 First Coordinate (y): f64</td></tr><tr><td style="text-align:left;">56</td><td style="text-align:left;"></td><td style="text-align:left;">tuple.1 Second Coordinate (x): f64</td></tr><tr><td style="text-align:left;">64</td><td style="text-align:left;"></td><td style="text-align:left;">tuple.1 Second Coordinate (y): f64</td></tr></tbody></table><hr><h2 id="flow-chart-of-cross-lines-from-quad-coordinates" tabindex="-1"><a class="header-anchor" href="#flow-chart-of-cross-lines-from-quad-coordinates"><span>Flow chart of <code>cross_lines_from_quad_coordinates</code></span></a></h2><p>We get a glimpse of the deep optimization of the generated code by looking at the flow chart of the <code>cross_lines_from_quad_coordinates</code> function. The flow chart shows the inlined code of the <code>make_quad_coordinates</code> function. The <code>Box</code> allocation and de-allocation are eliminated. Since the <code>Box</code> is eliminated, memory allocation failure exception is impossible.</p><p>In fact, the flow chart of the <code>cross_lines_from_quad_coordinates</code> function is simpler than the flow chart of the <code>make_quad_coordinates</code> function it is supposed to call!</p><figure><img src="https://eventhelix.com/rust/rust-to-assembly-arrays-option-box/option-box-quad-coordinates.svg" alt="Example of compiler optimizing away Box" tabindex="0" loading="lazy"><figcaption>Example of compiler optimizing away Box</figcaption></figure><hr><h2 id="assembly-code-for-cross-lines-from-quad-coordinates" tabindex="-1"><a class="header-anchor" href="#assembly-code-for-cross-lines-from-quad-coordinates"><span>Assembly code for <code>cross_lines_from_quad_coordinates</code></span></a></h2><p>Examine the assembly code using the flow chart blueprint.</p><p>Key points to note in the assembly code:</p><ul><li>The <code>make_quad_coordinates</code> function is inlined.</li><li>The <code>Box</code> allocation and de-allocation are eliminated.</li><li>The function cannot throw an exception because there is no heap allocation.</li><li>The caller of <code>cross_lines_from_quad_coordinates</code> is responsible for the memory allocation of the return value.</li><li>The generated code uses vectorized instructions to operate on two <code>f64s</code> simultaneously.</li></ul><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line"><span class="token comment">; maybe_coordinate: Option&lt;Coordinate&gt; is passed in rsi</span></span>
<span class="line"><span class="token comment">; The caller passes the return struct address via rdi :Option&lt;Box&lt;[Coordinate; 4]&gt;&gt;</span></span>
<span class="line">.LCPI1_0:</span>
<span class="line">        .quad   <span class="token number">0x8000000000000000</span>            <span class="token comment">; Constants used for flipping the signed bit in...</span></span>
<span class="line">        .quad   <span class="token number">0x8000000000000000</span>          <span class="token comment">; ..of a 64-bit floating point number.</span></span>
<span class="line">example::cross_lines_from_quad_coordinates:</span>
<span class="line">        mov     rax<span class="token punctuation">,</span> rdi                    <span class="token comment">; Return address information is copied to rax</span></span>
<span class="line">        cmp     qword ptr <span class="token punctuation">[</span>rsi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>          <span class="token comment">; Check if the discriminator is set to 0 (None case)</span></span>
<span class="line">        je      .LBB1_1                     <span class="token comment">; If the discriminator is 0, jump to the exit point.</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; üëç Some variant in maybe_coordinate input</span></span>
<span class="line">        <span class="token comment">; The compiler has inlined the make_quad_coordinates function.</span></span>
<span class="line">        movups  xmm0<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rsi <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">]</span>     <span class="token comment">; Vector load x and y from the memory pointed by rsi</span></span>
<span class="line">        movaps  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> .LCPI1_0<span class="token punctuation">]</span> <span class="token comment">; Load the constant with the most significant bit set</span></span>
<span class="line">        xorps   xmm1<span class="token punctuation">,</span> xmm0 <span class="token comment">; Negate x and y by toggling the sign bit. xmm1 how contains -x and -y.</span></span>
<span class="line">        movups  xmmword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm0     <span class="token comment">; Copy x and y for the tuple.0 First Coordinate(x, y) to the heap</span></span>
<span class="line">        movups  xmmword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1    <span class="token comment">; tuple.0 Second Coordinate(x, y): Write a 128-bit word to the</span></span>
<span class="line">                                                <span class="token comment">; memory corresponding to -x and -y</span></span>
<span class="line">                                                <span class="token comment">; Note that Intel ordering will result in -x being written to</span></span>
<span class="line">                                                <span class="token comment">; rax+24 address. -y will be written to rax+32 address.</span></span>
<span class="line">        movlps  qword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1      <span class="token comment">; tuple.1 First Coordinate (x): -x written to memory.</span></span>
<span class="line">        shufps  xmm0<span class="token punctuation">,</span> xmm0<span class="token punctuation">,</span> <span class="token number">78</span>                  <span class="token comment">; Swap the x and y coordinates in xmm0</span></span>
<span class="line">        movups  xmmword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">48</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm0    <span class="token comment">; vector store y followed by x</span></span>
<span class="line">                                                <span class="token comment">; wrote tupe.1 First Coordinate (y): y written to memory.</span></span>
<span class="line">                                                <span class="token comment">; wrote tuple.1 Second Coordinate (x): x written to memory.</span></span>
<span class="line"></span>
<span class="line">        pshufd  xmm0<span class="token punctuation">,</span> xmm1<span class="token punctuation">,</span> <span class="token number">238</span>                 <span class="token comment">; Bring -y to the lower 64-bits of xmm0</span></span>
<span class="line">        movq    qword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm0      <span class="token comment">; tuple.1 Second Coordinate (y): -y written to memory.</span></span>
<span class="line">        mov     ecx<span class="token punctuation">,</span> <span class="token number">1</span>                          <span class="token comment">; Set the discriminator for Some (32 bit write)</span></span>
<span class="line">        mov     qword ptr <span class="token punctuation">[</span>rax<span class="token punctuation">]</span><span class="token punctuation">,</span> rcx            <span class="token comment">; Write the discriminator to memory </span></span>
<span class="line">                                                <span class="token comment">; (rax is the 64-bit register that contains ecx)</span></span>
<span class="line">        ret                                     <span class="token comment">; Return the result in rax</span></span>
<span class="line"></span>
<span class="line">.LBB1_1:</span>
<span class="line">        <span class="token comment">; üëé None variant in maybe_coordinate input</span></span>
<span class="line">        xor     ecx<span class="token punctuation">,</span> ecx                        <span class="token comment">; None case (Discriminator is set to 0)</span></span>
<span class="line">        mov     qword ptr <span class="token punctuation">[</span>rax<span class="token punctuation">]</span><span class="token punctuation">,</span> rcx            <span class="token comment">; Write the None discriminator</span></span>
<span class="line">        ret                                     <span class="token comment">; Return the result in rax</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="key-takeaways" tabindex="-1"><a class="header-anchor" href="#key-takeaways"><span>Key takeaways</span></a></h2><ul><li>The Rust compiler uses vector operations to perform multiple operations in a single instruction.</li><li>Rust&#39;s inlining of functions is very deep and can eliminate expensive heap allocations. <ul><li>The inlining of functions works for functions in other crates as well.</li></ul></li><li><code>Option</code> containing a <code>Box</code> is represented as a single 64-bit pointer. The <code>NULL</code> pointer indicates the <code>None</code> case. A non-NULL pointer indicates the <code>Some</code> case.</li><li>No discriminators are used to represent the <code>Option</code> type.</li><li>Rust functions throw exceptions on memory allocation failure. One needs to be careful when using smart pointers and types that allocate memory from the heap.</li></ul><hr><h2 id="view-in-the-compiler-explorer" tabindex="-1"><a class="header-anchor" href="#view-in-the-compiler-explorer"><span>View in the Compiler Explorer</span></a></h2><p>The <a href="https://godbolt.org/z/fbT5hGrsz" target="_blank" rel="noopener noreferrer">Compiler Explorer</a> is a great tool for viewing the generated assembly code. The following link shows the assembly code generated for the <code>make_quad_coordinates</code> and <code>cross_lines_from_quad_coordinates</code> functions.</p><p>You can hover over the opcodes in the assembly code to learn about the individual instructions. Two interesting instructions are:</p><ul><li><code>shufps</code> is a vectorized instruction that can shuffle the contents of a move based on two-bit control fields.</li><li><code>pshufd</code> also supports fancy shuffling options that are explained in a <a href="https://reverseengineering.stackexchange.com/questions/20338/how-do-the-pshuflw-and-pshufd-instructions-work" target="_blank" rel="noopener noreferrer">stack exchange article</a>.</li></ul><hr>`,74);function x(i,_){const a=o("router-link"),l=o("VPCard");return h(),c("div",null,[n("h1",f,[n("a",b,[n("span",null,r(i.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),n("nav",v,[n("ul",null,[n("li",null,[s(a,{to:"#code-example"},{default:e(()=>[t("Code example")]),_:1})]),n("li",null,[s(a,{to:"#analyzing-make-quad-coordinates"},{default:e(()=>[t("Analyzing make_quad_coordinates")]),_:1})]),n("li",null,[s(a,{to:"#understanding-the-data-layout"},{default:e(()=>[t("Understanding the data layout")]),_:1}),n("ul",null,[n("li",null,[s(a,{to:"#representation-of-option"},{default:e(()=>[t("Representation of Option")]),_:1})]),n("li",null,[s(a,{to:"#representation-of-option-box-coordinate-4"},{default:e(()=>[t("Representation of Option<Box<[Coordinate; 4]>>")]),_:1})]),n("li",null,[s(a,{to:"#option-on-the-stack"},{default:e(()=>[t("Option on the stack")]),_:1})]),n("li",null,[s(a,{to:"#coordinate-4-array-on-the-heap"},{default:e(()=>[t("[Coordinate; 4] array on the heap")]),_:1})]),n("li",null,[s(a,{to:"#ieee-754-floating-point-standard"},{default:e(()=>[t("IEEE 754 floating point standard")]),_:1})])])]),n("li",null,[s(a,{to:"#flow-chart-for-make-quad-coordinates"},{default:e(()=>[t("Flow chart for make_quad_coordinates")]),_:1})]),n("li",null,[s(a,{to:"#assembly-code-for-make-quad-coordinates"},{default:e(()=>[t("Assembly code for make_quad_coordinates")]),_:1})]),n("li",null,[s(a,{to:"#analyzing-cross-lines-from-quad-coordinates"},{default:e(()=>[t("Analyzing cross_lines_from_quad_coordinates")]),_:1})]),n("li",null,[s(a,{to:"#representation-of-option-line-line"},{default:e(()=>[t("Representation of Option<(Line, Line)>")]),_:1})]),n("li",null,[s(a,{to:"#flow-chart-of-cross-lines-from-quad-coordinates"},{default:e(()=>[t("Flow chart of cross_lines_from_quad_coordinates")]),_:1})]),n("li",null,[s(a,{to:"#assembly-code-for-cross-lines-from-quad-coordinates"},{default:e(()=>[t("Assembly code for cross_lines_from_quad_coordinates")]),_:1})]),n("li",null,[s(a,{to:"#key-takeaways"},{default:e(()=>[t("Key takeaways")]),_:1})]),n("li",null,[s(a,{to:"#view-in-the-compiler-explorer"},{default:e(()=>[t("View in the Compiler Explorer")]),_:1})])])]),y,s(l,d(u({title:"Mapping Arrays, Tuples, Box and Option to assembly",desc:"Learn how Arrays, Tuples, Box and Option are represented in memory. Also understand the generated assembly code for these types.",link:"https://eventhelix.com/rust/rust-to-assembly-arrays-option-box",logo:"https://eventhelix.com/images/EventHelix-white-rounded-bg-blue.png",background:"rgba(250,250,250,0.2)"})),null,16),g])}const C=p(k,[["render",x],["__file","mapping-arrays-tuples-box-and-option-to-assembly.html.vue"]]),T=JSON.parse('{"path":"/rust/eventhelix-rust-to-assembly/mapping-arrays-tuples-box-and-option-to-assembly.html","title":"Mapping Arrays, Tuples, Box and Option to assembly","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Mapping Arrays, Tuples, Box and Option to assembly","description":"Rust to Assembly > Mapping Arrays, Tuples, Box and Option to assembly","category":["Rust"],"tag":["crashcourse","digitalocean","rust","rs","wasm","assembly"],"head":[[{"meta":null},{"property":"og:title","content":"Rust to Assembly > Mapping Arrays, Tuples, Box and Option to assembly"},{"property":"og:description","content":"Mapping Arrays, Tuples, Box and Option to assembly"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/rs-eventhelix-rust-to-assembly/mapping-arrays-tuples-box-and-option-to-assembly.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/rust/eventhelix-rust-to-assembly/mapping-arrays-tuples-box-and-option-to-assembly.html"}],["meta",{"property":"og:site_name","content":"ü•ÅCrashcourse"}],["meta",{"property":"og:title","content":"Mapping Arrays, Tuples, Box and Option to assembly"}],["meta",{"property":"og:description","content":"Rust to Assembly > Mapping Arrays, Tuples, Box and Option to assembly"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://eventhelix.com/rust/rust-to-assembly-arrays-option-box/option-box.svg"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"digitalocean"}],["meta",{"property":"article:tag","content":"rust"}],["meta",{"property":"article:tag","content":"rs"}],["meta",{"property":"article:tag","content":"wasm"}],["meta",{"property":"article:tag","content":"assembly"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Mapping Arrays, Tuples, Box and Option to assembly\\",\\"image\\":[\\"https://eventhelix.com/rust/rust-to-assembly-arrays-option-box/option-box.svg\\",\\"https://eventhelix.com/rust/rust-to-assembly-arrays-option-box/option-box-quad-coordinates.svg\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Code example","slug":"code-example","link":"#code-example","children":[]},{"level":2,"title":"Analyzing make_quad_coordinates","slug":"analyzing-make-quad-coordinates","link":"#analyzing-make-quad-coordinates","children":[]},{"level":2,"title":"Understanding the data layout","slug":"understanding-the-data-layout","link":"#understanding-the-data-layout","children":[{"level":3,"title":"Representation of Option","slug":"representation-of-option","link":"#representation-of-option","children":[]},{"level":3,"title":"Representation of Option<Box<[Coordinate; 4]>>","slug":"representation-of-option-box-coordinate-4","link":"#representation-of-option-box-coordinate-4","children":[]},{"level":3,"title":"Option on the stack","slug":"option-on-the-stack","link":"#option-on-the-stack","children":[]},{"level":3,"title":"[Coordinate; 4] array on the heap","slug":"coordinate-4-array-on-the-heap","link":"#coordinate-4-array-on-the-heap","children":[]},{"level":3,"title":"IEEE 754 floating point standard","slug":"ieee-754-floating-point-standard","link":"#ieee-754-floating-point-standard","children":[]}]},{"level":2,"title":"Flow chart for make_quad_coordinates","slug":"flow-chart-for-make-quad-coordinates","link":"#flow-chart-for-make-quad-coordinates","children":[]},{"level":2,"title":"Assembly code for make_quad_coordinates","slug":"assembly-code-for-make-quad-coordinates","link":"#assembly-code-for-make-quad-coordinates","children":[]},{"level":2,"title":"Analyzing cross_lines_from_quad_coordinates","slug":"analyzing-cross-lines-from-quad-coordinates","link":"#analyzing-cross-lines-from-quad-coordinates","children":[]},{"level":2,"title":"Representation of Option<(Line, Line)>","slug":"representation-of-option-line-line","link":"#representation-of-option-line-line","children":[]},{"level":2,"title":"Flow chart of cross_lines_from_quad_coordinates","slug":"flow-chart-of-cross-lines-from-quad-coordinates","link":"#flow-chart-of-cross-lines-from-quad-coordinates","children":[]},{"level":2,"title":"Assembly code for cross_lines_from_quad_coordinates","slug":"assembly-code-for-cross-lines-from-quad-coordinates","link":"#assembly-code-for-cross-lines-from-quad-coordinates","children":[]},{"level":2,"title":"Key takeaways","slug":"key-takeaways","link":"#key-takeaways","children":[]},{"level":2,"title":"View in the Compiler Explorer","slug":"view-in-the-compiler-explorer","link":"#view-in-the-compiler-explorer","children":[]}],"git":{"createdTime":1703642364000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":6}]},"readingTime":{"minutes":9.34,"words":2803},"filePathRelative":"rust/eventhelix-rust-to-assembly/mapping-arrays-tuples-box-and-option-to-assembly.md","localizedDate":"2023ÎÖÑ 12Ïõî 27Ïùº","excerpt":"\\n\\n<hr>\\n"}');export{C as comp,T as data};
