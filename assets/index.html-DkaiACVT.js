import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,a as e,t as d,b as t,w as a,n as m,g as u,e as s,r as l,o as g,d as r}from"./app-U_bew1in.js";const f={},k={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},b={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},_={class:"table-of-contents"},y=e("hr",null,null,-1),v=s('<div class="hint-container info"><p class="hint-container-title">Info</p><p>This is the Megaparsec tutorial which originally was written as a chapter for the <a href="https://intermediatehaskell.com/" target="_blank" rel="noopener noreferrer">Intermediate Haskell</a> book. Due to lack of progress with the book in the last year, other authors agreed to let me publish the text as a standalone tutorial so that people can benefit at least from this part of our work.</p></div><hr><h2 id="table-of-contents" tabindex="-1"><a class="header-anchor" href="#table-of-contents"><span>Table of Contents</span></a></h2>',3),w=s('<p>The toy parser combinators developed in chapter â€œAn Example: Writing Your Own Parser Combinatorsâ€ are not suitable for real-world use, so letâ€™s continue by taking a look at the libraries in the Haskell ecosystem that solve the same problem, and note various trade-offs they make:</p><ul><li><p><a href="https://hackage.haskell.org/package/parsec" target="_blank" rel="noopener noreferrer"><code>parsec</code></a> has been the â€œdefaultâ€ parsing library in Haskell for a long time. The library is said to be focused on quality of error messages. It however does not have good test coverage and is currently in maintenance mode.</p></li><li><p><a href="https://hackage.haskell.org/package/attoparsec" target="_blank" rel="noopener noreferrer"><code>attoparsec</code></a> is a robust, fast parsing library with focus on performance. It is the only library from this list that has full support for incremental parsing. Its downsides are poor quality of error messages, inability to be used as a monad transformer, and limited set of types that can be used as input stream.</p></li><li><p><a href="https://hackage.haskell.org/package/trifecta" target="_blank" rel="noopener noreferrer"><code>trifecta</code></a> features good error messages but is under-documented and hard to figure out. It can parse <code>String</code> and <code>ByteString</code> out-of-the-box, but not <code>Text</code>.</p></li><li><p><a href="https://hackage.haskell.org/package/megaparsec" target="_blank" rel="noopener noreferrer"><code>megaparsec</code></a> is a fork of <code>parsec</code> that has been actively developed in the last few years. The current version tries to find a nice balance between speed, flexibility, and quality of parse errors. As an unofficial successor of <code>parsec</code>, it stays conventional and immediately familiar for users who have used that library or who have read <code>parsec</code> tutorials.</p></li></ul><p>It would be impractical to try to cover all these libraries, and so we will focus on <code>megaparsec</code>. More precisely, we are going to cover the version 9, which by the time this book is published will probably have replaced the older versions almost everywhere.</p><hr>',4);function x(n,M){const i=l("router-link"),c=l("VPCard"),o=l("RouteLink");return g(),h("div",null,[e("h1",k,[e("a",b,[e("span",null,d(n.$frontmatter.title)+" ê´€ë ¨",1)])]),e("nav",_,[e("ul",null,[e("li",null,[t(i,{to:"#table-of-contents"},{default:a(()=>[r("Table of Contents")]),_:1})])])]),y,t(c,m(u({title:"Megaparsec tutorial",desc:"Mark Karpov > Megaparsec tutorial",link:"https://markkarpov.com/tutorial/megaparsec.html",logo:"https://markkarpov.com/static/img/site-icon.png",background:"rgba(86,86,125,0.2)"})),null,16),v,e("ul",null,[e("li",null,[t(o,{to:"/haskell/megaparsec/01.html"},{default:a(()=>[r("01. ParsecT and Parsec monads")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/02.html"},{default:a(()=>[r("02. Character and binary streams")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/03.html"},{default:a(()=>[r("03. Monadic and applicative syntax")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/04.html"},{default:a(()=>[r("04. Forcing consumption of input with eof")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/05.html"},{default:a(()=>[r("05. Working with alternatives")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/06.html"},{default:a(()=>[r("06. Controlling backtracking with try")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/07.html"},{default:a(()=>[r("07. Debugging parsers")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/08.html"},{default:a(()=>[r("08. Labeling and hiding things")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/09.html"},{default:a(()=>[r("09. Running a parser")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/10.html"},{default:a(()=>[r("10. The MonadParsec type class")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/11.html"},{default:a(()=>[r("11. Lexing")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/12.html"},{default:a(()=>[r("12. notFollowedBy and lookAhead")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/13.html"},{default:a(()=>[r("13. Parsing expressions")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/14.html"},{default:a(()=>[r("14. Indentation-sensitive parsing")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/15.html"},{default:a(()=>[r("15. Writing efficient parsers")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/16.html"},{default:a(()=>[r("16. Parse errors")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/17.html"},{default:a(()=>[r("17. Testing Megaparsec parsers")]),_:1})]),e("li",null,[t(o,{to:"/haskell/megaparsec/18.html"},{default:a(()=>[r("18. Working with custom input streams")]),_:1})])]),w])}const P=p(f,[["render",x],["__file","index.html.vue"]]),R=JSON.parse('{"path":"/haskell/megaparsec/","title":"Megaparsec tutorial","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Megaparsec tutorial","description":"Megaparsec tutorial","icon":"iconfont icon-haskell","category":["Haskell"],"tag":["crashcourse","haskell","parsec","attoparsec","trifecta"],"head":[[{"meta":null},{"property":"og:title","content":"ğŸ‘Megaparsec tutorial"},{"property":"og:description","content":"ğŸ‘Megaparsec tutorial"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/haskell/megaparsec/"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/haskell/megaparsec/"}],["meta",{"property":"og:site_name","content":"ğŸ¥Crashcourse"}],["meta",{"property":"og:title","content":"Megaparsec tutorial"}],["meta",{"property":"og:description","content":"Megaparsec tutorial"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"haskell"}],["meta",{"property":"article:tag","content":"parsec"}],["meta",{"property":"article:tag","content":"attoparsec"}],["meta",{"property":"article:tag","content":"trifecta"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Megaparsec tutorial\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Table of Contents","slug":"table-of-contents","link":"#table-of-contents","children":[]}],"git":{"createdTime":1709471553000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":5}]},"readingTime":{"minutes":1.68,"words":504},"filePathRelative":"haskell/megaparsec/README.md","localizedDate":"2024ë…„ 3ì›” 3ì¼","excerpt":"\\n\\n<hr>\\n"}');export{P as comp,R as data};
