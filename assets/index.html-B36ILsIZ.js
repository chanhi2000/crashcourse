import{_ as h}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as m,a as e,t as c,b as t,w as a,n as p,g as d,e as u,r as i,o as g,d as l}from"./app-U_bew1in.js";const k={},f={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},_={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},y={class:"table-of-contents"},b=e("hr",null,null,-1),v=e("hr",null,null,-1),T=u('<p>The tutorial aims to introduce the reader to <em>Template Haskell</em> (TH)‚Äîthe language extension that adds meta-programming capabilities to the Haskell language. Here I assume some familiarly with Haskell, perhaps beginner or intermediate level, although these terms are rather nebulous and subjective. To express the prerequisites in a more tangible form: if you know what a monad is, you should probably be OK.</p><p>TH has the reputation of being an expert-level topic that mere mortals are not prepared to comprehend. I don‚Äôt think this is so. The ideas behind TH are simple and make sense, while specific details can be always looked up in the Haddocks.</p><p>The tutorial cannot possibly cover every use of TH, and so it is structured in such a way so we only get to see the most common, conventional, and benign uses of this GHC feature.</p><hr><h2 id="motivation" tabindex="-1"><a class="header-anchor" href="#motivation"><span>Motivation</span></a></h2><p>One of the main difficulties with TH is perhaps deciding whether it is the best solution to a problem at hand. Writing code that generates code is generally considered an indication that the tools of expression provided by the language and/or programmer‚Äôs imagination have failed to address a particular problem and meta-programming is used as a last resort to get things done. True or not, TH is quite popular and so knowing your way around it is a valuable skill that can be used to do things that often cannot be achieved otherwise.</p><p>Let‚Äôs list some uses of TH:</p><ul><li><em>Automatic deriving of type class instances</em> is still perhaps the most common use case for TH. Even though the same problem can often be <a href="https://markkarpov.com/tutorial/generics" target="_blank" rel="noopener noreferrer">addressed by generics</a>, they are known to make compilation times longer (compared to TH-based solutions), so TH is still the preferred method of automatic instance derivation in libraries like <code>aeson</code> and <code>lens</code>.</li><li><em>Creation of TH DSLs</em> that are integrated into systems built in Haskell. Examples of such DLSs are the language for model declaration used in <a href="https://hackage.haskell.org/package/persistent" target="_blank" rel="noopener noreferrer">persistent</a>, and various other mini-languages used in the <a href="https://hackage.haskell.org/package/yesod" target="_blank" rel="noopener noreferrer">yesod</a> web framework.</li><li><em>Compile-time construction of values of refined types</em> that turns invalid inputs into compilation failures.</li><li><em>Compile-time loading and processing of data from external files</em>, which is very useful sometimes. Even though this involves running <code>IO</code> during compilation, it‚Äôs a relatively innocent use case of that dangerous feature.</li></ul><p>Reasons not to use TH:</p><p>TH helpers are often viewed as black boxes that do ‚Äúmagic‚Äù. It is not clear at all what a thing of the type Q [Dec] does, it might do anything (we will see that any code that generates declarations has the same Q [Dec] type, no matter what sort of declarations it generates). Documentation becomes the main source of information about semantics of TH code.</p><p>TH imposes restrictions on where the user should define TH functions themselves and sometimes also how to order definitions in files where TH functions are used.</p>',11);function H(n,w){const s=i("router-link"),r=i("VPCard"),o=i("RouteLink");return g(),m("div",null,[e("h1",f,[e("a",_,[e("span",null,c(n.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),e("nav",y,[e("ul",null,[e("li",null,[t(s,{to:"#motivation"},{default:a(()=>[l("Motivation")]),_:1})])])]),b,t(r,p(d({title:"Template Haskell tutorial",desc:"Mark Karpov > Template Haskell tutorial",link:"https://markkarpov.com/tutorial/th",logo:"https://markkarpov.com/static/img/site-icon.png",background:"rgba(86,86,125,0.2)"})),null,16),v,e("ul",null,[e("li",null,[t(o,{to:"/haskell/template-haskell/01.html"},{default:a(()=>[l("01. The Q monad")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/02.html"},{default:a(()=>[l("02. Splicing")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/03.html"},{default:a(()=>[l("03. Limitations of TH")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/04.html"},{default:a(()=>[l("04. Quotation")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/05.html"},{default:a(()=>[l("05. Typed expressions")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/06.html"},{default:a(()=>[l("06. A few words about runQ")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/07.html"},{default:a(()=>[l("07. Names")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/08.html"},{default:a(()=>[l("08. Retrieving information about things")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/09.html"},{default:a(()=>[l("09. Example 1: instance generation")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/10.html"},{default:a(()=>[l("10. Viewing the generated code")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/11.html"},{default:a(()=>[l("11. Lifting Haskell values into TH expressions")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/12.html"},{default:a(()=>[l("12. Example 2: creating refined values at compile time")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/13.html"},{default:a(()=>[l("13. Running IO in Q")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/14.html"},{default:a(()=>[l("14. Example 3: the file-embed package")]),_:1})]),e("li",null,[t(o,{to:"/haskell/template-haskell/15.html"},{default:a(()=>[l("15. Conclusion")]),_:1})])]),T])}const C=h(k,[["render",H],["__file","index.html.vue"]]),E=JSON.parse('{"path":"/haskell/template-haskell/","title":"Template Haskell tutorial","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Template Haskell tutorial","description":"Template Haskell tutorial","icon":"iconfont icon-haskell","category":["Haskell"],"tag":["crashcourse","haskell","parsec","attoparsec","trifecta"],"head":[[{"meta":null},{"property":"og:title","content":"üêëTemplate Haskell tutorial"},{"property":"og:description","content":"üêëTemplate Haskell tutorial"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/haskell/template-haskell/"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/haskell/template-haskell/"}],["meta",{"property":"og:site_name","content":"ü•ÅCrashcourse"}],["meta",{"property":"og:title","content":"Template Haskell tutorial"}],["meta",{"property":"og:description","content":"Template Haskell tutorial"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"haskell"}],["meta",{"property":"article:tag","content":"parsec"}],["meta",{"property":"article:tag","content":"attoparsec"}],["meta",{"property":"article:tag","content":"trifecta"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Template Haskell tutorial\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Motivation","slug":"motivation","link":"#motivation","children":[]}],"git":{"createdTime":1709471553000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":4}]},"readingTime":{"minutes":2.17,"words":650},"filePathRelative":"haskell/template-haskell/README.md","localizedDate":"2024ÎÖÑ 3Ïõî 3Ïùº","excerpt":"\\n\\n<hr>\\n"}');export{C as comp,E as data};
