import{_ as h}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as g,a as e,t as w,b as n,w as i,n as r,g as l,d as t,e as u,r as p,o as m}from"./app-U_bew1in.js";const b={},y={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},f={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},k={class:"table-of-contents"},v=e("hr",null,null,-1),_=u('<h2 id="project-18-part-one" tabindex="-1"><a class="header-anchor" href="#project-18-part-one"><span>Project 18, part one</span></a></h2><p>Thomas Fuchs once said, ‚Äúthe best error message is the one that never shows up.‚Äù Of course, <em>getting</em> to that point is easier said than done ‚Äì even in just your progress in this course so far you‚Äôve almost certainly hit 50 or more bugs in your code, and had to figure out the problem then resolve it.</p><p>In this small but important technique project we‚Äôre going to look at a few different ways of helping you identify problems in your code. Even though this is an important skill, I waited until now to show it to you because it‚Äôs important you first feel the problem acutely ‚Äì you‚Äôve hit bugs, and you‚Äôve had to work hard to solve them. But now you‚Äôve done that, you should be able to appreciate these debugging tips all the more!</p><p><strong>Today you have five short topics to work through, and you‚Äôll learn about <code>assert()</code>, breakpoints, view debugging, and more.</strong></p><h3 id="setting-up" tabindex="-1"><a class="header-anchor" href="#setting-up"><span>Setting up</span></a></h3>',5),x={class:"hint-container details"},D=e("summary",null,"Setting up",-1),T=e("p",null,"Debugging is the act of removing mistakes from your apps, so in some respects programming is the act of putting bugs into your apps. What‚Äôs more, there‚Äôs a famous quote that should strike terror into your heart: ‚ÄúDebugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.‚Äù",-1),S=e("p",null,"Of course, the truth is that we‚Äôre not able to write code ‚Äúas cleverly as possible‚Äù ‚Äì we all just muddle through and do our best. Debugging, then, is inevitable: even the best of us writes software with mistakes in, and it‚Äôs a hugely important skill to be able to find and fix those mistakes as efficiently as possible.",-1),j=e("p",null,"In this project we‚Äôll be looking at several different debugging techniques, all of which are useful. I‚Äôve arranged them easy to hard, so you can get started immediately and work your way forward as your skills improve.",-1),q=e("p",null,"Remember: there is no learning without struggle. Every time you make a mistake coding, you‚Äôll be forced to debug it, and in doing so your coding skills will improve as will your debugging skills. So: don‚Äôt be annoyed when you screw up ‚Äì it benefits you in the long term!",-1),I=e("p",null,"To follow along, please create a new Single View App project named Project18.",-1),V=e("h3",{id:"basic-swift-debugging-using-print",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#basic-swift-debugging-using-print"},[e("span",null,[t("Basic Swift debugging using "),e("code",null,"print()")])])],-1),B={class:"hint-container details"},X=e("summary",null,"Basic Swift debugging using print()",-1),C=u(`<p>We&#39;re going to start with the absolute easiest debugging technique, which is the <code>print()</code> function. This prints a message into the Xcode debug console that can say anything you want, because users won&#39;t see it in the UI. The &quot;scattershot&quot; approach to bug fixing is to litter your code with calls to <code>print()</code> then follow the messages to see what&#39;s going on.</p><p>You&#39;ll meet lots of people telling you how bad this is, but the truth is it&#39;s the debugging method everyone starts with ‚Äì it&#39;s easy, it&#39;s natural, and it often gives you enough information to solve your problem. Use it with Swift&#39;s string interpolation to see the contents of your variables when your app is running.</p><p>We‚Äôve used <code>print()</code> several times already, always in its most basic form:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;I&#39;m inside the viewDidLoad() method!&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>By adding calls like that to your various methods, you can see exactly how your program flowed.</p><p>However, <code>print()</code> is actually a bit more complicated behind the scenes. For example, you can actually pass it lots of values at the same time, and it will print them all:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That makes <code>print()</code> a variadic function, which you learned about previously. Here, though, it‚Äôs worth adding that <code>print()</code>‚Äôs variadic nature becomes much more useful when you use its optional extra parameters: <code>separator</code> and <code>terminator</code>.</p><p>The first of these, <code>separator</code>, lets you provide a string that should be placed between every item in the <code>print()</code> call. Try running this code:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> separator<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;-&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That should print ‚Äú1-2-3-4-5‚Äù, because the <code>separator</code> parameter is used to split up each item passed into <code>print()</code>.</p><p>The second optional parameter, <code>terminator</code>, is what should be placed after the final item. It‚Äôs <code>\\n</code> by default, which you should remember means ‚Äúline break‚Äù. If you don‚Äôt want <code>print()</code> to insert a line break after every call, just write this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Some message&quot;</span></span><span class="token punctuation">,</span> terminator<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Notice how you don‚Äôt need to specify <code>separator</code> if you don‚Äôt want to.</p>`,14),P=e("h3",{id:"debugging-with-assert",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#debugging-with-assert"},[e("span",null,[t("Debugging with "),e("code",null,"assert()")])])],-1),F={class:"hint-container details"},A=e("summary",null,"Debugging with assert()",-1),N=u(`<p>One level up from <code>print()</code> are assertions, which are debug-only checks that will force your app to crash if a specific condition isn&#39;t true.</p><p>On the surface, that sounds terrible: why would you want your app to crash? There are two reasons. First, sometimes making your app crash is the Least Bad Option: if something has gone catastrophically wrong ‚Äì if some fundamentally important file is not where it should be ‚Äì then it may be the case that continuing your app will cause irreparable harm to user data, in which case crashing, while a bad result, is better than losing data.</p><p>Second, these assertion crashes only happen while you‚Äôre debugging. When you build a release version of your app ‚Äì <em>i.e.</em>, when you ship your app to the App Store ‚Äì Xcode automatically disables your assertions so they won‚Äôt reach your users. This means you can set up an extremely strict environment while you‚Äôre developing, ensuring that all values are present and correct, without causing problems for real users.</p><p>Here&#39;s a very basic example:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Maths failure!&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Maths failure!&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>As you can see <code>assert()</code> takes two parameters: something to check, and a message to print out of the check fails. If the check evaluates to false, your app will be forced to crash because you know it&#39;s not in a safe state, and you&#39;ll see the error message in the debug console. You can ‚Äì and should! ‚Äì add these assertions liberally to your code, because they help guarantee that your code‚Äôs state is what you think it is.</p><p>The advantage to assertions is that their check code is never executed in a live app, so your users are never aware of their presence. This is different from <code>print()</code>, which would remain in your code if you shipped it, albeit mostly invisible. In fact, because calls to <code>assert()</code> are ignored in release builds of your app, you can do complex checks:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">myReallySlowMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;The slow method returned false, which is a bad thing!&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That <code>myReallySlowMethod()</code> call will execute only while you‚Äôre running test builds ‚Äì that code will be removed entirely when you build for the App Store.</p><p>So: assertions are like running your code in strict mode. If your app works great with assertions on ‚Äì things that literally make your app crash if things are wrong ‚Äì then it will work even better in release mode.</p>`,10),O=e("h3",{id:"debugging-with-breakpoints",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#debugging-with-breakpoints"},[e("span",null,"Debugging with breakpoints")])],-1),L={class:"hint-container details"},R=e("summary",null,"Debugging with breakpoints",-1),W=u(`<p>It‚Äôs time to start using that Project18 project you made, because we‚Äôre about to look at breakpoints. These are easy to use initially, but have a lot of hidden complexity if you want to get more advanced.</p><p>Let&#39;s start small, with a simple loop that prints numbers from 1 to 100. Add this to <code>viewDidLoa</code>d()\`\`:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span> <span class="token operator">...</span> <span class="token number">100</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Got number </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">i</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If we wanted to see exactly what our program state was at the time we call the <code>print()</code> function, look to the left of where you&#39;ve been typing and you&#39;ll see the line number markers. Click on the line number where <code>print()</code> is, and a blue marker will appear to signal that a breakpoint has been placed. This means that execution of your code will stop when that line is reached, and you have the opportunity to inspect your app‚Äôs internal state to see what values everything has.</p>`,4),E=e("code",null,"[Delete Breakpoint]",-1),M=e("strong",null,"No line numbers?",-1),H=e("code",null,"[Preferences]",-1),Y=e("code",null,"[Text Editing]",-1),J=u("<p>With that breakpoint in place, Xcode will pause execution when it&#39;s reached and show you the values of all your variables. Try running it now, and you should see your app paused, with a light green marker on the line of code that is about to be executed. At the bottom of the Xcode window you should see Xcode telling you that <code>i</code> currently has a value of 1. That&#39;s because it paused as soon as this line is reached, which is the very first iteration of our loop.</p><p>From here, you can carry on execution by pressing F6, but you may need to use Fn+F6 because the function keys are often mapped to actions on Macs. This shortcut is called Step Over and will tell Xcode to advance code execution by one line. You can walk through the loop in its entirety by pressing F6 again and again, but there&#39;s another command called Continue (<kbd>Ctrl</kbd>+<kbd>Cmd</kbd>+<kbd>Y</kbd>) that means &quot;continue executing my program until you hit another breakpoint.&quot;</p><p>When your program is paused, you&#39;ll see something useful on the left of Xcode&#39;s window: a <em>back trace</em> that shows you all the threads in your program and what they are executing. So if you find a bug somewhere in method <code>d()</code>, this back trace will show you that <code>d()</code> was called by <code>c()</code>, which was called by <code>b()</code>, which in turn was called by <code>a()</code> ‚Äì it effectively shows you the events leading up to your problem, which is invaluable when trying to spot bugs.</p>",3),K=e("code",null,"[View > Debug Area > Activate Console]",-1),U=e("code",null,"p i",-1),Z=e("code",null,"i",-1),G=e("p",null,[t("While your app is paused, here‚Äôs one more neat trick that few people know about: that light green arrow that shows your current execution position can be "),e("em",null,"moved"),t(". Just click and drag it somewhere else to have execution pick up from there ‚Äì although Xcode will warn you that it might have unexpected results, so tread carefully!")],-1),z=e("p",null,"Breakpoints can do two more clever things, but for some reason both of them aren't used nearly enough. The first is that you can make breakpoints conditional, meaning that they will pause execution of your program only if the condition is matched. Right now, our breakpoint will stop execution every time our loop goes around, but what if we wanted it to stop only every 10 times?",-1),Q=e("code",null,"i % 10 == 0",-1),$=e("code",null,"i",-1),ee=e("code",null,"[Automatically continue]",-1),te=e("p",null,`The second clever thing that breakpoints can do is be automatically triggered when an exception is thrown. Exceptions are errors that aren't handled, and will cause your code to crash. With breakpoints, you can say "pause execution as soon as an exception is thrown," so that you can examine your program state and see what the problem is.`,-1),ne=e("kbd",null,"Cmd",-1),se=e("kbd",null,"8",-1),ae=e("code",null,"[+]",-1),oe=e("code",null,"[Exception Breakpoint]",-1),ie=e("h3",{id:"view-debugging",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#view-debugging"},[e("span",null,"View debugging")])],-1),re={class:"hint-container details"},le=e("summary",null,"View debugging",-1),ce=e("p",null,"The last debugging technique I want to look at is view debugging, Xcode comes with a marvelous feature called Capture View Hierarchy, and when it's used your see your current view layout inside Xcode with thin gray lines around all the views.",-1),ue=e("code",null,"[View Debugging > Capture View Hierarchy]",-1),pe=e("p",null,"Here‚Äôs the clever part: if you click and drag inside the hierarchy display, you'll see you're actually viewing a 3D representation of your view, which means you can look behind the layers to see what else is there. The hierarchy automatically puts some depth between each of its views, so they appear to pop off the canvas as you rotate them.",-1),de=e("p",null,"This debug mode is perfect for times when you know you've placed your view but for some reason can't see it ‚Äì often you'll find the view is behind something else by accident.",-1),he=e("hr",null,null,-1);function ge(d,we){const a=p("router-link"),o=p("VPCard"),c=p("VidStack"),s=p("FontIcon");return m(),g("div",null,[e("h1",y,[e("a",f,[e("span",null,w(d.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),e("nav",k,[e("ul",null,[e("li",null,[n(a,{to:"#project-18-part-one"},{default:i(()=>[t("Project 18, part one")]),_:1}),e("ul",null,[e("li",null,[n(a,{to:"#setting-up"},{default:i(()=>[t("Setting up")]),_:1})]),e("li",null,[n(a,{to:"#basic-swift-debugging-using-print"},{default:i(()=>[t("Basic Swift debugging using print()")]),_:1})]),e("li",null,[n(a,{to:"#debugging-with-assert"},{default:i(()=>[t("Debugging with assert()")]),_:1})]),e("li",null,[n(a,{to:"#debugging-with-breakpoints"},{default:i(()=>[t("Debugging with breakpoints")]),_:1})]),e("li",null,[n(a,{to:"#view-debugging"},{default:i(()=>[t("View debugging")]),_:1})])])])])]),v,n(o,r(l({title:"100 Days of Swift - Day 64",desc:"Project 18, part one",link:"https://www.hackingwithswift.com/100/64",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),_,e("details",x,[D,n(o,r(l({title:"100 Days of Swift - Day 64 - Setting up",desc:"Setting up",link:"https://www.hackingwithswift.com/read/18/1/setting-up",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),n(c,{src:"youtube/aIdq-MJOtE4"}),T,S,j,q,I]),V,e("details",B,[X,n(o,r(l({title:"100 Days of Swift - Day 64 - Basic Swift debugging using print()",desc:"Basic Swift debugging using print()",link:"https://www.hackingwithswift.com/read/18/2/basic-swift-debugging-using-print",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),n(c,{src:"youtube/tbFO8DsJ6aw"}),C]),P,e("details",F,[A,n(o,r(l({title:"100 Days of Swift - Day 64 - Debugging with assert()",desc:"Debugging with assert()",link:"https://www.hackingwithswift.com/read/18/3/debugging-with-assert",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),n(c,{src:"youtube/2GkNf9XZN5I"}),N]),O,e("details",L,[R,n(o,r(l({title:"100 Days of Swift - Day 64 - Debugging with breakpoints",desc:"Debugging with breakpoints",link:"https://www.hackingwithswift.com/read/18/4/debugging-with-breakpoints",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),n(c,{src:"youtube/OCeKmiCJLtg"}),W,e("p",null,[t("If you click on a breakpoint again, the blue arrow will become faint to show that the breakpoint exists but is disabled. This is useful when you want to keep your place, but don‚Äôt want execution to stop right now. You can click again to make it active, or right-click and choose "),n(s,{icon:"iconfont icon-select"}),E,t(" to remove it entirely.")]),e("p",null,[M,t(" If your Xcode isn't showing line numbers by default, I suggest you turn them on. Go to the Xcode menu and choose "),n(s,{icon:"iconfont icon-select"}),H,t(", then choose the "),n(s,{icon:"iconfont icon-select"}),Y,t(' tab and make sure "Line numbers" is checked.')]),J,e("p",null,[t("Xcode also gives you an interactive LLDB debugger window, where you can type commands to query values and run methods. If it‚Äôs visible, you‚Äôll see ‚Äú(lldb)‚Äù in the bottom of your Xcode window. If you don‚Äôt see that, go to "),n(s,{icon:"iconfont icon-select"}),K,t(", at which point focus will move to the LLDB window. Try typing "),U,t(" to ask Xcode to print the value of the "),Z,t(" variable.")]),G,z,e("p",null,[t("Right-click on the breakpoint (the blue arrow marker) and choose Edit Breakpoint. In the popup that appears, set the condition value to be "),Q,t(" ‚Äì this uses modulo, as seen in project 8. With that in place, execution will now pause only when "),$,t(' is 10, 20, 30 and so on, up to 100. You can use conditional breakpoints to execute debugger commands automatically ‚Äì the "'),n(s,{icon:"iconfont icon-select"}),ee,t('" checkbox is perfect for making your program continue uninterrupted while breakpoints silently trigger actions.')]),te,e("p",null,[t("To make this happen, press "),ne,t("+"),se,t(" to choose the breakpoint navigator ‚Äì it's on the left of your screen, where the project navigator normally sits. Now click the "),n(s,{icon:"iconfont icon-select"}),ae,t(' button in the bottom-left corner and choose "'),n(s,{icon:"iconfont icon-select"}),oe,t(`." That's it! The next time your code hits a fatal problem, the exception breakpoint will trigger and you can take action.`)])]),ie,e("details",re,[le,n(o,r(l({title:"100 Days of Swift - Day 64 - View debugging",desc:"View debugging",link:"https://www.hackingwithswift.com/read/18/5/view-debugging",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(213,52,58,0.2)"})),null,16),n(c,{src:"youtube/01K6Oy5ktaQ"}),ce,e("p",null,[t("First, launch a project with some interesting UI. Project 13, for example, has enough in there to be interesting. Now run the program as normal, then in Xcode go to the Debug menu and choose "),n(s,{icon:"iconfont icon-select"}),ue,t(". After a few seconds of thinking, Xcode will show you a screenshot of your app‚Äôs UI.")]),pe,de]),he])}const ye=h(b,[["render",ge],["__file","64.html.vue"]]),fe=JSON.parse('{"path":"/swift/100-days-of-swift/64.html","title":"Day 64","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Day 64","description":"100 Days of Swift > Day 64","category":["Swift"],"tag":["crashcourse","paul-hudson","swift","hacking-with-swift","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"100 Days of Swift > Day 64"},{"property":"og:description","content":"Day 64"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/swift/100-days-of-swift/64.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/swift/100-days-of-swift/64.html"}],["meta",{"property":"og:site_name","content":"ü•ÅCrashcourse"}],["meta",{"property":"og:title","content":"Day 64"}],["meta",{"property":"og:description","content":"100 Days of Swift > Day 64"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"paul-hudson"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"hacking-with-swift"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Day 64\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Project 18, part one","slug":"project-18-part-one","link":"#project-18-part-one","children":[{"level":3,"title":"Setting up","slug":"setting-up","link":"#setting-up","children":[]},{"level":3,"title":"Basic Swift debugging using print()","slug":"basic-swift-debugging-using-print","link":"#basic-swift-debugging-using-print","children":[]},{"level":3,"title":"Debugging with assert()","slug":"debugging-with-assert","link":"#debugging-with-assert","children":[]},{"level":3,"title":"Debugging with breakpoints","slug":"debugging-with-breakpoints","link":"#debugging-with-breakpoints","children":[]},{"level":3,"title":"View debugging","slug":"view-debugging","link":"#view-debugging","children":[]}]}],"git":{"createdTime":1703642364000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":10}]},"readingTime":{"minutes":8.78,"words":2634},"filePathRelative":"swift/100-days-of-swift/64.md","localizedDate":"2023ÎÖÑ 12Ïõî 27Ïùº","excerpt":"\\n\\n<hr>\\n"}');export{ye as comp,fe as data};
