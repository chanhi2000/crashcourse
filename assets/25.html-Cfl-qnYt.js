import{_ as u}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,a as e,t as h,b as s,w as t,n as o,g as i,e as p,r as c,o as m,d as l}from"./app-U_bew1in.js";const w={},g={id:"frontmatter-title-관련",tabindex:"-1"},k={class:"header-anchor",href:"#frontmatter-title-관련"},y={class:"table-of-contents"},f=e("hr",null,null,-1),v=p('<h2 id="milestone-projects-1-3" tabindex="-1"><a class="header-anchor" href="#milestone-projects-1-3"><span>Milestone: Projects 1-3</span></a></h2><p>It’s time for another consolidation day, because we’ve covered a lot of ground in the first three topics and it’s important you review them if you want them to stick in your head.</p><p>However, this will also be another day when you’re asked to create a complete app from scratch. Yes, I know you’ve already made a complete app of your own just a few days ago, but bear with me – this repetition matters!</p><p>There’s a famous story about a teacher who went into a pottery class and did an experiment. Half the class were asked to produce one pot, and they had all day to make it the best they could. The other half were asked to produce as <em>many</em> pots as they could.</p><p>At the end of the day, the teacher put all the pots together and asked the students to choose which pots were the best. And – perhaps surprisingly – the best pots were from the group who went for <em>quantity</em> over <em>quality</em>.</p><p>This isn’t me suggesting you should rush through work or do half a job to get through a checklist of tasks. Instead, I want you to think about what it takes to truly master a skill. If you only ever built one app, you would have no room to experiment, no room to screw up without consequence, and no room to try something that you wouldn’t otherwise try – you’d have one pot, and it wouldn’t be great.</p><p>But if you have the chance to make <em>many</em> apps, each one designed to be simple so you don’t have the pressure of shipping something great, then the opposite is true: you have a clean slate each time you work, you get to practice the same basic tasks again and again, and you get to experiment freely.</p><p>After all, if worse comes to worst you just throw your app away at the end, knowing that you’ll have another one to do in a few days. Then another, then another. In fact, you’ll be making lots of apps during this course – that’s kind of the point!</p><p>Anyway, enough chit chat: you have some topics to review, some key points where I want to focus on some important topics in more detail, and a full app to build. Let’s get to it!</p><p><strong>Today you have three topics to work through, one of which of is your challenge.</strong></p><h3 id="what-you-learned" tabindex="-1"><a class="header-anchor" href="#what-you-learned"><span>What you learned</span></a></h3>',11),b={class:"hint-container details"},S=e("summary",null,"What you learned",-1),I=p("<p>You’ve made your first two SwiftUI projects now, and completed a technique project too – this same cadence of two apps and a technique project continues to the end of the course, and will help you advance your knowledge quickly while taking the time to go back and refine what you learned.</p><p>Although we are only three projects into SwiftUI, you’ve already learned some of the most important concepts: views, modifiers, state, stack layouts, and more – these are skills that you’ll be using again and again in SwiftUI, which is why I wanted to get them down early.</p><p>Of course, you also built some real projects and completed lots of coding challenges to help solidify your learning, so hopefully you’re starting to get a sense of what you know.</p><p>So far we have covered:</p><ul><li>Building scrolling forms that mix text with controls such as <code>Picker</code>, which SwiftUI turns into a beautiful table-based layout where new screens slide in with fresh choices.</li><li>Creating a <code>NavigationView</code> and giving it a title. This not only allows us to push new views onto the screen, but also lets us set a title and avoid problems with content going under the clock.</li><li>How to use<code> @State</code> to store changing data, and why it’s needed. Remember, all our SwiftUI views are structs, which means they can’t be changed without something like <code>@State</code>.</li><li>Creating two-way bindings for user interface controls such as <code>TextField</code> and <code>Picker</code>, learning how using <code>$variable</code> lets us both read and write values.</li><li>Using <code>ForEach</code> to create views in a loop, which allows us to make lots of views all at once.</li><li>Building complex layouts using <code>VStack</code>, <code>HStack</code>, and <code>ZStack</code>, as well as combining them together to make grids.</li><li>How to use colors and gradients as views, including how to give them specific frames so you can control their size.</li><li>How to create buttons by providing some text or an image, along with a closure that should be executed when the button is tapped.</li><li>Creating alerts by defining the conditions under which the alert should be shown, then toggling that state from elsewhere.</li><li>How (and why!) SwiftUI uses opaque result types (<code>some View</code>) so extensively, and why this is so closely linked to modifier order being important.</li><li>How to use the ternary conditional operator to create conditional modifiers that apply different results depending on your program state.</li><li>How to break up your code into small parts using view composition and custom view modifiers, which in turn allows us to build more complex programs without getting lost in code.</li></ul><p>One thing I want you to think about is what it means to be a “view” in SwiftUI. Before you started this course you might well have thought that <code>Color.red</code> couldn’t possibly be a view, but it is. You’ve also seen how <code>LinearGradient</code> is a view, which means it’s easy to use inside our layouts.</p><p>But what about <code>VStack</code>? Or <code>Group</code>? Or <code>ForEach</code>? Are <em>those</em> views?</p><p>Yes! Those absolutely are all views in SwiftUI, which is what makes the framework so remarkably composable – we can put a <code>ForEach</code> inside a <code>ForEach</code> inside a <code>Group</code> inside a <code>VStack</code>, and it all works.</p><p>Remember, all something needs to do in order to conform to the <code>View</code> protocol is to have a single computed property called <code>body</code> that returns <code>some View</code>.</p><p>Previously we looked very closely at protocols, protocol extensions, and protocol-oriented programming in Swift, and you might have wondered why this was all so important. Well, now I hope you can see: the <code>View</code> protocol is the centerpiece of SwiftUI – anything can conform to it and start taking part in layouts, in just a few simple lines of code.</p><p>In other user interface frameworks (including Apple’s own UIKit), classes were used for this work. This meant that if you had some existing types and you wanted to use them for layout, you needed to make them inherit from <code>UIView</code> - which in turn meant getting over 200 properties and methods that you probably didn’t need, as well as a raft of other functionality used behind the scenes.</p><p>In SwiftUI none of that happens: we just add a single <code>View</code> conformance. This is the power of protocols and protocol extensions, and this is what makes protocol-oriented programming so important – if we add a single <code>body</code> property to our type, SwiftUI knows how to use that to do layout and rendering.</p><p>Now, if you were paying attention you might have noticed a curiosity: when we make any sort of SwiftUI view we need to make it return <code>some View</code> – we make a view, and it returns one or more other views. Those views have their own <code>body</code> properties that in turn return views, and those views have their own <code>body</code> properties that… well, you get the point.</p><p>This seems like SwiftUI has built an infinite loop for itself: if all views are made up of other views, where does it actually end?</p><p>Obviously it <em>does</em> end otherwise none of our SwiftUI code would actually work. And the trick lies in something Apple calls <em>primitive views</em> – the absolute bare building blocks of SwiftUI, which conform to <code>View</code> but return some fixed content rather than rendering some other kind of view instead.</p><p>There are quite a few of these building blocks, and they won’t come as much of a surprise – <code>Text</code> is one, for example, as is <code>Image</code>, <code>Color</code>, <code>Spacer</code>, and more. Ultimately all the UI we build is created on top of these building blocks, which is what breaks the seemingly infinite loop.</p>",16),T=e("h3",{id:"key-points",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#key-points"},[e("span",null,"Key points")])],-1),x={class:"hint-container details"},_=e("summary",null,"Key points",-1),q=p(`<p>There are three important points that are worth going over in more detail. This will partly be reviewing what we learned – going over it again with different examples to help make sure they are clear – but I also want to take this chance to answer some questions that are likely to have cropped up so far.</p><h4 id="structs-vs-classes" tabindex="-1"><a class="header-anchor" href="#structs-vs-classes"><span>Structs vs classes</span></a></h4><p>First, something that should hopefully be fairly fresh in your memory: structs and classes. These are both ways of letting us build complex data types with properties and methods, but the way they work – more specifically, how they <em>differ</em> – matters.</p><p>If you remember, there are five key differences between structs and classes:</p><ol><li>Classes don’t come with a memberwise initializer; structs get these by default.</li><li>Classes can use inheritance to build up functionality; structs cannot.</li><li>If you copy a class, both copies point to the same data; copies of structs are always unique.</li><li>Classes can have deinitializers; structs cannot.</li><li>You can change variable properties inside constant classes; properties inside constant structs are fixed regardless of whether the properties are constants or variables.</li></ol><p>In Apple’s original programming language, Objective-C, we used classes for pretty much <em>everything</em> – we didn’t have a choice, because it was really baked into the way things worked.</p><p>In Swift we <em>do</em> have a choice, and that choice ought to be based upon those factors above. I say “ought to be” because it’s not uncommon to see folks who don’t care about these differences, and so use either <code>class</code> or <code>struct</code> all the time without considering the ramifications of that choice.</p><p>Whether you choose structs or classes is down to you and the specific problems you’re solving. However, what I <em>want</em> you to do is consider how it conveys your <em>intent</em>. Donald Knuth said that “programs are meant to be read by humans and only incidentally for computers to execute”, which really gets to the heart of what I’m talking about: when someone reads your code, is your intent clear to them?</p><p>If you use structs most of the time, switching to a class in one particular place conveys some intent: this thing is different and needs to be used differently. If you <em>always</em> use classes, that distinction gets lost – after all, it’s extremely unlikely you need them that often.</p><p>Tip: One of the fascinating details of SwiftUI is how it completely inverts how we use structs and classes. In UIKit we would use structs for data and classes for UI, but in SwiftUI it’s completely the opposite – a good reminder of the importance of learning things, even if you think they aren’t immediately useful.</p><h4 id="working-with-foreach" tabindex="-1"><a class="header-anchor" href="#working-with-foreach"><span>Working with ForEach</span></a></h4><p>The second thing I’d like to discuss is <code>ForEach</code>, which we have used with code like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token class-name">ForEach</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">..&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> number <span class="token keyword">in</span></span>
<span class="line">    <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Row </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">number</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ForEach</code> is a view just like most other things in SwiftUI, but it allows us to create other views inside a loop. In doing so, it also allows us to bypass the ten-child limit that SwiftUI imposes – the <code>ForEach</code> itself becomes one of the 10, rather than the things inside it.</p><p>Now consider a string array like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">let</span> agents <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;Cyril&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Lana&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Pam&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Sterling&quot;</span></span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>How could we loop over those and make text views?</p><p>One option is to use the same construction we already have:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token class-name">VStack</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">ForEach</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">..&lt;</span>agents<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Text</span><span class="token punctuation">(</span>agents<span class="token punctuation">[</span><span class="token short-argument">$0</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>But SwiftUI offers us a second alternative: we can loop over the array directly. This takes a little more thinking, because SwiftUI wants to know how it can identify each item in the array.</p><p>Think about it: if we loop over a four-item array we will create four views, but if <code>body</code> gets re-invoked and our array now contains <em>five</em> items, SwiftUI needs to know which view is new so it can be shown in the UI. The last thing SwiftUI wants to do is throw away its whole layout and start from scratch every time a small change is made. Instead, it wants to do the least amount of work possible: it wants to leave the existing four views in place and add only the fifth.</p><p>So, we come back to how Swift can identify values in our array. When we were using a range such as <code>0..&lt;5</code> or <code>0..&lt;agents.count</code>, Swift knew for sure that each item was unique because it would use the numbers from the range – each number was used only once in the loop, so it would definitely be unique.</p><p>In our array of strings that’s no longer possible, but we can clearly see that each value is unique: the values in <code>[&quot;Cyril&quot;, &quot;Lana&quot;, &quot;Pam&quot;, &quot;Sterling&quot;]</code> don’t repeat. So, what we can do is tell SwiftUI that the strings themselves – “Cyril”, “Lana”, etc – are what can be used to identify each view in the loop uniquely.</p><p>In code, we’d write this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token class-name">VStack</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">ForEach</span><span class="token punctuation">(</span>agents<span class="token punctuation">,</span> id<span class="token punctuation">:</span> <span class="token punctuation">\\</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token short-argument">$0</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>So rather than loop over integers and use that to read into the array, we’re now reading items in the array directly – just like a <code>for</code> loop would do.</p><p>As you progress with SwiftUI we’ll look at a third way of identifying views using the <code>Identifiable</code> protocol, but that will come in time.</p><h4 id="working-with-bindings" tabindex="-1"><a class="header-anchor" href="#working-with-bindings"><span>Working with bindings</span></a></h4><p>When we use controls such as <code>Picker</code> and <code>TextField</code> we create two-way bindings for them to some sort of <code>@State</code> property using <code>$propertyName</code>. This works great for simple properties, but sometimes – only sometimes, hopefully! – you might want something more advanced: what if you want to run some logic to calculate the current value? Or what if you want to do more than just stash away a value when it’s written?</p><p>If we want to react to changes in a binding, we might try to leverage Swift’s <code>didSet</code> property observer, but you’d be disappointed. This is where custom bindings come in: they can be used just like <code>@State</code> bindings, except we get complete control over how they work.</p><p>Bindings aren’t magic: <code>@State</code> takes away some boring boilerplate code for us, but it’s perfectly possible to create and manage bindings by hand if you want to. Again, I’m not showing you this because it’s common, because it’s really not; my hope is that you’ll need to do this rarely. Instead, I’m showing it to you because I want to eliminate the idea that SwiftUI is doing some sort of magic on your behalf.</p><p>Everything that SwiftUI does for us can be done by hand, and although it’s nearly always better to rely on the automatic solution it can be really helpful to take a peek behind the scenes so you understand <em>what</em> it’s doing on your behalf.</p><p>First let’s look at the simplest form of custom binding, which just stores the value away in another <code>@State</code> property and reads that back:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">ContentView</span><span class="token punctuation">:</span> <span class="token class-name">View</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token attribute atrule">@State</span> <span class="token keyword">private</span> <span class="token keyword">var</span> selection <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">var</span> body<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">View</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">let</span> binding <span class="token operator">=</span> <span class="token class-name">Binding</span><span class="token punctuation">(</span></span>
<span class="line">            <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> selection <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">            <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> selection <span class="token operator">=</span> <span class="token short-argument">$0</span> <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">VStack</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name">Picker</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Select a number&quot;</span></span><span class="token punctuation">,</span> selection<span class="token punctuation">:</span> binding<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token class-name">ForEach</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">..&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Item </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation"><span class="token short-argument">$0</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">.</span><span class="token function">pickerStyle</span><span class="token punctuation">(</span><span class="token punctuation">.</span>segmented<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>So, that binding is effectively just acting as a passthrough – it doesn’t store or calculate any data itself, but just acts as a shim between our UI and the underlying state value that is being manipulated.</p><p>However, notice that the picker is now made using <code>selection: binding</code> – no dollar sign required. We don’t need to explicitly ask for the two-way binding here because it already <em>is</em> one.</p><p>If we wanted to, we could create a more advanced binding that does more than just pass through a single value. For example, imagine we had a form with three toggle switches: does the user agree to the terms and conditions, agree to the privacy policy, and agree to get emails about shipping.</p><p>We might represent that as three Boolean <code>@State</code> properties:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token attribute atrule">@State</span> <span class="token keyword">var</span> agreedToTerms <span class="token operator">=</span> <span class="token boolean">false</span></span>
<span class="line"><span class="token attribute atrule">@State</span> <span class="token keyword">var</span> agreedToPrivacyPolicy <span class="token operator">=</span> <span class="token boolean">false</span></span>
<span class="line"><span class="token attribute atrule">@State</span> <span class="token keyword">var</span> agreedToEmails <span class="token operator">=</span> <span class="token boolean">false</span></span>
<span class="line"><span class="token class-name">Although</span> the user could just toggle them all by hand<span class="token punctuation">,</span> we could use a custom binding to <span class="token keyword">do</span> them all at once<span class="token punctuation">.</span> <span class="token class-name">This</span> binding would be <span class="token boolean">true</span> <span class="token keyword">if</span> all three of those <span class="token class-name">Booleans</span> were <span class="token boolean">true</span><span class="token punctuation">,</span> but <span class="token keyword">if</span> it got changed then it would update them all<span class="token punctuation">,</span> like this<span class="token punctuation">:</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> agreedToAll <span class="token operator">=</span> <span class="token class-name">Binding</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token punctuation">{</span></span>
<span class="line">        agreedToTerms <span class="token operator">&amp;&amp;</span> agreedToPrivacyPolicy <span class="token operator">&amp;&amp;</span> agreedToEmails</span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token punctuation">{</span></span>
<span class="line">        agreedToTerms <span class="token operator">=</span> <span class="token short-argument">$0</span></span>
<span class="line">        agreedToPrivacyPolicy <span class="token operator">=</span> <span class="token short-argument">$0</span></span>
<span class="line">        agreedToEmails <span class="token operator">=</span> <span class="token short-argument">$0</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>So now we can create four toggle switches: one each for the individual Booleans, and one control switch that agrees or disagrees to all three at once:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift" data-title="swift"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">ContentView</span><span class="token punctuation">:</span> <span class="token class-name">View</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token attribute atrule">@State</span> <span class="token keyword">private</span> <span class="token keyword">var</span> agreedToTerms <span class="token operator">=</span> <span class="token boolean">false</span></span>
<span class="line">    <span class="token attribute atrule">@State</span> <span class="token keyword">private</span> <span class="token keyword">var</span> agreedToPrivacyPolicy <span class="token operator">=</span> <span class="token boolean">false</span></span>
<span class="line">    <span class="token attribute atrule">@State</span> <span class="token keyword">private</span> <span class="token keyword">var</span> agreedToEmails <span class="token operator">=</span> <span class="token boolean">false</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">var</span> body<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">View</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">let</span> agreedToAll <span class="token operator">=</span> <span class="token class-name">Binding</span><span class="token operator">&lt;</span><span class="token class-name">Bool</span><span class="token operator">&gt;</span><span class="token punctuation">(</span></span>
<span class="line">            <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token punctuation">{</span></span>
<span class="line">                agreedToTerms <span class="token operator">&amp;&amp;</span> agreedToPrivacyPolicy <span class="token operator">&amp;&amp;</span> agreedToEmails</span>
<span class="line">            <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">            <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token punctuation">{</span></span>
<span class="line">                agreedToTerms <span class="token operator">=</span> <span class="token short-argument">$0</span></span>
<span class="line">                agreedToPrivacyPolicy <span class="token operator">=</span> <span class="token short-argument">$0</span></span>
<span class="line">                agreedToEmails <span class="token operator">=</span> <span class="token short-argument">$0</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">VStack</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name">Toggle</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Agree to terms&quot;</span></span><span class="token punctuation">,</span> isOn<span class="token punctuation">:</span> $agreedToTerms<span class="token punctuation">)</span></span>
<span class="line">            <span class="token class-name">Toggle</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Agree to privacy policy&quot;</span></span><span class="token punctuation">,</span> isOn<span class="token punctuation">:</span> $agreedToPrivacyPolicy<span class="token punctuation">)</span></span>
<span class="line">            <span class="token class-name">Toggle</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Agree to receive shipping emails&quot;</span></span><span class="token punctuation">,</span> isOn<span class="token punctuation">:</span> $agreedToEmails<span class="token punctuation">)</span></span>
<span class="line">            <span class="token class-name">Toggle</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Agree to all&quot;</span></span><span class="token punctuation">,</span> isOn<span class="token punctuation">:</span> agreedToAll<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Again, custom bindings aren’t something you’ll want that often, but it’s so important to take the time to look behind the curtain and understand what’s going on. Even though it’s incredibly smart, SwiftUI is just a tool, not magic!</p>`,42),U=e("h3",{id:"challenge",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#challenge"},[e("span",null,"Challenge")])],-1),j={class:"hint-container details"},P=e("summary",null,"Challenge",-1),V=p("<p>You have a basic understanding of arrays, state, views, images, text, and more, so let’s put them together: your challenge is to make a brain training game that challenges players to win or lose at rock, paper, scissors.</p><p>So, very roughly:</p><ul><li>Each turn of the game the app will randomly pick either rock, paper, or scissors.</li><li>Each turn the app will alternate between prompting the player to win or lose.</li><li>The player must then tap the correct move to win or lose the game.</li><li>If they are correct they score a point; otherwise they lose a point.</li><li>The game ends after 10 questions, at which point their score is shown.</li></ul><p>So, if the app chose “Rock” and “Win” the player would need to choose “Paper”, but if the app chose “Rock” and “Lose” the player would need to choose “Scissors”.</p><p>To solve this challenge you’ll need to draw on skills you learned in tutorials 1 and 2:</p><ol><li>Start with an App template, then create a property to store the three possible moves: rock, paper, and scissors.</li><li>You’ll need to create two <code>@State</code> properties to store the app’s current choice and whether the player should win or lose.</li><li>You can use <code>Int.random(in:)</code> to select a random move. You can use it for whether the player should win too if you want, but there’s an even easier choice: <code>Bool.random()</code> is randomly true or false. After the initial value, use <code>toggle()</code> between rounds so it’s always changing.</li><li>Create a <code>VStack</code> showing the player’s score, the app’s move, and whether the player should win or lose. You can use <code>if shouldWin</code> to return one of two different text views.</li><li>The important part is making three buttons that respond to the player’s move: Rock, Paper, or Scissors.</li><li>Use the <code>font()</code> modifier to adjust the size of your text. If you’re using emoji for the three moves, they also scale. <strong>Tip</strong>: You can ask for very large system fonts using <code>.font(.system(size: 200))</code> – they’ll be a fixed size, but at least you can make sure they are nice and big! I’m going to provide some hints below, but I suggest you try to complete as much of the challenge as you can before reading them.</li></ol><p>Hints:</p><ul><li>Start off with the simplest logic you can: three buttons, each with logic that says “the player tapped rock, the player was trying to win, and the app chose scissors, so add 1 point.”</li><li>Once you have that working, look for a way to simplify your logic such as an array of which items beat each move. For example, if your moves array was <code>[&quot;Rock&quot;, &quot;Paper&quot;, &quot;Scissors&quot;] </code>your array of winning moves would be <code>[&quot;Paper&quot;, &quot;Scissors&quot;, &quot;Rock&quot;]</code>.</li><li>You don’t need to add graphics if you don’t want to; just some text views and buttons is enough. Why not try emoji?</li></ul><p>This should be a fun exercise: there’s a little bit of Swift, a little bit of SwiftUI, and a little bit of logic, all wrapped up in a game where you can really go to town on theming if you want to.</p>",9),C=e("div",{class:"hint-container tip"},[e("p",{class:"hint-container-title"},"Note"),e("p",null,"Don’t worry if you don’t complete challenges in the day they were assigned – in future days you’ll find you have some time to spare here and there, so challenges are something you can return back to in the future.")],-1),A=e("hr",null,null,-1);function E(r,D){const a=c("router-link"),n=c("VPCard");return m(),d("div",null,[e("h1",g,[e("a",k,[e("span",null,h(r.$frontmatter.title)+" 관련",1)])]),e("nav",y,[e("ul",null,[e("li",null,[s(a,{to:"#milestone-projects-1-3"},{default:t(()=>[l("Milestone: Projects 1-3")]),_:1}),e("ul",null,[e("li",null,[s(a,{to:"#what-you-learned"},{default:t(()=>[l("What you learned")]),_:1})]),e("li",null,[s(a,{to:"#key-points"},{default:t(()=>[l("Key points")]),_:1})]),e("li",null,[s(a,{to:"#challenge"},{default:t(()=>[l("Challenge")]),_:1})])])])])]),f,s(n,o(i({title:"100 Days of SwiftUI - Day 25",desc:"Milestone: Projects 1-3",link:"https://www.hackingwithswift.com/100/swiftui/25",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),v,e("details",b,[S,s(n,o(i({title:"100 Days of SwiftUI - Day 25 - What you learned",desc:"What you learned",link:"https://hackingwithswift.com/guide/ios-swiftui/2/1/what-you-learned",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),I]),T,e("details",x,[_,s(n,o(i({title:"100 Days of SwiftUI - Day 25 - Key points",desc:"Key points",link:"https://hackingwithswift.com/guide/ios-swiftui/2/2/key-points",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),q]),U,e("details",j,[P,s(n,o(i({title:"100 Days of SwiftUI - Day 25 - Challenge",desc:"Challenge",link:"https://hackingwithswift.com/guide/ios-swiftui/2/3/challenge",logo:"https://www.hackingwithswift.com/favicon.svg",background:"rgba(54,94,226,0.2)"})),null,16),V]),C,A])}const W=u(w,[["render",E],["__file","25.html.vue"]]),$=JSON.parse('{"path":"/swift/100-days-of-swiftui/25.html","title":"Day 25","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Day 25","description":"100 Days of SwiftUI > Day 25","category":["Swift"],"tag":["crashcourse","paul-hudson","swift","swiftui","hacking-with-swift","xcode","appstore"],"head":[[{"meta":null},{"property":"og:title","content":"100 Days of SwiftUI > Day 25"},{"property":"og:description","content":"Day 25"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/swift/100-days-of-swiftui/25.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/swift/100-days-of-swiftui/25.html"}],["meta",{"property":"og:site_name","content":"🥁Crashcourse"}],["meta",{"property":"og:title","content":"Day 25"}],["meta",{"property":"og:description","content":"100 Days of SwiftUI > Day 25"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"paul-hudson"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"swiftui"}],["meta",{"property":"article:tag","content":"hacking-with-swift"}],["meta",{"property":"article:tag","content":"xcode"}],["meta",{"property":"article:tag","content":"appstore"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Day 25\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Milestone: Projects 1-3","slug":"milestone-projects-1-3","link":"#milestone-projects-1-3","children":[{"level":3,"title":"What you learned","slug":"what-you-learned","link":"#what-you-learned","children":[]},{"level":3,"title":"Key points","slug":"key-points","link":"#key-points","children":[]},{"level":3,"title":"Challenge","slug":"challenge","link":"#challenge","children":[]}]}],"git":{"createdTime":1703642364000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":10}]},"readingTime":{"minutes":12.22,"words":3666},"filePathRelative":"swift/100-days-of-swiftui/25.md","localizedDate":"2023년 12월 27일","excerpt":"\\n\\n<hr>\\n"}');export{W as comp,$ as data};
