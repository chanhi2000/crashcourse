import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as g,a as e,t as h,b as t,n as s,g as n,w as c,d as o,e as m,r as l,o as u}from"./app-U_bew1in.js";const y={},f={id:"frontmatter-title-관련",tabindex:"-1"},b={class:"header-anchor",href:"#frontmatter-title-관련"},x={class:"table-of-contents"},D=e("hr",null,null,-1),B=m('<p>DynamoDB는 RDBMS에 비해 데이터 구조를 자유롭게 저장할 수 있으므로 이 부분을 적극 활용합니다. 또한, 데이터 개수가 많고, 용량이 커서 서버 한대로 처리할 수 없을 때 유용하게 사용할 수 있습니다. RDBMS에서는 서버를 대용량 데이터를 분할하여 처리하기가 상당히 어렵습니다.</p><p>이번에는 애니팡이나 쿠키런과 같은 모바일 게임의 DB를 설계해보겠습니다. 이러한 게임의 핵심 요구사항은 다음과 같습니다(로그인, 유저 및 친구관리, 선물, 상점 기능은 생략하겠습니다).</p><ul><li>주간 전체순위 산출</li><li>주간 친구순위 산출</li><li>개인 최근 점수 목록 조회</li><li>개인 최고기록 조회</li></ul><p>완벽하게 제품화할 정도로 설계를 하자면 내용도 많아지고 복잡해지기 때문에 DynamoDB의 인덱스, 로컬 보조 인덱스, 글로벌 보조 인덱스를 활용하는 방법 위주로 간단하게 설계해보겠습니다. 게임을 할 때마다 서버에 점수를 전송하여 DB에 저장하고, 주간 전체순위, 주간 친구순위를 산출한다고 가정해보겠습니다.</p><p>먼저 주간 전체순위 산출을 위한 유저 순위 테이블(<code>UsersLeaderboard</code>)의 구조입니다.</p><ul><li><strong>Id</strong>: 숫자 형식이며 유저를 구분하는 유일한 값입니다.</li><li><strong>Name</strong>: 문자열 형식이며 유저의 이름을 저장합니다.</li><li><strong>TopScore</strong>: 숫자 형식이며 유저의 주간 최고점수를 저장합니다.</li><li><strong>Week</strong>: 문자열 형식이며 한 주를 저장합니다. 예) 2014-05-09,2014-05-15</li></ul><h2 id="usersleaderboard" tabindex="-1"><a class="header-anchor" href="#usersleaderboard"><span><code>UsersLeaderboard</code></span></a></h2><blockquote><p>유저 순위 테이블</p></blockquote><table><thead><tr><th style="text-align:left;">키 이름(값 형식)</th><th style="text-align:left;"><code>Id(Number)</code></th><th style="text-align:left;"><code>Name(String)</code></th><th style="text-align:left;"><code>TopScore(Number)</code></th><th style="text-align:left;"><code>Week(String)</code></th></tr></thead><tbody><tr><td style="text-align:left;">테이블 인덱스</td><td style="text-align:left;">해시 기본 키</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;">범위 기본 키</td></tr><tr><td style="text-align:left;">로컬 보조 인덱스</td><td style="text-align:left;">해시 키</td><td style="text-align:left;"></td><td style="text-align:left;">범위 키</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">글로벌 보조 인덱스</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;">범위 키</td><td style="text-align:left;">해시 키</td></tr></tbody></table><p><code>Id</code>를 해시 기본 키, <code>Week</code>를 범위 기본 키로 설정한 테이블 인덱스로 개인 최근 점수 목록을 조회할 수 있습니다. <code>Week</code>를 9999-12-31,9999-12-31보다 작은<sup>less</sup> <sup>than</sup> 조건으로 내림차순으로 정렬하면 됩니다. <code>Id</code>를 해시 키, <code>TopScore</code>를 범위 키로 설정한 로컬 보조 인덱스로 개인 최고기록을 조회할 수 있습니다. <code>TopScore</code>를 99999보다 작은<sup>less</sup> <sup>then</sup> 조건으로 내림차순 정렬하면 됩니다(최대점수는 99999라고 가정).</p><p><code>Week</code>를 해시 키, Top Score를 범위 키로 설정한 글로벌 보조 인덱스로 주간 전체순위를 산출할 수 있습니다. <code>Week</code>를 2014-05-09,2014-05-15와 같은<sup>equal</sup> <sup>to</sup> 조건에 <code>TopScore</code>를 99999보다 작은<sup>less</sup> <sup>than</sup> 조건으로 내림차순 정렬하면 됩니다.</p><p>이제 주간 친구순위 산출을 위한 친구 순위 테이블(<code>FriendsLeaderboard</code>)의 구조입니다.</p><ul><li><strong>Id</strong>: 숫자 형식이며 유저를 구분하는 유일한 값입니다.</li><li><strong>Name</strong>: 문자열 형식이며 유저의 이름을 저장합니다.</li><li><strong>Score</strong>: 숫자 형식이며 현재 유저가 획득한 점수를 저장합니다.</li><li><strong>FriendIdAndWeek</strong>: 문자열 형식이며 현재 유저의 친구 <code>Id</code>와 한 주를 함께 저장합니다. 친구 <code>Id</code>가 2라면 2,2014-05-09,2014-05-15와 같은 형식입니다. 현재 유저가 게임을 플레이 할 때마다, 유저의 모든 친구 <code>Id</code>와 주를 이런 방식으로 점수와 함께 저장해야 합니다. 또한, 유저 <code>Id</code>가 1이라면 1,2014-05-09,2014-05-15와 같이 자기자신의 데이터도 저장합니다.</li></ul><h2 id="friendsleaderboard" tabindex="-1"><a class="header-anchor" href="#friendsleaderboard"><span><code>FriendsLeaderboard</code></span></a></h2><blockquote><p>친구 순위 테이블</p></blockquote><table><thead><tr><th style="text-align:left;">키 이름(값 형식)</th><th style="text-align:left;"><code>Id(Number)</code></th><th style="text-align:left;"><code>Name(String)</code></th><th style="text-align:left;"><code>Score(Number)</code></th><th style="text-align:left;"><code>FriendIdAndWeek(String)</code></th></tr></thead><tbody><tr><td style="text-align:left;">테이블 인덱스</td><td style="text-align:left;">해시 기본 키</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;">범위 기본 키</td></tr><tr><td style="text-align:left;">글로벌 보조 인덱스</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;">범위 키</td><td style="text-align:left;">해시 키</td></tr></tbody></table><p><code>FriendIdAndWeek</code>를 해시 키, <code>Score</code>를 범위 키로 설정한 글로벌 보조 인덱스로 주간 친구순위를 산출할 수 있습니다. 조회하고 싶은 <code>Id</code>가 2라면 <code>FriendIdAndWeek</code>를 2,2014-05-09,2014-05-15와 같은<sup>equal</sup> <sup>to</sup> 조건에 <code>Score</code>를 99999보다 작은<sup>less</sup> <sup>than</sup> 조건으로 내림차순 정렬하면 됩니다. 이렇게 하면 내 친구들의 <code>Id</code>와 점수를 조회할 수 있습니다.</p><p>이런 방법으로 DynamoDB에 점수 데이터를 저장하면 늘어나는 유저의 숫자와 상관없이 순위를 산출할 수 있습니다. 기존에 순위를 구할 때에는 Redis 같은 인 메모리 데이터베이스에서 제공하는 Sorted Set 자료 구조로 순위를 산출했지만 유저가 많이 늘어나서 메모리 용량을 벗어나는 경우 개발 및 운영을 하기가 상당히 까다로웠습니다. DynamoDB는 데이터가 늘어나면 알아서 대응을 해줘서 용량에 대해 신경 쓸 필요가 없고 쿼리 속도 또한, 빨라서 상당히 편리합니다.</p><hr>',19);function _(i,k){const r=l("VPCard"),d=l("router-link"),a=l("FontIcon");return u(),g("div",null,[e("h1",f,[e("a",b,[e("span",null,h(i.$frontmatter.title)+" 관련",1)])]),t(r,s(n({title:"목차",desc:"아마존 웹 서비스를 다루는 기술",link:"/aws/art-of-aws/README.md",logo:"https://pyrasis.com/assets/images/pyrasis.png",background:"rgba(31,41,55,0.2)"})),null,16),e("nav",x,[e("ul",null,[e("li",null,[t(d,{to:"#usersleaderboard"},{default:c(()=>[o("UsersLeaderboard")]),_:1})]),e("li",null,[t(d,{to:"#friendsleaderboard"},{default:c(()=>[o("FriendsLeaderboard")]),_:1})])])]),D,t(r,s(n({title:"14장 - 2. DynamoDB에 맞는 데이터 구조 설계하기",desc:"아마존 웹 서비스를 다루는 기술",link:"https://pyrasis.com/book/TheArtOfAmazonWebServices/Chapter14/02",logo:"https://pyrasis.com/favicon.ico",background:"rgba(31,41,55,0.2)"})),null,16),e("p",null,[o("DynamoDB는 "),t(a,{icon:"iconfont icon-mysql"}),o("MySQL, "),t(a,{icon:"iconfont icon-oracle"}),o("Oracle, "),t(a,{icon:"iconfont icon-sqlserver"}),o("SQL Server 등의 RDBMS와는 특성이 다릅니다. 프로젝트 혹은 제품에서 요구하는 기능이 있을 것인데, 그중 DynamoDB에서 효율적으로 처리할 수 있는 요구사항은 DynamoDB에서 처리합니다. RDBMS에서 효율적으로 처리할 수 있는 부분까지 DynamoDB로 이전할 필요는 없습니다.")]),B])}const w=p(y,[["render",_],["__file","14B.html.vue"]]),v=JSON.parse('{"path":"/aws/art-of-aws/14B.html","title":"14B. DynamoDB에 맞는 데이터 구조 설계하기","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"14B. DynamoDB에 맞는 데이터 구조 설계하기","description":"아마존 웹 서비스를 다루는 기술 > 14B. DynamoDB에 맞는 데이터 구조 설계하기","category":["AWS"],"tag":["crashcourse","pyrasis","aws","amazon-web-services"],"head":[[{"meta":null},{"property":"og:title","content":"아마존 웹 서비스를 다루는 기술 > 14B. DynamoDB에 맞는 데이터 구조 설계하기"},{"property":"og:description","content":"14B. DynamoDB에 맞는 데이터 구조 설계하기"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/aws/art-of-aws/14B.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/aws/art-of-aws/14B.html"}],["meta",{"property":"og:site_name","content":"🥁Crashcourse"}],["meta",{"property":"og:title","content":"14B. DynamoDB에 맞는 데이터 구조 설계하기"}],["meta",{"property":"og:description","content":"아마존 웹 서비스를 다루는 기술 > 14B. DynamoDB에 맞는 데이터 구조 설계하기"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"pyrasis"}],["meta",{"property":"article:tag","content":"aws"}],["meta",{"property":"article:tag","content":"amazon-web-services"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"14B. DynamoDB에 맞는 데이터 구조 설계하기\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"UsersLeaderboard","slug":"usersleaderboard","link":"#usersleaderboard","children":[]},{"level":2,"title":"FriendsLeaderboard","slug":"friendsleaderboard","link":"#friendsleaderboard","children":[]}],"git":{"createdTime":1712541541000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":3}]},"readingTime":{"minutes":0.86,"words":259},"filePathRelative":"aws/art-of-aws/14B.md","localizedDate":"2024년 4월 8일","excerpt":"\\n"}');export{w as comp,v as data};
