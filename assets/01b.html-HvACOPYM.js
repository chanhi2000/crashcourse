import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,a as t,t as d,b as e,w as i,e as r,r as s,o as u,d as n}from"./app-U_bew1in.js";const h={},g={id:"frontmatter-title-관련",tabindex:"-1"},p={class:"header-anchor",href:"#frontmatter-title-관련"},f={class:"table-of-contents"},y=r('<hr><h2 id="기본-architecture" tabindex="-1"><a class="header-anchor" href="#기본-architecture"><span>기본 Architecture</span></a></h2><div class="hint-container info"><p class="hint-container-title">오라클은 데이터베이스와 이를 액세스하는 프로세스 사이에 메모리 캐시 영역(SGA)이 있다.</p><figure><img src="https://www.ibm.com/developerworks/data/library/techarticle/dm-0401gupta/fig9.gif" alt="0F" tabindex="0" loading="lazy"><figcaption>0F</figcaption></figure><ul><li>디스크 I/O 에 비해 메모리 캐시 I/O 는 매우 빠르다.</li><li>많은 프로세스가 동시에 데이터를 액세스 하기 때문에 사용자 데이터를 보호하는 Lock 과 공유 메모리 영역인 SGA 에 위치한 데이터 구조 액세스를 직렬화 하기 위한 Latch도 필요.</li><li>오라클은 블록 단위로 I/O 하며, DBWR/CKPT 가 주기적으로 캐시-데이터파일 동기화 수행.</li></ul></div><ul><li><code>Database</code>: 디스크에 저장된 데이터 집합(Datafile, Redo Log File, Control File...)</li><li><code>Instance</code>: SGA(<em>System Global Area</em>) + Process <ul><li><code>Server Process</code>: 사용자 명령 처리 <ul><li>Dedicated Server Process: 클라이언트를 위한 전용 프로세스, 사용자에게 필요한 서비스 제공 (SQL 파싱, 최적화, 실행, 블록 읽기, 읽은 데이터 정렬, 네트워크 전송)</li><li>스스로 처리하지 못하는 일을 만나면 OS, I/O 서브시스템, Background Process 등에 신호를 보내 대신 일을 처리하도록 요청</li></ul></li><li><code>Background Process</code> : 뒤에서 역할 수행</li></ul></li></ul><figure><img src="https://docs.oracle.com/cd/B28359_01/network.111/b28316/img/net81097.gif" alt="오라클 접속할 시 내부 처리 과정" tabindex="0" loading="lazy"><figcaption>오라클 접속할 시 내부 처리 과정</figcaption></figure><ul><li>리스너에 연결 요청 시 서버프로세스를 띄우고(Fork) 메모리(PGA)를 할당 한다. <ul><li>비용이 큰 작업 이므로 성능을 위해 Connection Pool 을 통해 <strong>재사용</strong> 필수</li></ul></li></ul><figure><img src="http://cfile8.uf.tistory.com/image/136E7D504F93100718AF59" alt="Connection Pool" tabindex="0" loading="lazy"><figcaption>Connection Pool</figcaption></figure><figure><img src="http://www.oracle.com/ocom/groups/public/%40otn/documents/digitalasset/112670.gif" alt="RAC" tabindex="0" loading="lazy"><figcaption>RAC</figcaption></figure><ul><li>하나의 데이터베이스를 엑세스 하는 다중 인스턴스로 구성</li><li>과거 공유 디스크 방식, 현재 공유 캐시 방식</li><li>글로벌 캐시 개념 : 로컬 캐시에 없는 데이터 블록을 원격 노드에서 전송 받음</li><li>다른 인스턴스의 Dirty 버퍼도 Interconnect 를 통해 주고 받으며 갱신 수행, OPS 는 디스크로 쓰기 작업 선행 필요 (Ping)</li></ul><figure><img src="http://cfile10.uf.tistory.com/image/271A0D36539481C406A9C9" alt="SQL Trace - 정확한 이해 필요(query, current)" tabindex="0" loading="lazy"><figcaption>SQL Trace - 정확한 이해 필요(query, current)</figcaption></figure><table><thead><tr><th style="text-align:center;">항목</th><th style="text-align:left;">설명</th></tr></thead><tbody><tr><td style="text-align:center;"><code>count</code></td><td style="text-align:left;">수행 횟수</td></tr><tr><td style="text-align:center;"><code>cpu</code></td><td style="text-align:left;">CPU 시간(초)</td></tr><tr><td style="text-align:center;"><code>elapsed</code></td><td style="text-align:left;">수행 시간(초)</td></tr><tr><td style="text-align:center;"><code>disk</code></td><td style="text-align:left;">Physical(Disk) Read Block Count / physical reads</td></tr><tr><td style="text-align:center;"><code>query</code></td><td style="text-align:left;">Consistent Read Block Count / consistent gets</td></tr><tr><td style="text-align:center;"><code>current</code></td><td style="text-align:left;">Current(Dirty) Read Block Count / db block gets</td></tr><tr><td style="text-align:center;"><code>rows</code></td><td style="text-align:left;">Record Count</td></tr></tbody></table><blockquote><p>컬럼 의미</p></blockquote><hr><h2 id="db-버퍼-캐시" tabindex="-1"><a class="header-anchor" href="#db-버퍼-캐시"><span>DB 버퍼 캐시</span></a></h2><p>메모리 캐시 영역(SGA) 중 사용자 데이터가 거쳐 가는 부분</p><h3 id="블록-단위-i-o" tabindex="-1"><a class="header-anchor" href="#블록-단위-i-o"><span>블록 단위 I/O</span></a></h3><div class="hint-container warning"><p class="hint-container-title">설명</p><p>오라클에서 I/O는 블록(Block) 단위로 이뤄짐</p></div><ul><li>single block read / multi block read (<code>Full Scan</code>, <code>DBWR</code>)</li><li>하나 레코드의 하나 컬럼만 읽어도 속한 블록 전체를 읽음</li><li>블록 개수 <ul><li>SQL 성능을 좌우하는 가장 중요한 성능 지표</li><li>옵티마이저의 판단에 가장 큰 영향을 미침 (<code>INDEX SCAN</code> / <code>FULL TABLE SCAN</code>)</li></ul></li></ul><h3 id="버퍼-캐시-구조" tabindex="-1"><a class="header-anchor" href="#버퍼-캐시-구조"><span>버퍼 캐시 구조</span></a></h3><figure><img src="https://docs.oracle.com/database/121/CNCPT/img/GUID-5CE65D12-8850-421F-BAB6-5EC8DE0660B7-default.gif" alt="바둑판처럼 생긴 버퍼 캐시에서 읽고자 하는 블록을 어떻게 찾는가? (해시 테이블)" tabindex="0" loading="lazy"><figcaption>바둑판처럼 생긴 버퍼 캐시에서 읽고자 하는 블록을 어떻게 찾는가? (해시 테이블)</figcaption></figure><ul><li>해시 테이블(해시 맵)은 SGA 내에서 가장 많이 사용되는 자료구조. <ul><li>주소록과 유사 - 성씨가 같은 고객은 같은 페이지(해시 버킷)에 정렬 없이 관리</li><li>해시 버킷 내에서 스캔 방식 사용 (성능을 위해 각 버킷 내 엔트리 개수 일정 수준 유지 필요)</li><li>버퍼 캐시도 해시 테이블 구조로 관리 됨 - 해시 키 값 : DBA(Data Block Address) <ul><li>해시 함수에 DBA 입력해 리턴 받은 해시 값이 같은 블록들을 같은 해시 버킷에 연결 리스트(해시 체인)로 구조화</li><li>필요한 블록 주소를 해시 버킷에서 스캔 후 있으면 읽고, 없으면 디스크에서 읽어 해시 체인에 연결 후 읽음</li></ul></li></ul></li><li>버퍼 헤더만 해시 체인에 연결 됨, 데이터 값은 포인터를 이용해 버퍼 블록을 찾아 얻게 됨</li></ul><figure><img src="https://sites.google.com/site/embtdbo/_/rsrc/1263474372157/wait-event-documentation/oracle-latch-cache-buffers-chains/buffer_cache_steps_to_get_block.PNG" alt="해시함수 예제 : MOD" tabindex="0" loading="lazy"><figcaption>해시함수 예제 : MOD</figcaption></figure><h3 id="캐시-버퍼-체인" tabindex="-1"><a class="header-anchor" href="#캐시-버퍼-체인"><span>캐시 버퍼 체인</span></a></h3><ul><li>각 해시 체인은 Latch 에 의해 보호 됨 <ul><li>DB 버퍼 캐시는 공유 메모리 영역에 존재 하므로 동시 액세스 가능 하며, 액세스 직렬화(Serialization) 메커니즘 필요 (<em>i.e</em>. Latch)</li><li>Latch 를 획득한 프로세스만 그 Latch 에 의해 보호되는 자료구조 진입 허용</li><li>Cache Buffers Chains: 해시 체인에 버퍼 블록을 스캔/연결/해제 작업 보호, 하나의 Latch 가 여러 해시 체인을 동시 보호</li></ul></li></ul><table><thead><tr><th style="text-align:center;">DB버전</th><th style="text-align:center;">Latch 갯수</th></tr></thead><tbody><tr><td style="text-align:center;">9i</td><td style="text-align:center;">241 개</td></tr><tr><td style="text-align:center;">10g</td><td style="text-align:center;">394 개</td></tr><tr><td style="text-align:center;">11g</td><td style="text-align:center;">496 개</td></tr></tbody></table><blockquote><p>DB 버전 별 Latch 갯수</p></blockquote><table><thead><tr><th style="text-align:center;">구분</th><th style="text-align:center;">파라미터</th><th style="text-align:center;">책</th><th style="text-align:center;">실제(11g)</th></tr></thead><tbody><tr><td style="text-align:center;">해시 버킷 개수</td><td style="text-align:center;"><code>_db_block_hash_buckets</code></td><td style="text-align:center;">2,097,152</td><td style="text-align:center;">8,388,608</td></tr><tr><td style="text-align:center;">래치 개수</td><td style="text-align:center;"><code>_db_block_hash_latches</code></td><td style="text-align:center;">65,536</td><td style="text-align:center;">262,144</td></tr><tr><td style="text-align:center;">래치 당 해시 버킷 수</td><td style="text-align:center;">-</td><td style="text-align:center;">32</td><td style="text-align:center;">32</td></tr><tr><td style="text-align:center;">블록 버퍼 개수</td><td style="text-align:center;"><code>_db_block_buffers</code></td><td style="text-align:center;">836,684</td><td style="text-align:center;">3,084,990</td></tr><tr><td style="text-align:center;">해시 버킷 개수 / 블록 버퍼 개수</td><td style="text-align:center;">-</td><td style="text-align:center;">2.5</td><td style="text-align:center;">2.7</td></tr></tbody></table><blockquote><p>해시 버킷, 블록 버퍼, 래치 갯수</p></blockquote><ul><li><p>하나의 해시 체인에 하나의 버퍼만 달리는 것이 목표 임 - 해시 체인 스캔 비용 최소화</p></li><li><p>블록 버퍼 대비 해시 버킷 개수가 충분히 많아야 함 - 2.5배 ?</p></li><li><p>9i 부터 읽기 전용 작업 시 cache buffers chains Latch 를 Share 모드 획득 가능</p><ul><li>SELECT (X), 필요한 블록을 찾기 위한 해시 체인 스캔 (O)</li></ul></li><li><p>버퍼 헤더에 Pin 설정 시 cache buffers chains Latch 사용</p><ul><li>Share 모드 획득 후, 체인 구조 변경 혹은 버퍼 헤더에 Pin 설정 시 Exclusive 모드로 변</li></ul></li></ul><h3 id="캐시-버퍼-lru-체인" tabindex="-1"><a class="header-anchor" href="#캐시-버퍼-lru-체인"><span>캐시 버퍼 LRU 체인</span></a></h3><figure><img src="https://talebzadehmich.files.wordpress.com/2012/03/mru-lru_oracle_pre_922.gif" alt="LRU(Least Recently Used) 알고리즘" tabindex="0" loading="lazy"><figcaption>LRU(Least Recently Used) 알고리즘</figcaption></figure><ul><li>사용 빈도 높은 블록들 위주로 버퍼 캐시가 구성 되도록 함</li><li>모든 버퍼 블록 헤더를 LRU 체인에 연결 <ul><li>사용 빈도 순으로 위치 이동</li><li>Free 버퍼 필요시 액세스 빈도가 낮은 블록을 우선 밀어냄 (자주 액세스 되는 블록이 캐시에 더 오래 남게 됨)</li><li>cache buffers lru chain Latch 로 보호</li></ul></li><li>모든 버퍼 블록은 둘중 하나의 LRU 리스트에 속함 <ul><li>Dirty 리스트 : 캐시 내 변경 됨, 아직 디스크에 반영 안된 블록 관리 (LRUW 리스트) <ul><li>변경 시 리스트에서 잠시 나옴</li></ul></li><li>LRU 리스트 : Dirty 리스트 외 나머지 블록 관리 <ul><li>변경 시 Dirty 리스트로 이동</li></ul></li></ul></li><li>모든 버퍼 블록은 셋중 하나의 상태임 <ul><li>Free 버퍼 : 빈 상태 혹은 데이터 파일과 동기화 된 상태, 언제든 덮어 쓸 수 있음, <ul><li>변경 시 Dirty 버퍼 됨</li></ul></li><li>Dirty 버퍼 : 변경 되어 데이터 파일과 동기화 필요 상태, 동기화 되면 Free 버퍼 됨</li><li>Pinned 버퍼 : 읽기/쓰기 작업 중인 버퍼 블록</li></ul></li></ul><hr><h2 id="버퍼-lock" tabindex="-1"><a class="header-anchor" href="#버퍼-lock"><span>버퍼 Lock</span></a></h2><h3 id="버퍼-lock이란" tabindex="-1"><a class="header-anchor" href="#버퍼-lock이란"><span>버퍼 Lock이란?</span></a></h3><ul><li>하나의 cache buffers chains Latch 에 여러(32) 해시 체인이 보호 되고 있음 (Latch 경합) <ul><li>동시에 버퍼 블록 접근 할 경우 정합성 문제 발생 가능 (직렬화 필요)</li><li>버퍼 블록을 찾으면 버퍼 Lock 설정 후 Latch 해제 (읽기: Share 모드, 변경: Exclusive 모드) <ul><li><code>SELECT</code> 문 도 블록 클린아웃 필요 시 Exclusive 모드 설정</li><li>이미 Exclusive 모드로 점유 된 상태라면 버퍼 헤더의 Lock 대기자 목록(Waiter List) 등록 후 Latch 해제 - buffer busy waits, 선행 버퍼 Lock 해제시 버퍼 Lock 획득</li></ul></li><li>버퍼 블록 Lock 해제 시 Latch 다시 획득 (한개 블록 읽기가 이렇게 고비용)</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">한번 래치 획득 읽기</p><p>블록 읽을 때 대부분 두번 래치 획득 (찾고 Pin 설정, 다쓰고 Pin 해제), 하지만 몇몇 오퍼레이션은 한번만 래치 획득 - consistent gets - examination</p></div><h3 id="버퍼-핸들" tabindex="-1"><a class="header-anchor" href="#버퍼-핸들"><span>버퍼 핸들</span></a></h3><ul><li>버퍼 Lock 은 버퍼 사용중을 표시 (버퍼 헤더에 Pin 설정 / Pinned 버퍼) <ul><li>변경 시 하나의 프로세스만 Pin 가능, 읽기는 동시에 Pin 가능</li><li>버퍼 핸들(Buffer Handle)을 버퍼 헤더에 있는 소유자 목록(Holder List)에 연결 시켜 Pin 설정</li></ul></li><li>cache buffer handles 래치 <ul><li>각 프로세스 마다 <code>_db_handles_cached(5)</code> 개수 만큼 버퍼 핸들 미리 할당</li><li>미리 할당된 갯수 이상의 버퍼 핸들 얻을 때 필요</li><li>시스템 전체 버퍼 핸들 개수 : <code>_db_handles</code> = <code>processes</code> * <code>_db_handles_cached</code></li></ul></li></ul><h3 id="버퍼-lock의-필요성" tabindex="-1"><a class="header-anchor" href="#버퍼-lock의-필요성"><span>버퍼 Lock의 필요성</span></a></h3><ul><li>한개 레코드 갱신도 블록 단위로 I/O를 수행</li><li>정합성 유지를 위해 블록 자체로의 진입을 직렬화 해야 함 <ul><li>블록 내 10개 레코드를 읽는 순간 다른 프로세스에 의해 변경이 발생 하면 잘못된 결과를 얻게 됨</li><li>로우 단위 Lock 설정 도 레코드 속성 변경 이므로 동시 수행은 문제가 됨</li><li>블록 헤더 변경(블록 SCN, ITL 슬롯 등)도 동시 수행은 문제가 됨 (Lost Update 발생)</li></ul></li></ul><div class="hint-container warning"><p class="hint-container-title">Consistent 모드 읽기</p><p>쿼리 SCN 과 블록 SCN 을 비교해 읽어도 되는 블록인지 확인 하면서 읽기 (블록 읽는 도중 블록 내용 변경 대응 불가)</p></div><div class="hint-container tip"><p class="hint-container-title">Pin 된 버퍼 블록</p><ul><li><code>alter system flush buffer_cache;</code> 에도 밀려 나지 않는다.</li><li><code>alter system set events &#39;immediate trace name flush_cache&#39;;</code> (9i)</li></ul></div><h3 id="버퍼-pinning" tabindex="-1"><a class="header-anchor" href="#버퍼-pinning"><span>버퍼 Pinning</span></a></h3><ul><li>버퍼를 읽고 나서 버퍼 Pin을 즉각 해제하지 않고 데이터베이스 Call이 진행되는 동안 유지하는 기능 <ul><li>래치 획득 없이 버퍼를 읽으므로 논리 읽기 횟수가 감소 됨</li></ul></li><li>버퍼 Pinning 발생 지점 <ul><li>인덱스를 스캔하면서 테이블을 액세스할 때의 인덱스 리프 블록 (전통적)</li><li>인덱스로부터 액세스되는 하나의 테이블 블록 (8i)</li><li>NL 조인 시 Inner 테이블을 Lookup 하기 위해 사용되는 인덱스 루트 블록 (9i)</li><li>Index Skip Scan 시 브랜치 블록 (9i)</li><li>NL 조인 시 Inner 테이블의 루트 외 다른 인덱스 블록 (11g)</li><li>DML 수행 시 Undo 블록</li></ul></li></ul><table><thead><tr><th style="text-align:left;">블록 액세스 방법</th><th style="text-align:left;">증가 수치</th></tr></thead><tbody><tr><td style="text-align:left;">래치 획득 후</td><td style="text-align:left;"><code>session logical reads</code></td></tr><tr><td style="text-align:left;">버퍼 Pinning 후</td><td style="text-align:left;"><code>buffer is pinned count</code></td></tr></tbody></table><blockquote><p>블록 액세스 방법 별 증가 수치</p></blockquote><ul><li>버퍼 Pinning 은 하나의 데이터베이스 Call (Parse, Execute, Fetch) 내에서만 유효</li><li>버퍼 Pinning 을 통한 블록 I/O 감소효과는 SQL 튜닝의 중요 부분 <ul><li>Reorg 를 통한 인덱스 클러스터링 팩터 (버퍼 Pinning) 개선 가능</li></ul></li></ul><hr><h2 id="redo" tabindex="-1"><a class="header-anchor" href="#redo"><span>Redo</span></a></h2><table><thead><tr><th style="text-align:center;">Redo 구분</th><th style="text-align:left;">속성</th></tr></thead><tbody><tr><td style="text-align:center;">Online</td><td style="text-align:left;">Redo 로그 버퍼에 버퍼링된 로그 엔트리를 기록하는 파일, 최소 두 개 구성, 라운드 로빈 로그 스위칭 발생</td></tr><tr><td style="text-align:center;">Archived</td><td style="text-align:left;">Online Redo 로그 파일이 재사용 되기 전 다른 위치로의 백업본</td></tr></tbody></table><blockquote><p>데이터/컨트롤 파일의 모든 변경 사항을 하나의 Redo 로그 엔트리로서 Redo 로그에 기록</p></blockquote><div class="hint-container info"><p class="hint-container-title">Redo 목적</p><ol><li>Database Recovery</li><li>Cache Recovery (Instance Recovery)</li><li>Fast Commit</li></ol></div><ul><li>Media Fail 발생 시 데이터베이스 복구 위해 Archived Redo 로그 사용</li><li>인스턴스 비정상 종료 시 휘발성의 버퍼 캐시 데이터 복구 위해 Redo 로그 사용 <ul><li>인스턴스 재기동 시 Online Redo 로그의 마지막 Checkpoint 이후 트랜잭션의 Roll Forward (버퍼 캐시에만 존재했던 변경 사항이 Commit 여부와 관계 없이 복구 됨)</li><li>Undo 데이터를 이용해 Commit 안된 트랜잭션을 Rollback (Transaction Recovery)</li><li>데이터 파일에는 Commit 된 변경 사항만 존재</li></ul></li><li>Fast Commit 을 위해 Redo 로그 사용 <ul><li>메모리의 버퍼 블록이 아직 디스크에 기록되지 않았지만 Redo 로그를 믿고 빠르게 커밋 완료 <ul><li>변경 사항은 Redo 로그에는 바로 기록하고, 버퍼 블록의 메모리-디스크 동기화는 나중에 일괄 수행</li><li>버퍼 블록의 디스크에 기록은 Random 액세스(느림), Redo 로그 기록은 Append 액세스 (빠름)</li></ul></li></ul></li></ul><div class="hint-container warning"><p class="hint-container-title">Delayed 블록 클린아웃</p><ul><li>로우 Lock 이 버퍼 블록 내 레코드 속성으로 구현 되어 있어, Commit 시 바로 로우 Lock 해제 불가능</li><li>Commit 시점에는 Undo 세그먼트 헤더의 트랜잭션 테이블에만 Commit 정보 기록, 블록 클린아웃(Commit 정보 기록, 로우 Lock 해제)은 나중에 수행</li></ul></div><ul><li>Redo 레코드는 Redo 로그 버퍼 → Redo 로그 파일 기록 됨 <ul><li>3초마다 DBWR 로부터 신호 받을 때 (DBWR 은 Dirty 버퍼를 데이터 파일에 기록하기 전 LGWR 에 신호 보냄) - Write Ahead Logging (DBWR 가 Dirty 블록을 디스크에 기록하기 전, LGWR 는 해당 Redo 엔트리를 모두 Redo 로그 파일에 기록 해야 한다.)</li><li>로그 버퍼의 1/3이 차거나, Redo 레코드량이 1MB 넘을 때</li><li>사용자 Commit/Rollback - Log Force at Commit (최소 Commit 시점에는 Redo 정보가 디스크에 저장 되어야 한다.)</li></ul></li></ul><figure><img src="http://cfile24.uf.tistory.com/image/226EF23754F9FE311F02B4" alt="Fast Commit 메커니즘" tabindex="0" loading="lazy"><figcaption>Fast Commit 메커니즘</figcaption></figure><ul><li>사용자 Commit</li><li>LGWR 가 Commit 레코드 Redo 로그 버퍼 기록</li><li>트랜잭션 로그 엔트리와 함께 Redo 로그 파일 기록 (이후 복구 가능)</li><li>사용자 프로세스에 Success Code 리턴</li></ul><div class="hint-container tip"><p class="hint-container-title">log file sync</p><p>LGWR 프로세스가 로그 버퍼 내용을 Redo 로그 파일에 기록 하는 동안 서버 프로세스가 대기하는 현상</p></div><hr><h2 id="undo" tabindex="-1"><a class="header-anchor" href="#undo"><span>Undo</span></a></h2><ul><li>Undo 세그먼트는 일반 세그먼트와 다르지 않다. (Extend 단위 확장, 버퍼 캐시 캐싱, 변경사항 Redo 로깅)</li><li>트랜잭션 별로 Undo 세그먼트가 할당 되고 변경 사항이 Undo 레코드 단위로 기록 됨 (복수 트랜잭션이 한 Undo 세그먼트 공유 가능)</li></ul><table><thead><tr><th style="text-align:center;">구분</th><th style="text-align:left;">설명</th></tr></thead><tbody><tr><td style="text-align:center;"><code>Rollback</code></td><td style="text-align:left;">8i 까지, Rollback 세그먼트 수동 관리</td></tr><tr><td style="text-align:center;"><code>Undo</code></td><td style="text-align:left;">9i 부터, AUM(Automatic Undo Management) 도입</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">AUM</p><ul><li>1 Undo 세그먼트, 1 트랜잭션 목표로 자동 관리</li><li>Undo 세그먼트 부족 시 가장 적게 사용되는 Undo 세그먼트 할당</li><li>Undo 세그먼트 확장 불가 시 다른 Undo 세그먼트로 부터 Free Undo Space 회수 (Dynamic Extent Transfer)</li><li>Undo Tablespace 내 Free Undo Space 가 소진 되면 에러 발생</li></ul></div><h3 id="undo-목적" tabindex="-1"><a class="header-anchor" href="#undo-목적"><span>Undo 목적</span></a></h3><ul><li>Transaction Rollback <ul><li>트랜잭션 Rollback 시 Undo 데이터 사용</li></ul></li><li>Transaction Recovery <ul><li>Instance Recovery 시 Roll Forward 후 Commit 안된 트랜잭션 Rollback 시 Undo 데이터 사용</li></ul></li><li>Read Consistency <ul><li>읽기 일관성을 위해 Undo 데이터 사용 (다른 DB는 Lock 을 통해 읽기 일관성 구현)</li></ul></li></ul><h3 id="undo-세그먼트-트랜잭션-테이블-슬롯" tabindex="-1"><a class="header-anchor" href="#undo-세그먼트-트랜잭션-테이블-슬롯"><span>Undo 세그먼트 트랜잭션 테이블 슬롯</span></a></h3><p>Undo 세그먼트 중 첫 익스텐트, 첫 블록의 Undo 세그먼트 헤더에 트랜잭션 테이블 슬롯이 위치</p><figure><img src="http://blog.itpub.net/attachment/201506/23/7728585_1435048415NuN8.jpg" alt="0O" tabindex="0" loading="lazy"><figcaption>0O</figcaption></figure><ul><li>트랜잭션 테이블 슬롯 기록 사항 <ul><li>트랜잭션 ID: USN(Undo Segment Number)# + Slot# + Wrap#</li><li>트랜잭션 상태 정보 (Transaction Status)</li><li>커밋 SCN (트랜잭션이 커밋 된 경우)</li><li>Last UBA (Undo Block Address)</li><li>기타</li></ul></li><li>트랜잭션 테이블 슬롯(Slot) 할당 및 Active 표시 후 트랜잭션 시작 가능 (대기 이벤트 : undo segment tx slot)</li><li>트랜잭션의 변경사항은 Undo 블록에 Undo 레코드로서 순차적으로 하나씩 기록 됨 (Last UBA[Undo Block Address] 정보로 마지막 Undo 레코드 확인 <ul><li>Undo 레코드는 체인 형태로 연결 되며, Rollback 시 체인을 거슬러 올라가며 작업 수행</li></ul></li><li><code>v$transaction.{used_ublk, used_urec}</code><ul><li>트랜잭션이 사용중인 Undo Block 수, Undo 레코드 수 확인 가능</li></ul></li></ul><table><thead><tr><th>구분</th><th>Undo 레코드 내용</th><th><code>v$transaction.used_urec</code> 증가(TBL)</th><th>v$transaction.used_urec 증가(TBL+IDX)</th><th>비고</th></tr></thead><tbody><tr><td>INSERT</td><td>추가된 레코드 ROWID</td><td>1</td><td>2</td><td>_</td></tr><tr><td>UPDATE</td><td>변경</td><td>컬럼</td><td>Before Image</td><td>1</td></tr><tr><td>DELETE</td><td>전체</td><td>컬럼</td><td>Before Image</td><td>1</td></tr></tbody></table><blockquote><p>DML 별 Undo 레코드 내용</p></blockquote><ul><li>커밋 된 순서대로 트랜잭션 슬롯 순차적 재사용 <ul><li>커밋 안된 Active 상태의 Undo 블록 및 트랜잭션 슬롯은 재사용 안됨</li><li>커밋에 의해 트랜잭션 상태 정보 (committed), 그 시점의 커밋 SCN이 저장된 트랜잭션 슬롯이 재사용 됨</li></ul></li><li>Undo Retention (undo_retention) <ul><li>완료된 트랜잭션의 Undo 데이터를 지정된 시간만큼 &quot;가급적&quot; 유지</li><li>값을 기준으로 unexpired / expired 구분 되며 Undo Extent 필요시 expired 상태의 Extent 먼저 활용, 필요시 unexpired 상태의 Extent 도 활용</li><li>guarantee 옵션 : unexpired 상태의 Extent 활용 불가 <ul><li><code>alter tablespace undotbs1 retention guarantee;</code></li></ul></li><li>Automatic Undo Retention Tuning <ul><li>시스템 상황에 따라 tuned_undo_retention 값 자동 계산 및 Undo Extent 관리 (undo_retention 최소값이 되며 &quot;가급적&quot; 지켜 짐)</li></ul></li></ul></li></ul><h3 id="블록-헤더-itl-슬롯" tabindex="-1"><a class="header-anchor" href="#블록-헤더-itl-슬롯"><span>블록 헤더 ITL 슬롯</span></a></h3><ul><li><p>테이블/인덱스 블록 헤더에는 ITL(Interested Transaction List) 슬롯 존재</p><ul><li>ITL 슬롯 번호</li><li>트랜잭션 ID</li><li>UBA (Undo Block Address)</li><li>커밋 Flag</li><li>Locking 정보</li><li>커밋 SCN (트랜잭션이 커밋 된 경우)</li></ul></li><li><p>레코드 갱신 시 블록 헤더의 ITL 슬롯 확보 후 트랜잭션 ID 및 트랜잭션 Active 상태 기록 선행 필요</p><ul><li>ITL 슬롯 확보 될 때 까지 트랜잭션은 Blocking 됨 (enq: TX - allocate ITL entry)</li><li>ITL 슬롯 수 관련 파라미터 : initrans(1/2), maxtrans(255), pctfree <ul><li><a href="http://ukja.tistory.com/252" target="_blank" rel="noopener noreferrer">INITRANS와 MAXTRANS</a></li></ul></li></ul></li></ul><h3 id="lock-byte" tabindex="-1"><a class="header-anchor" href="#lock-byte"><span>Lock Byte</span></a></h3><ul><li>레코드가 저장되는 로우 헤더에 관련 트랜잭션 ITL 슬롯 번호 기록 하는 Lock Byte 할당</li><li>로우 Lock 구현 = 로우 단위 Lock + 트랜잭션 Lock 조합 (TX Lock)</li><li>레코드 갱신 예제 <ul><li>대상 레코드의 Lock Byte 확인 : 활성화 상태</li><li>ITL 슬롯 의 트랜잭션ID 확인</li><li>트랜잭션 테이블 슬롯 에서 트랜잭션 상태 확인 : 활성화 상태</li><li>대기</li></ul></li><li>Lock 매니저 <ul><li>다른 DBMS 는 Lock 매니저로 갱신 중 레코드 정보 관리, 오라클은 별도 리소스 없음 (레코드 속성)</li><li>Lock 매니저는 유한한 리소스 문제로 로우 → 블럭 → 테이블 레벨로 Lock 에스컬레이션 발생 가능 (급격한 동시성 저하)</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">ITL 슬롯의 UBA(Undo Block Address) 정보</p><p>트랜잭션에 의한 변경 이전 데이터(Before Image)가 저장된 Undo 블록 주소를 가리키는 포인터 정보 (CR Copy 생성 시 사용)</p></div><hr>',79);function b(a,m){const l=s("router-link");return u(),c("div",null,[t("h1",g,[t("a",p,[t("span",null,d(a.$frontmatter.title)+" 관련",1)])]),t("nav",f,[t("ul",null,[t("li",null,[e(l,{to:"#기본-architecture"},{default:i(()=>[n("기본 Architecture")]),_:1})]),t("li",null,[e(l,{to:"#db-버퍼-캐시"},{default:i(()=>[n("DB 버퍼 캐시")]),_:1}),t("ul",null,[t("li",null,[e(l,{to:"#블록-단위-i-o"},{default:i(()=>[n("블록 단위 I/O")]),_:1})]),t("li",null,[e(l,{to:"#버퍼-캐시-구조"},{default:i(()=>[n("버퍼 캐시 구조")]),_:1})]),t("li",null,[e(l,{to:"#캐시-버퍼-체인"},{default:i(()=>[n("캐시 버퍼 체인")]),_:1})]),t("li",null,[e(l,{to:"#캐시-버퍼-lru-체인"},{default:i(()=>[n("캐시 버퍼 LRU 체인")]),_:1})])])]),t("li",null,[e(l,{to:"#버퍼-lock"},{default:i(()=>[n("버퍼 Lock")]),_:1}),t("ul",null,[t("li",null,[e(l,{to:"#버퍼-lock이란"},{default:i(()=>[n("버퍼 Lock이란?")]),_:1})]),t("li",null,[e(l,{to:"#버퍼-핸들"},{default:i(()=>[n("버퍼 핸들")]),_:1})]),t("li",null,[e(l,{to:"#버퍼-lock의-필요성"},{default:i(()=>[n("버퍼 Lock의 필요성")]),_:1})]),t("li",null,[e(l,{to:"#버퍼-pinning"},{default:i(()=>[n("버퍼 Pinning")]),_:1})])])]),t("li",null,[e(l,{to:"#redo"},{default:i(()=>[n("Redo")]),_:1})]),t("li",null,[e(l,{to:"#undo"},{default:i(()=>[n("Undo")]),_:1}),t("ul",null,[t("li",null,[e(l,{to:"#undo-목적"},{default:i(()=>[n("Undo 목적")]),_:1})]),t("li",null,[e(l,{to:"#undo-세그먼트-트랜잭션-테이블-슬롯"},{default:i(()=>[n("Undo 세그먼트 트랜잭션 테이블 슬롯")]),_:1})]),t("li",null,[e(l,{to:"#블록-헤더-itl-슬롯"},{default:i(()=>[n("블록 헤더 ITL 슬롯")]),_:1})]),t("li",null,[e(l,{to:"#lock-byte"},{default:i(()=>[n("Lock Byte")]),_:1})])])])])]),y])}const L=o(h,[["render",b],["__file","01b.html.vue"]]),R=JSON.parse('{"path":"/misc/oracle-sql-db-tuning/01b.html","title":"01B","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"01B","description":"🙆‍♂️DB Server 성능 향상, 분석 및 튜닝 전문가 향상과정 > 01B","category":["Oracle DB"],"tag":["crashcourse","oracle","oracle-db","oracle-sql"],"head":[[{"meta":null},{"property":"og:title","content":"🙆‍♂️DB Server 성능 향상, 분석 및 튜닝 전문가 향상과정 > 01B"},{"property":"og:description","content":"01B"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/assets/misc/oracle-sql-db-tuning/01b.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/misc/oracle-sql-db-tuning/01b.html"}],["meta",{"property":"og:site_name","content":"🥁Crashcourse"}],["meta",{"property":"og:title","content":"01B"}],["meta",{"property":"og:description","content":"🙆‍♂️DB Server 성능 향상, 분석 및 튜닝 전문가 향상과정 > 01B"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-10-03T01:20:13.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"oracle"}],["meta",{"property":"article:tag","content":"oracle-db"}],["meta",{"property":"article:tag","content":"oracle-sql"}],["meta",{"property":"article:modified_time","content":"2024-10-03T01:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"01B\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-03T01:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"기본 Architecture","slug":"기본-architecture","link":"#기본-architecture","children":[]},{"level":2,"title":"DB 버퍼 캐시","slug":"db-버퍼-캐시","link":"#db-버퍼-캐시","children":[{"level":3,"title":"블록 단위 I/O","slug":"블록-단위-i-o","link":"#블록-단위-i-o","children":[]},{"level":3,"title":"버퍼 캐시 구조","slug":"버퍼-캐시-구조","link":"#버퍼-캐시-구조","children":[]},{"level":3,"title":"캐시 버퍼 체인","slug":"캐시-버퍼-체인","link":"#캐시-버퍼-체인","children":[]},{"level":3,"title":"캐시 버퍼 LRU 체인","slug":"캐시-버퍼-lru-체인","link":"#캐시-버퍼-lru-체인","children":[]}]},{"level":2,"title":"버퍼 Lock","slug":"버퍼-lock","link":"#버퍼-lock","children":[{"level":3,"title":"버퍼 Lock이란?","slug":"버퍼-lock이란","link":"#버퍼-lock이란","children":[]},{"level":3,"title":"버퍼 핸들","slug":"버퍼-핸들","link":"#버퍼-핸들","children":[]},{"level":3,"title":"버퍼 Lock의 필요성","slug":"버퍼-lock의-필요성","link":"#버퍼-lock의-필요성","children":[]},{"level":3,"title":"버퍼 Pinning","slug":"버퍼-pinning","link":"#버퍼-pinning","children":[]}]},{"level":2,"title":"Redo","slug":"redo","link":"#redo","children":[]},{"level":2,"title":"Undo","slug":"undo","link":"#undo","children":[{"level":3,"title":"Undo 목적","slug":"undo-목적","link":"#undo-목적","children":[]},{"level":3,"title":"Undo 세그먼트 트랜잭션 테이블 슬롯","slug":"undo-세그먼트-트랜잭션-테이블-슬롯","link":"#undo-세그먼트-트랜잭션-테이블-슬롯","children":[]},{"level":3,"title":"블록 헤더 ITL 슬롯","slug":"블록-헤더-itl-슬롯","link":"#블록-헤더-itl-슬롯","children":[]},{"level":3,"title":"Lock Byte","slug":"lock-byte","link":"#lock-byte","children":[]}]}],"git":{"createdTime":1703642364000,"updatedTime":1727918413000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":5}]},"readingTime":{"minutes":2.5,"words":751},"filePathRelative":"misc/oracle-sql-db-tuning/01b.md","localizedDate":"2023년 12월 27일","excerpt":"\\n\\n<hr>\\n<h2>기본 Architecture</h2>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">오라클은 데이터베이스와 이를 액세스하는 프로세스 사이에 메모리 캐시 영역(SGA)이 있다.</p>\\n<figure><img src=\\"https://www.ibm.com/developerworks/data/library/techarticle/dm-0401gupta/fig9.gif\\" alt=\\"0F\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>0F</figcaption></figure>\\n<ul>\\n<li>디스크 I/O 에 비해 메모리 캐시 I/O 는 매우 빠르다.</li>\\n<li>많은 프로세스가 동시에 데이터를 액세스 하기 때문에 사용자 데이터를 보호하는 Lock 과 공유 메모리 영역인 SGA 에 위치한 데이터 구조 액세스를 직렬화 하기 위한 Latch도 필요.</li>\\n<li>오라클은 블록 단위로 I/O 하며, DBWR/CKPT 가 주기적으로 캐시-데이터파일 동기화 수행.</li>\\n</ul>\\n</div>"}');export{L as comp,R as data};
