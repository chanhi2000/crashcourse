import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as n,t as m,b as a,w as t,n as u,g as d,e as p,d as s,r as o,o as h}from"./app-U_bew1in.js";const v={},k={id:"frontmatter-title-관련",tabindex:"-1"},b={class:"header-anchor",href:"#frontmatter-title-관련"},f={class:"table-of-contents"},x=n("hr",null,null,-1),g=p(`<hr><blockquote><p>Map Rust vector iteration to assembly</p></blockquote><p>Vectors are the most used collection type in Rust. Let us look under the hood to understand the assembly code generated for a vector iteration. We will see that the length of a vector is an important factor in vectorizing the iterations. With vectorization, the processor performs multiple operations per instruction. Finally, we will experiment with the Compiler Explorer to see how the compiler unrolls loops and uses vector instructions to improve performance.</p><h2 id="vector-memory-layout" tabindex="-1"><a class="header-anchor" href="#vector-memory-layout"><span>Vector memory layout</span></a></h2><p>Before we go any further, let us look at the memory layout of a vector. The definition of a vector is shown below. Vectors in Rust contain a pointer to a heap vector buffer (<code>buf.ptr</code>), total capacity of the buffer (<code>buf.cap</code>) and the total length (<code>len</code>) of the vector. The vector buffer is a pointer to a buffer of the type <code>T</code>. The length is the number of elements in the vector. The capacity is the total number of elements that the vector can hold without reallocating the buffer. Note that <code>_marker</code> is 0-sized as it is of the type <code>PhantomData&lt;T&gt;</code>.</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">:</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> <span class="token class-name">Global</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// Points to the start of the vector data and keeps the capacity information</span></span>
<span class="line">    buf<span class="token punctuation">:</span> <span class="token class-name">RawVec</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token operator">&gt;</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token comment">// Length of the vector</span></span>
<span class="line">    len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token type-definition class-name">RawVec</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// Points to the heap address that stores the vector data</span></span>
<span class="line">    ptr<span class="token punctuation">:</span> <span class="token class-name">NonNull</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token comment">// Capacity of the vector</span></span>
<span class="line">    cap<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span></span>
<span class="line">    _marker<span class="token punctuation">:</span> <span class="token class-name">PhantomData</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The following figure shows the memory layout of a vector. The heap pointer (<code>buf.ptr</code>) points to the start of the vector buffer. The vector buffer contains three <code>i64</code>. The length of the vector is 3 (<code>len</code>) and the capacity of the vector is 8 (<code>buf.cap</code>).</p><figure><img src="https://eventhelix.com/rust/rust-to-assembly-vector-iteration/vec-i64.svg" alt="Bool vector" tabindex="0" loading="lazy"><figcaption>Bool vector</figcaption></figure><hr><h2 id="sample-vector-handling-code" tabindex="-1"><a class="header-anchor" href="#sample-vector-handling-code"><span>Sample vector handling code</span></a></h2><p>Let us explore the Rust to assembly mapping of the <code>Vec</code> struct using a simple function, <code>increment_by</code> that increments the elements of a vector by a specified value (<code>num</code>). The sample also includes <code>increment_example</code> that calls the <code>increment_by</code> function.</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token comment">// Increment each element of a i64 vector by num. A mutable</span></span>
<span class="line"><span class="token comment">// reference to the vector is passed in.</span></span>
<span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">increment_by</span><span class="token punctuation">(</span>num<span class="token punctuation">:</span> <span class="token keyword">i64</span><span class="token punctuation">,</span> list<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i64</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// Iterate over the vector and increment each element.</span></span>
<span class="line">    <span class="token keyword">for</span> item <span class="token keyword">in</span> list <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// Note that the item needs to be dereferenced </span></span>
<span class="line">        <span class="token operator">*</span>item <span class="token operator">+=</span> num<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">increment_example</span><span class="token punctuation">(</span>inc_by<span class="token punctuation">:</span> <span class="token keyword">i64</span><span class="token punctuation">,</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">i64</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i64</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token keyword">mut</span> list <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">to_vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">increment_by</span><span class="token punctuation">(</span>inc_by<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    list</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="assembly-code-for-increment-by" tabindex="-1"><a class="header-anchor" href="#assembly-code-for-increment-by"><span>Assembly code for <code>increment_by</code></span></a></h2><p>The generated assembly code for the <code>increment_by</code> function is shown below. The generated assembly code seems quite complex. On close examination, it becomes clear that the code is optimized for operating on vectors of wildly different lengths.</p><p>Let us look at the assembly code that does the heavy lifting for a vector of a certain length. Once we understand these fragments, we will look at the complete assembly to understand how all other lengths are handled by combining these fragments.</p><h3 id="vector-length-less-than-4" tabindex="-1"><a class="header-anchor" href="#vector-length-less-than-4"><span>Vector length less than 4</span></a></h3><p>For vectors that are shorter than 4, the generated assembly code loops over each entry in the vector and increments it by the specified value.</p><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line">.LBB0_11:</span>
<span class="line">        add     qword ptr <span class="token punctuation">[</span>rax<span class="token punctuation">]</span><span class="token punctuation">,</span> rdi    <span class="token comment">; Add num to the next entry in the vector</span></span>
<span class="line">        add     rax<span class="token punctuation">,</span> <span class="token number">8</span>                  <span class="token comment">; Move to the next entry in the vector</span></span>
<span class="line">        cmp     rax<span class="token punctuation">,</span> rcx                <span class="token comment">; Check if we have reached the end of the vector</span></span>
<span class="line">        jne     .LBB0_11                <span class="token comment">; Jump if we have not reached the end of the vector</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vector-length-is-4" tabindex="-1"><a class="header-anchor" href="#vector-length-is-4"><span>Vector length is 4</span></a></h3><p>If the vector length is 4, the compiler unrolls the loop and generates the following assembly code. Vector instructions perform two 64-bit operations in parallel. The <code>movdqu</code> instruction moves the vector data from the vector buffer to an <code>xmm</code> register. The <code>paddq</code> instruction adds the specified value to the vector data. The <code>movdqu</code> instruction moves the vector data back to the vector buffer.</p><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line">.LBB0_7:</span>
<span class="line">        movdqu  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi<span class="token punctuation">]</span>         <span class="token comment">; Load two 64-bit numbers from the vector</span></span>
<span class="line">        movdqu  xmm2<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span>    <span class="token comment">; Load two more 64-bit numbers from the vector</span></span>
<span class="line">        paddq   xmm1<span class="token punctuation">,</span> xmm0                            <span class="token comment">; Add the increment value to the first two 64-bit number</span></span>
<span class="line">        paddq   xmm2<span class="token punctuation">,</span> xmm0                            <span class="token comment">; Add the increment value to the 3rd and 4th of 64-bit number</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1         <span class="token comment">; Store the result back in the vector (1st and 2nd number)</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm2    <span class="token comment">; Store the result back in the vector (3rd and 4th number)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vector-length-is-a-multiple-of-8" tabindex="-1"><a class="header-anchor" href="#vector-length-is-a-multiple-of-8"><span>Vector length is a multiple of 8</span></a></h3><p>For vectors with lengths that are a multiple of 8, the compiler handles 8 64-bit operations per iteration. The 8 64-bit numbers are copied to the <code>xmm</code> registers using four <code>movdqu</code> instructions. Four <code>paddq</code> instructions perform the 8 additions. Finally, the four <code>movdqu</code> instructions copy the results back to the vector buffer.</p><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line">.LBB0_5:</span>
<span class="line">        movdqu  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi<span class="token punctuation">]</span>         <span class="token comment">; Load the first two 64-bit number</span></span>
<span class="line">        movdqu  xmm2<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span>    <span class="token comment">; Load the third and fourth 64-bit number</span></span>
<span class="line">        movdqu  xmm3<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span>    <span class="token comment">; Load the fifth and sixth 64-bit number</span></span>
<span class="line">        movdqu  xmm4<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">48</span><span class="token punctuation">]</span>    <span class="token comment">; Load the seventh and eighth 64-bit number</span></span>
<span class="line">        paddq   xmm1<span class="token punctuation">,</span> xmm0      <span class="token comment">; Add the increment value to the first two 64-bit number</span></span>
<span class="line">        paddq   xmm2<span class="token punctuation">,</span> xmm0      <span class="token comment">; Add the increment value to the third and fourth 64-bit number</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1         <span class="token comment">; Store the first two 64-bit number</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm2    <span class="token comment">; Store the third and fourth 64-bit number</span></span>
<span class="line">        paddq   xmm3<span class="token punctuation">,</span> xmm0      <span class="token comment">; Add the increment value to the fifth and sixth 64-bit number</span></span>
<span class="line">        paddq   xmm4<span class="token punctuation">,</span> xmm0      <span class="token comment">; Add the increment value to the seventh and eighth 64-bit number</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm3    <span class="token comment">; Store the fifth and sixth 64-bit number</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">48</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm4    <span class="token comment">; Store the seventh and eighth 64-bit number</span></span>
<span class="line">        add     rsi<span class="token punctuation">,</span> <span class="token number">64</span>     <span class="token comment">; Increment the 64-bit numbers index</span></span>
<span class="line">        add     rax<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span>     <span class="token comment">; Decrement the count by 2 as 8 64-bit numbers have been processed.</span></span>
<span class="line">        jne     .LBB0_5     <span class="token comment">; Jump if there are still quad 64-bit numbers to process</span></span>
<span class="line">        test    r10b<span class="token punctuation">,</span> <span class="token number">1</span>     <span class="token comment">; Check if there are still entries to process</span></span>
<span class="line">        je      .LBB0_8     <span class="token comment">; Jump if less than 4 entries need to be processed.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="handling-vectors-of-arbitrary-length" tabindex="-1"><a class="header-anchor" href="#handling-vectors-of-arbitrary-length"><span>Handling vectors of arbitrary length</span></a></h3><p>Now that we have analyzed the special cases, let us look at the code below that handles vectors of arbitrary length. The code uses the assembly code blocks we described above. The full code of the function combines the three code blocks to handle vectors of arbitrary length. For example, a vector of length 41 will be handled as.</p>`,26),y=n("ol",null,[n("li",null,[s("Iterate until index 31 ("),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mn",null,"4"),n("mo",null,"∗"),n("mn",null,"8"),n("mo",null,"="),n("mn",null,"32"),n("mi",null,"e"),n("mi",null,"n"),n("mi",null,"t"),n("mi",null,"r"),n("mi",null,"i"),n("mi",null,"e"),n("mi",null,"s")]),n("annotation",{encoding:"application/x-tex"},"4*8=32 entries")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"4"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"∗"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"8"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"="),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6595em"}}),n("span",{class:"mord"},"32"),n("span",{class:"mord mathnormal"},"e"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mord mathnormal"},"t"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),n("span",{class:"mord mathnormal"},"i"),n("span",{class:"mord mathnormal"},"es")])])]),s(") with four loops through that process 8 operations per loop (4 sets of vector operations). The "),n("code",null,".LBB0_5"),s(" label shows the code that performs the four loops.")]),n("li",null,[s("Iterate until index 35 ("),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mn",null,"32"),n("mo",null,"+"),n("mn",null,"4"),n("mi",null,"e"),n("mi",null,"n"),n("mi",null,"t"),n("mi",null,"r"),n("mi",null,"i"),n("mi",null,"e"),n("mi",null,"s")]),n("annotation",{encoding:"application/x-tex"},"32+4 entries")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),n("span",{class:"mord"},"32"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6595em"}}),n("span",{class:"mord"},"4"),n("span",{class:"mord mathnormal"},"e"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mord mathnormal"},"t"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),n("span",{class:"mord mathnormal"},"i"),n("span",{class:"mord mathnormal"},"es")])])]),s(") with the code that processes 4 operations with two vector operations "),n("code",null,".LBB0_7"),s(" label shows this in the assembly of the function.")]),n("li",null,[s("Iterate until index 38 ("),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mn",null,"36"),n("mo",null,"+"),n("mn",null,"3"),n("mi",null,"e"),n("mi",null,"n"),n("mi",null,"t"),n("mi",null,"r"),n("mi",null,"i"),n("mi",null,"e"),n("mi",null,"s")]),n("annotation",{encoding:"application/x-tex"},"36+3 entries")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),n("span",{class:"mord"},"36"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6595em"}}),n("span",{class:"mord"},"3"),n("span",{class:"mord mathnormal"},"e"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mord mathnormal"},"t"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),n("span",{class:"mord mathnormal"},"i"),n("span",{class:"mord mathnormal"},"es")])])]),s(") with the code that processes one iteration per loop. Refer to "),n("code",null,".LBB0_11"),s(" label in the following code.")])],-1),w=p(`<div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line"><span class="token comment">; rsi contains the address of the vector to be incremented.</span></span>
<span class="line">example::increment_by:</span>
<span class="line">        mov     <span class="token register symbol">r9</span><span class="token punctuation">,</span> qword ptr <span class="token punctuation">[</span>rsi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span> <span class="token comment">; r9 now contains the length of the vector</span></span>
<span class="line">        test    <span class="token register symbol">r9</span><span class="token punctuation">,</span> <span class="token register symbol">r9</span>                   <span class="token comment">; Check if the vector is empty</span></span>
<span class="line">        je      .LBB0_12                 <span class="token comment">; Jump if the vector is empty</span></span>
<span class="line">        mov     rcx<span class="token punctuation">,</span> qword ptr <span class="token punctuation">[</span>rsi<span class="token punctuation">]</span>     <span class="token comment">; rcx now contains the address of the vector data</span></span>
<span class="line">        lea     rax<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token register symbol">r9</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>            <span class="token comment">; rax now contains the index of the last entry in the vector.</span></span>
<span class="line">        movabs  rdx<span class="token punctuation">,</span> <span class="token number">2305843009213693951</span> <span class="token comment">; Hex 1FFF_FFFF_FFFF_FFFF</span></span>
<span class="line">        and     rdx<span class="token punctuation">,</span> rax                 <span class="token comment">; rdx contains the index of the last entry in the vector with 3 MSB cleared.</span></span>
<span class="line">        mov     rax<span class="token punctuation">,</span> rcx                 <span class="token comment">; rax now contains the address of the vector data</span></span>
<span class="line">        cmp     rdx<span class="token punctuation">,</span> <span class="token number">3</span>                   <span class="token comment">; Check if the vector has less than 4 entries</span></span>
<span class="line">        jb      .LBB0_10                 <span class="token comment">; Jump if the vector has less than 4 entries</span></span>
<span class="line">        </span>
<span class="line">        <span class="token comment">; ⭐ Handle vectors with 4 or more entries</span></span>
<span class="line">        inc     rdx             <span class="token comment">; Add 1 to the last entry index to get length.</span></span>
<span class="line">        mov     <span class="token register symbol">r8</span><span class="token punctuation">,</span> rdx         <span class="token comment">; r8 now contains the number of items to be processed.</span></span>
<span class="line">        and     <span class="token register symbol">r8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span>          <span class="token comment">; Mask of the lower 2 bits to get the count of entries that is divisible by 4.</span></span>
<span class="line">        movq    xmm0<span class="token punctuation">,</span> rdi       <span class="token comment">; Parameter num, the increment value, is now in xmm0.</span></span>
<span class="line">        pshufd  xmm0<span class="token punctuation">,</span> xmm0<span class="token punctuation">,</span> <span class="token number">68</span>  <span class="token comment">; Make a copy of num to the upper 64 bits to facilitate vector addition.</span></span>
<span class="line">                                <span class="token comment">; 68 = 0100 0100 results in copying the lower 64 bits to the upper 64 bits.</span></span>
<span class="line">                                <span class="token comment">; A reference with detailed description follows the assembly code.</span></span>
<span class="line">        lea     rax<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token register symbol">r8</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">]</span>   <span class="token comment">; rax now is 4 less than the number of items to be processed.</span></span>
<span class="line">        mov     r10<span class="token punctuation">,</span> rax        <span class="token comment">; r10 is now 4 less than the number of items to be processed.</span></span>
<span class="line">        shr     r10<span class="token punctuation">,</span> <span class="token number">2</span>          <span class="token comment">; Divide r10 by 4 to get the index of the last quad 64-bit numbers.</span></span>
<span class="line">        inc     r10             <span class="token comment">; Add 1 to get the count of quad 64-bit numbers.</span></span>
<span class="line">        test    rax<span class="token punctuation">,</span> rax        <span class="token comment">; Check if any more sets of 4 entries are available</span></span>
<span class="line">        je      .LBB0_3         <span class="token comment">; Jump if no more sets of 4 entries are available</span></span>
<span class="line">        mov     rax<span class="token punctuation">,</span> r10        <span class="token comment">; rax now contains the count of quad 64-bit numbers</span></span>
<span class="line">        and     rax<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span>         <span class="token comment">; Mask of the lower 2 bits to get the count of quad 64-bit numbers that is divisible by 4.</span></span>
<span class="line">        xor     esi<span class="token punctuation">,</span> esi        <span class="token comment">; Set the quad 64-bit numbers index to 0</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; ⭐ Process eight 64-bit additions per iteration</span></span>
<span class="line">.LBB0_5:</span>
<span class="line">        movdqu  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi<span class="token punctuation">]</span>         <span class="token comment">; Load the first two 64-bit number</span></span>
<span class="line">        movdqu  xmm2<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span>    <span class="token comment">; Load the third and fourth 64-bit number</span></span>
<span class="line">        movdqu  xmm3<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span>    <span class="token comment">; Load the fifth and sixth 64-bit number</span></span>
<span class="line">        movdqu  xmm4<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">48</span><span class="token punctuation">]</span>    <span class="token comment">; Load the seventh and eighth 64-bit number</span></span>
<span class="line">        paddq   xmm1<span class="token punctuation">,</span> xmm0      <span class="token comment">; Add the increment value to the first two 64-bit number</span></span>
<span class="line">        paddq   xmm2<span class="token punctuation">,</span> xmm0      <span class="token comment">; Add the increment value to the third and fourth 64-bit number</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1         <span class="token comment">; Store the first two 64-bit number</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm2    <span class="token comment">; Store the third and fourth 64-bit number</span></span>
<span class="line">        paddq   xmm3<span class="token punctuation">,</span> xmm0      <span class="token comment">; Add the increment value to the fifth and sixth 64-bit number</span></span>
<span class="line">        paddq   xmm4<span class="token punctuation">,</span> xmm0      <span class="token comment">; Add the increment value to the seventh and eighth 64-bit number</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm3    <span class="token comment">; Store the fifth and sixth 64-bit number</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">48</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm4    <span class="token comment">; Store the seventh and eighth 64-bit number</span></span>
<span class="line">        add     rsi<span class="token punctuation">,</span> <span class="token number">64</span>     <span class="token comment">; Move offset to next entry</span></span>
<span class="line">        add     rax<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span>     <span class="token comment">; Decrement the count by 2 as 8 64-bit numbers have been processed.</span></span>
<span class="line">        jne     .LBB0_5     <span class="token comment">; Jump if there are still quad 64-bit numbers to process</span></span>
<span class="line">        test    r10b<span class="token punctuation">,</span> <span class="token number">1</span>     <span class="token comment">; Check if there are still entries to process</span></span>
<span class="line">        je      .LBB0_8     <span class="token comment">; Jump if less than 4 entries need to be processed.</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; ⭐ Block processing four 64-bit additions</span></span>
<span class="line">.LBB0_7:</span>
<span class="line">        movdqu  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi<span class="token punctuation">]</span>           <span class="token comment">; Load two 64-bit numbers from the vector</span></span>
<span class="line">        movdqu  xmm2<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span>      <span class="token comment">; Load two more 64-bit numbers from the vector</span></span>
<span class="line">        paddq   xmm1<span class="token punctuation">,</span> xmm0                              <span class="token comment">; Add the increment value to the first two 64-bit number</span></span>
<span class="line">        paddq   xmm2<span class="token punctuation">,</span> xmm0                              <span class="token comment">; Add the increment value to the 3rd and 4th of 64-bit number</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1           <span class="token comment">; Store the result back in the vector (1st and 2nd number)</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rcx <span class="token operator">+</span> rsi <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm2      <span class="token comment">; Store the result back in the vector (3rd and 4th number)</span></span>
<span class="line">.LBB0_8:</span>
<span class="line">        cmp     rdx<span class="token punctuation">,</span> <span class="token register symbol">r8</span>                 <span class="token comment">; Check if all entries have been processed</span></span>
<span class="line">        je      .LBB0_12                <span class="token comment">; Jump if all entries have been processed</span></span>
<span class="line">        lea     rax<span class="token punctuation">,</span> <span class="token punctuation">[</span>rcx <span class="token operator">+</span> <span class="token number">8</span><span class="token operator">*</span><span class="token register symbol">r8</span><span class="token punctuation">]</span>       <span class="token comment">; rax now contains the address of the last entry</span></span>
<span class="line">.LBB0_10:</span>
<span class="line">        lea     rcx<span class="token punctuation">,</span> <span class="token punctuation">[</span>rcx <span class="token operator">+</span> <span class="token number">8</span><span class="token operator">*</span><span class="token register symbol">r9</span><span class="token punctuation">]</span>       <span class="token comment">; rcx now contains the address of the last entry in the vector</span></span>
<span class="line">                                        <span class="token comment">; rax points to the first entry in the vector</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; ⭐ Process one 64-bit addition per iteration </span></span>
<span class="line">.LBB0_11:</span>
<span class="line">        add     qword ptr <span class="token punctuation">[</span>rax<span class="token punctuation">]</span><span class="token punctuation">,</span> rdi    <span class="token comment">; Add num to the next entry in the vector</span></span>
<span class="line">        add     rax<span class="token punctuation">,</span> <span class="token number">8</span>                  <span class="token comment">; Move to the next entry in the vector</span></span>
<span class="line">        cmp     rax<span class="token punctuation">,</span> rcx                <span class="token comment">; Check if we have reached the end of the vector</span></span>
<span class="line">        jne     .LBB0_11                <span class="token comment">; Jump if we have not reached the end of the vector</span></span>
<span class="line">.LBB0_12:</span>
<span class="line">        ret</span>
<span class="line">.LBB0_3:</span>
<span class="line">        xor     esi<span class="token punctuation">,</span> esi                <span class="token comment">; esi is now 0</span></span>
<span class="line">        test    r10b<span class="token punctuation">,</span> <span class="token number">1</span>                 <span class="token comment">; Check if one set of quad 64-bit numbers is available</span></span>
<span class="line">        jne     .LBB0_7                 <span class="token comment">; Jump if quad 64-bit numbers are available</span></span>
<span class="line">        jmp     .LBB0_8                 <span class="token comment">; Jump if less than 4 64-bit numbers are available</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>pshufd</code> shuffling options that are explained <a href="https://reverseengineering.stackexchange.com/questions/20338/how-do-the-pshuflw-and-pshufd-instructions-work" target="_blank" rel="noopener noreferrer">in a stack exchange article</a>.</p></blockquote><hr><h2 id="assembly-code-for-increment-example" tabindex="-1"><a class="header-anchor" href="#assembly-code-for-increment-example"><span>Assembly code for <code>increment_example</code></span></a></h2><p>We have looked at the code generated for <code>increment_by</code>. Now let us examine a call to the function from the <code>increment_example</code> function.</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">increment_example</span><span class="token punctuation">(</span>inc_by<span class="token punctuation">:</span> <span class="token keyword">i64</span><span class="token punctuation">,</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">i64</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i64</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token keyword">mut</span> list <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">to_vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">increment_by</span><span class="token punctuation">(</span>inc_by<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    list</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Looking at the code for <code>increment_example</code> we can see that the generated assembly code is a lot simpler than that for <code>increment_by</code> function. We also see that there is no call to <code>increment_by</code>, the relevant code from the function has been inlined into <code>increment_example</code>. We are seeing a lot of compiler optimizations at work here.</p><ul><li>The compiler figures out that inlining the <code>increment_by</code> function would reduce a function call.</li><li>Once the compiler decides to inline, it sees that the vector will only be of length 4. The compiler decides that it does not need to bring in the complexity of handling any arbitrary length vector. The compiler optimizes the inlined code to be a lot faster by just including the handling for a vector of length 4.</li><li>The compiler also unrolls the loop to process four 64-bit additions.</li></ul><p>Also, note that the assembly code for <code>increment_example</code> calls <code>__rust_alloc</code> for allocating the vector data on the heap. If the memory allocation fails, the function throws an exception using the <code>ud2</code> instruction.</p><div class="language-armasm line-numbers-mode" data-highlighter="prismjs" data-ext="armasm" data-title="armasm"><pre><code><span class="line">.LCPI1_0:</span>
<span class="line">        .quad   <span class="token number">4</span>               <span class="token comment">; Vector length</span></span>
<span class="line">        .quad   <span class="token number">4</span>               <span class="token comment">; Vector capacity</span></span>
<span class="line">example::increment_example:</span>
<span class="line">        push    r15             <span class="token comment">; Save r15 on the stack</span></span>
<span class="line">        push    r14             <span class="token comment">; Save r14 on the stack</span></span>
<span class="line">        push    rbx             <span class="token comment">; Save rbx on the stack</span></span>
<span class="line">        mov     r15<span class="token punctuation">,</span> rdx        <span class="token comment">; r15 = address of the array</span></span>
<span class="line">        mov     r14<span class="token punctuation">,</span> rsi        <span class="token comment">; r14 = inc_by</span></span>
<span class="line">        mov     rbx<span class="token punctuation">,</span> rdi        <span class="token comment">; rbx = address of vector on the stack</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; 📦 Allocate memory for the vector buffer</span></span>
<span class="line">        mov     edi<span class="token punctuation">,</span> <span class="token number">32</span>       <span class="token comment">; edi = number of 64-bit numbers to process</span></span>
<span class="line">        mov     esi<span class="token punctuation">,</span> <span class="token number">8</span>          <span class="token comment">; esi = byte alignment is at 8 bytes</span></span>
<span class="line">        call    qword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> __rust_alloc@GOTPCREL<span class="token punctuation">]</span> <span class="token comment">; The allocated heap address is in rax</span></span>
<span class="line">        test    rax<span class="token punctuation">,</span> rax <span class="token comment">; Check if the allocation failed</span></span>
<span class="line">        je      .LBB1_1  <span class="token comment">; Jump if the allocation failed</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; ⭐ Copy the array to the vector</span></span>
<span class="line">        mov     qword ptr <span class="token punctuation">[</span>rbx<span class="token punctuation">]</span><span class="token punctuation">,</span> rax            <span class="token comment">; Store the address of the vector in the vector buffer</span></span>
<span class="line">        movups  xmm0<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>r15<span class="token punctuation">]</span>         <span class="token comment">; Vectot load the first two 64-bit numbers from the array</span></span>
<span class="line">        movups  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>r15 <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span>    <span class="token comment">; Vector load the third and fourth 64-bit numbers from the array</span></span>
<span class="line">        movups  xmmword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1    <span class="token comment">; Vector store the third and fourth 64-bit numbers in the vector</span></span>
<span class="line">        movups  xmmword ptr <span class="token punctuation">[</span>rax<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm0         <span class="token comment">; Vector store the first two 64-bit numbers in the vector</span></span>
<span class="line">        movaps  xmm0<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> .LCPI1_0<span class="token punctuation">]</span> <span class="token comment">; Load the vector length and capacity</span></span>
<span class="line">        movups  xmmword ptr <span class="token punctuation">[</span>rbx <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm0     <span class="token comment">; Store the vector length and capacity in the vector</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; ⭐ Increment the vector</span></span>
<span class="line">        movq    xmm0<span class="token punctuation">,</span> r14                       <span class="token comment">; Load the increment value</span></span>
<span class="line">        pshufd  xmm0<span class="token punctuation">,</span> xmm0<span class="token punctuation">,</span> <span class="token number">68</span>                  <span class="token comment">; The increment value is now copied to the lower and upper 64-bits of xmm0</span></span>
<span class="line">        movdqu  xmm1<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rax<span class="token punctuation">]</span>         <span class="token comment">; Load the first two 64-bit numbers from the vector</span></span>
<span class="line">        movdqu  xmm2<span class="token punctuation">,</span> xmmword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span>    <span class="token comment">; Load the third and fourth 64-bit numbers from the vector</span></span>
<span class="line">        paddq   xmm1<span class="token punctuation">,</span> xmm0                      <span class="token comment">; Add the increment value to the first two 64-bit numbers</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rax<span class="token punctuation">]</span><span class="token punctuation">,</span> xmm1         <span class="token comment">; Store the first two 64-bit numbers in the vector</span></span>
<span class="line">        paddq   xmm2<span class="token punctuation">,</span> xmm0                      <span class="token comment">; Add the increment value to the third and fourth 64-bit numbers</span></span>
<span class="line">        movdqu  xmmword ptr <span class="token punctuation">[</span>rax <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xmm2    <span class="token comment">; Store the third and fourth 64-bit numbers in the vector</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">; ⭐ Return the vector</span></span>
<span class="line">        mov     rax<span class="token punctuation">,</span> rbx        <span class="token comment">; Return the vector in rax</span></span>
<span class="line">        pop     rbx             <span class="token comment">; Restore rbx</span></span>
<span class="line">        pop     r14             <span class="token comment">; Restore r14</span></span>
<span class="line">        pop     r15             <span class="token comment">; Restore r15</span></span>
<span class="line">        ret                     <span class="token comment">; Return the vector in rax</span></span>
<span class="line">.LBB1_1:</span>
<span class="line"><span class="token comment">; 💀 Allocation failure handler</span></span>
<span class="line">        mov     edi<span class="token punctuation">,</span> <span class="token number">32</span>         <span class="token comment">; edi = Size of the attempted allocation</span></span>
<span class="line">        mov     esi<span class="token punctuation">,</span> <span class="token number">8</span>          <span class="token comment">; esi = Alignment is at 8 bytes</span></span>
<span class="line">        call    qword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> alloc::alloc::handle_alloc_error@GOTPCREL<span class="token punctuation">]</span> <span class="token comment">; Call the allocation failure handler</span></span>
<span class="line">        ud2                     <span class="token comment">; Use the ud2 instruction to throw an exception</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="experiment-in-the-compiler-explorer" tabindex="-1"><a class="header-anchor" href="#experiment-in-the-compiler-explorer"><span>Experiment in the Compiler Explorer</span></a></h2><p>Now let us <a href="https://godbolt.org/z/q7G3nerPd" target="_blank" rel="noopener noreferrer">experiment with the vector iteration example in the Compiler Explorer</a>.</p><ul><li>In the <code>increment_example</code> function, change <code>array: [i64; 4]</code> (line 12) and see how the compiler handles different array lengths: <ul><li><code>array: [i64; 128]</code> - The compiler unrolls the loop even for 128 entries!</li><li><code>array: [i64; 256]</code> - The compiler generates an efficient loop that performs 8 64-bit additions in a single iteration of the loop.</li><li><code>array: [i64; 257]</code> - 256 operations are performed in the loop and the remaining one operation is performed outside the loop.</li></ul></li><li>Change the compiler options to use the AVX-512 instruction set using the flag setting <code>-C opt-level=3 -C target_cpu=skylake-avx512</code> (change in the edit box on the top right). The compiler generates code that uses the <code>vaddq</code> instruction to perform 4 64-bit additions with a single instruction. <ul><li><code>array: [i64; 256]</code> - With the AVX-512 instruction set, the compiler generates an efficient loop that performs 16 64-bit additions in a single iteration of the loop.</li></ul></li><li>In the <code>increment_by</code> function, change <code>*item += num</code> to <code>*item *= num</code> (line 8) and see the dramatic impact on the generated code. <ul><li>The compiler does not try to optimize for different vector lengths. It generates a single loop with that performs the multiplication.</li></ul></li></ul><hr><h2 id="key-takeaways" tabindex="-1"><a class="header-anchor" href="#key-takeaways"><span>Key Takeaways</span></a></h2><ul><li>When the length of a vector is not known at compile time, the generated code performs runtime length checks to pick the most efficient loop.</li><li>When the length of the vector is known at compile time, the compiler can generate more efficient code as it does not need to perform runtime length checks to pick the right looping option. The compiler can unroll the loop even for a large number of iterations.</li><li>The compiler can generate more efficient code when the vector is a multiple of 8 or 16 elements.</li><li>Vector creation involves dynamic memory allocation. The compiler generates code that panics when the allocation fails.</li><li>Target a more recent CPU architecture to get more efficient code. The compiler can generate code that uses the AVX-512 instruction set to perform 4 64-bit operations with a single instruction.</li></ul>`,17);function _(l,q){const e=o("router-link"),c=o("VPCard");return h(),r("div",null,[n("h1",k,[n("a",b,[n("span",null,m(l.$frontmatter.title)+" 관련",1)])]),n("nav",f,[n("ul",null,[n("li",null,[a(e,{to:"#vector-memory-layout"},{default:t(()=>[s("Vector memory layout")]),_:1})]),n("li",null,[a(e,{to:"#sample-vector-handling-code"},{default:t(()=>[s("Sample vector handling code")]),_:1})]),n("li",null,[a(e,{to:"#assembly-code-for-increment-by"},{default:t(()=>[s("Assembly code for increment_by")]),_:1}),n("ul",null,[n("li",null,[a(e,{to:"#vector-length-less-than-4"},{default:t(()=>[s("Vector length less than 4")]),_:1})]),n("li",null,[a(e,{to:"#vector-length-is-4"},{default:t(()=>[s("Vector length is 4")]),_:1})]),n("li",null,[a(e,{to:"#vector-length-is-a-multiple-of-8"},{default:t(()=>[s("Vector length is a multiple of 8")]),_:1})]),n("li",null,[a(e,{to:"#handling-vectors-of-arbitrary-length"},{default:t(()=>[s("Handling vectors of arbitrary length")]),_:1})])])]),n("li",null,[a(e,{to:"#assembly-code-for-increment-example"},{default:t(()=>[s("Assembly code for increment_example")]),_:1})]),n("li",null,[a(e,{to:"#experiment-in-the-compiler-explorer"},{default:t(()=>[s("Experiment in the Compiler Explorer")]),_:1})]),n("li",null,[a(e,{to:"#key-takeaways"},{default:t(()=>[s("Key Takeaways")]),_:1})])])]),x,a(c,u(d({title:"Map Rust vector iteration to assembly",desc:"Learn how to map Rust vector iteration to assembly. Also understand how the compiler optimizes the loop with vector instructions.",link:"https://eventhelix.com/rust/rust-to-assembly-vector-iteration",logo:"https://eventhelix.com/images/EventHelix-white-rounded-bg-blue.png",background:"rgba(250,250,250,0.2)"})),null,16),g,y,w])}const T=i(v,[["render",_],["__file","rust-to-assembly-vector-iteration.html.vue"]]),A=JSON.parse('{"path":"/rust/eventhelix-rust-to-assembly/rust-to-assembly-vector-iteration.html","title":"Map Rust vector iteration to assembly","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Map Rust vector iteration to assembly","description":"Rust to Assembly > Map Rust vector iteration to assembly","category":["Rust"],"tag":["crashcourse","digitalocean","eventhelix","rust","rs","wasm","assembly"],"head":[[{"meta":null},{"property":"og:title","content":"Rust to Assembly > Map Rust vector iteration to assembly"},{"property":"og:description","content":"Map Rust vector iteration to assembly"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/rust/eventhelix-rust-to-assembly/rust-enum-and-match-representation-in-assembly.html"}],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/crashcourse/rust/eventhelix-rust-to-assembly/rust-to-assembly-vector-iteration.html"}],["meta",{"property":"og:site_name","content":"🥁Crashcourse"}],["meta",{"property":"og:title","content":"Map Rust vector iteration to assembly"}],["meta",{"property":"og:description","content":"Rust to Assembly > Map Rust vector iteration to assembly"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://eventhelix.com/rust/rust-to-assembly-vector-iteration/vec-i64.svg"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-03-20T07:03:32.000Z"}],["meta",{"property":"article:tag","content":"crashcourse"}],["meta",{"property":"article:tag","content":"digitalocean"}],["meta",{"property":"article:tag","content":"eventhelix"}],["meta",{"property":"article:tag","content":"rust"}],["meta",{"property":"article:tag","content":"rs"}],["meta",{"property":"article:tag","content":"wasm"}],["meta",{"property":"article:tag","content":"assembly"}],["meta",{"property":"article:modified_time","content":"2024-03-20T07:03:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Map Rust vector iteration to assembly\\",\\"image\\":[\\"https://eventhelix.com/rust/rust-to-assembly-vector-iteration/vec-i64.svg\\"],\\"dateModified\\":\\"2024-03-20T07:03:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Vector memory layout","slug":"vector-memory-layout","link":"#vector-memory-layout","children":[]},{"level":2,"title":"Sample vector handling code","slug":"sample-vector-handling-code","link":"#sample-vector-handling-code","children":[]},{"level":2,"title":"Assembly code for increment_by","slug":"assembly-code-for-increment-by","link":"#assembly-code-for-increment-by","children":[{"level":3,"title":"Vector length less than 4","slug":"vector-length-less-than-4","link":"#vector-length-less-than-4","children":[]},{"level":3,"title":"Vector length is 4","slug":"vector-length-is-4","link":"#vector-length-is-4","children":[]},{"level":3,"title":"Vector length is a multiple of 8","slug":"vector-length-is-a-multiple-of-8","link":"#vector-length-is-a-multiple-of-8","children":[]},{"level":3,"title":"Handling vectors of arbitrary length","slug":"handling-vectors-of-arbitrary-length","link":"#handling-vectors-of-arbitrary-length","children":[]}]},{"level":2,"title":"Assembly code for increment_example","slug":"assembly-code-for-increment-example","link":"#assembly-code-for-increment-example","children":[]},{"level":2,"title":"Experiment in the Compiler Explorer","slug":"experiment-in-the-compiler-explorer","link":"#experiment-in-the-compiler-explorer","children":[]},{"level":2,"title":"Key Takeaways","slug":"key-takeaways","link":"#key-takeaways","children":[]}],"git":{"createdTime":1703642364000,"updatedTime":1710918212000,"contributors":[{"name":"chanhi2000","email":"chanhi2000@gmail.com","commits":5}]},"readingTime":{"minutes":10.77,"words":3230},"filePathRelative":"rust/eventhelix-rust-to-assembly/rust-to-assembly-vector-iteration.md","localizedDate":"2023년 12월 27일","excerpt":"\\n\\n<hr>\\n"}');export{T as comp,A as data};
